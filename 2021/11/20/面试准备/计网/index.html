<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 5.4.0">

  

  

  
    <meta name="author" content="ChenZehong">
  

  

  

  <title>计算机网络篇 | 大三下</title>

  

  
    <link rel="shortcut icon" href="/happy.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/19a1b73a4f201a00a3da538a73add9bd--2226138859.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          大三下
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">计算机网络篇</h1>
          <h2 class="title-sub-wrap">
            <strong>ChenZehong</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2021-11-20T12:43:32.637Z" itemprop="datePublished">2021-11-20</time>
          </h2>
          <ul class="wrap-list dark">
  
    <li><a href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">📒 面试准备</a></li>
  
</ul>
          <ul class="wrap-list dark">
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <ul>
<li>知道哪些计算机网络模型？OSI 和 TCP/IP</li>
</ul>
<p>OSI模型一共有七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP模型有五层：应用层（HTTP协议、DNS协议、FTP协议）、传输层（TCP协议、UDP协议）、网络层（IP协议）、数据链路层、物理层</p>
<ul>
<li>TCP协议与UDP协议的区别：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/26468b56ce599668.png"></p>
<ul>
<li>UDP协议为什么不可靠：</li>
</ul>
<p>1、不保证信息交付：不确认、不重传、无超时</p>
<p>2、不保证交付顺序：不设置包序号，不重排，不会发生队首堵塞</p>
<p>3、不跟踪连接状态：不必建立连接或重启状态机</p>
<p>4、不进行拥塞控制：不内置客户端或网络反馈机制</p>
<ul>
<li>TCP的重传机制：</li>
</ul>
<p>由于TCP的下层网络层可能出现丢失、重复或者失序的情况，为保证数据传输的正确性，TCP会重传认为已丢失的包。TCP在发送一个数据之后会开启一个定时器，若是在这个时间内没有收到发送数据的确认应答，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。TCP使用两套独立的机制来完成重传，一个是基于时间，一个是基于确认信息。</p>
<p>超时重传（RTO）：超时重传时间应该略大于报文往返的RRT值。实际上RTO是经常变化的，因为我们的网络也是经常变化的。</p>
<p>快速重传：不以时间为驱动，而是以数据为驱动重传。快速重传的工作方式就是当收到三个相同的ACK报文时吗，会在定时器过期之前，重传丢失的报文。为了解决是重传之前的一个还是重传所有的问题，于是有了SACK方法。</p>
<p>选择性确认（SACK）：这种方式只需要在TCP头部字段中加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据接收到了，然后重传丢失的数据。</p>
<p>D-SACK：可以让发送方知道是发出去的包丢了哈市接收方回应的ACK包丢了，还可以知道是不是发送方的数据包被网络延迟了；还可以知道网络中是不是把发送方的数据包复制了。</p>
<ul>
<li>Cookie Session Token的原理</li>
</ul>
<p>cookie的原理：</p>
<ol>
<li>客户端第一次发送请求时发送数据到服务器</li>
<li>服务器返回响应消息的同时传回一个cookie</li>
<li>客户端接收到服务器的响应后将cookie存放在一个统一的地方</li>
<li>客户端再次向服务器发送请求时会把cookie写进请求头然后发给服务器</li>
</ol>
<p>session的原理：</p>
<ol>
<li>服务器在处理客户端请求过程中会创建session，并为session生成一个唯一的ID</li>
<li>服务器将sessionID发送给客户端</li>
<li>当客户端再次发送请求时会带上这个sessionID</li>
<li>服务器接收到请求之后会根据ID找到相对应的session，完成请求</li>
</ol>
<p>token的原理：</p>
<ol>
<li>客户端第一次请求时，发送用户信息到服务器，服务器对用户信息使用加密算法和密钥进行签名，再将这个签名和数据一起作为token返回给客户端</li>
<li>服务端不再保存token，客户端保存token</li>
<li>当客户端再次发送请求时在请求信息中将token一起发送给服务器</li>
<li>服务器使用相同的加密算法和密钥对数据再进行一次签名，和token的签名作比较</li>
<li>如果相同则知道客户端登录过</li>
</ol>
<ul>
<li>跨域：</li>
</ul>
<p>同源：指域名、协议、端口相同</p>
<p>跨域就是指浏览器不能执行其他网站的脚本，是浏览器对Javascript实施的安全限制。之所以有同源策略是浏览器对于用户安全的考虑，会导致Cookie、LocalStorage无法读取，DOM和JS对象无法获取、Ajax请求发送不出去。</p>
<p>解决跨域的方法：</p>
<p>1、jsonp是利用script脚本不受同源策略的限制</p>
<p>2、CORS（跨域资源共享）</p>
<p>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头origin;后端在接收到请求确定响应后会在响应头加上Access-Control-Allow-Origin。浏览器判断响应中的Access-Control-Allow-Origin与当前地址值是否相同，匹配成功则继续相应处理，否则报错。</p>
<p>需要浏览器和服务器的支持，浏览器在发送请求时在请求头中添加origin字段，然后在服务器里面配置Access-Control-Allow-Origin，服务器接收到请求时会根据origin字段在Access-Control-Allow-Origin查找，如果有则允许跨域，没有则不允许。</p>
<p>3、代理跨域请求</p>
<p>前端发送请求经过代理，请求需要的服务器资源</p>
<p>4、HTML5 postMessage方法</p>
<p>允许来自不同源的脚本采用异步方式进行有限的通信</p>
<p>5、基于HTML5的websocket协议</p>
<p>基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求</p>
<ul>
<li>HTTP缓存：</li>
</ul>
<p>有效减少网络请求的体积和数量</p>
<p>强缓存：在第一次请求返回的响应头中添加cache-control，设置max-age有效时间，这样当发送下一次请求时如果在有效期内则直接在缓存中获取资源。</p>
<p>协商缓存：服务器端缓存策略，在第一次发送请求的响应头中加入资源标识，如果第二次请求发现资源并没有修改过则返回304状态码直接从缓存中获取资源。如果资源已经修改则返回200状态码和最新的资源以及最新的资源标识。资源标识有last-modified和etag，last-modified对应需要在第二次请求的请求中中添加if-modified-since；etag对应需要在第二次请求的请求中中添加if-none-match。</p>
<p>etag优先级更高，因为last-modified只能精确到秒，而且文件如果隔一段时间重复生成即使内容相同last-modified会每次返回资源文件，而etag可以判断内容相同则返回304从缓存中获取资源。</p>
<ul>
<li>js事件循环：</li>
</ul>
<p>浏览器由很多模块组成，有解析html和css的模块，有解析js的模块，有定时器模块，有ajax模块。<br>其中v8引擎就是用来解析js的，js是单线程是因为v8引擎是单线程，当v8引擎解析到异步代码时，比如定时器，就会把异步代码交给相关的模块处理，处理完之后，再交给事件队列中排队，当执行栈有空时，消息队列就把事件交给调用栈执行。拿定时器来说，当v8引擎从上往下执行代码，读到定时器的时候。就会把定时器交给定时器模块处理，然后v8引擎继续执行代码，定时器模块会计时，当时间到了，就会把任务交给事件队列，当执行栈有空闲时，事件队列就会把任务推给执行栈，执行栈执行完毕之后将其弹出。如果是promise回调函数则是添加进微任务队列中，当执行栈为空时将任务推给执行栈执行。</p>
<p>优先级是执行栈&gt;微任务队列&gt;事件队列</p>
<ul>
<li>GET 和 POST 的区别：</li>
</ul>
<p>GET是通过URl传递参数，post是通过请求体传递参数</p>
<p>GET请求在url中是有长度限制的，而post没有</p>
<p>get比post不安全，因为参数是直接暴露在url中的，所以不能传递敏感信息</p>
<p>get是一个幂等的请求不会产生对服务器资源产生影响，post不是一个幂等的请求一般用以对服务器资源产生影响的情景，如注册用户</p>
<p>get请求参数会被完整地保留在浏览器的历史记录里，而post不会</p>
<ul>
<li>post请求与put请求的区别：</li>
</ul>
<p>put请求是向服务器端发送数据，从而修改数据的内容，但是不会更新数据的种类，可以理解为更新数据</p>
<p>post请求是向服务器发送数据，该请求会改变数据的种类等资源，它会创建新的内容。</p>
<ul>
<li>常见http请求头：</li>
</ul>
<p>Accept：浏览器可处理的内容类型</p>
<p>Accept-Charset：浏览器能够显示的字符集</p>
<p>Accept-Encoding：浏览器能够处理的压缩编码</p>
<p>Connection：浏览器与服务器之间连接的类型</p>
<p>Cookie：当前页面设置的任何Cookie</p>
<p>Host：发出请求页面所在的域</p>
<p>Referer：发出请求的页面的URL</p>
<p>User-Agent：浏览器的用户代理字符串</p>
<ul>
<li>常见http响应头：</li>
</ul>
<p>Date：发送消息的时间</p>
<p>server：服务器名称</p>
<p>Cache-Control：控制http缓存</p>
<p>content-type：表示后面的文档属于什么MIME类型</p>
<ul>
<li>http码是304多好还是不好？</li>
</ul>
<p>304是协商缓存中服务器向客户端返回，允许客户端调用缓存内容的状态码，它不是一种错误。</p>
<p>但是当304状态码多了之后，搜 索引擎蜘蛛可能会降低对网站的抓取次数，相反如果每次抓取都能获取新内容，回访率也会增加。</p>
<ul>
<li>options的主要用途：</li>
</ul>
<p>获取服务器支持的所有http请求方法</p>
<p>用来检查访问权限，例如在进行CORS进行跨域资源共享时，对于复杂请求就是使用options方法发送嗅探请求，以判断是否有对指定资源的访问权限</p>
<ul>
<li>http1.0与http1.1之间的区别：</li>
</ul>
<p>连接方面：1.0使用非持久连接，1.1使用持久长连接，支持多个http请求使用同一个tcp连接</p>
<p>资源请求方面：1.0中当客户端需要某个对象的一部分，服务器只能一整个对象，而1.1中引入range允许只请求资源的某个部分，返回码是206</p>
<p>缓存方面：1.0主要使用If-Modified-Since、Expries来作为缓存判断的标准，1.1则引入了Etag、if-Undified-Since、If-Match、If-None-Match等更多缓存头来控制缓存策略</p>
<p>1.1新增了host字用来指定服务器的域名，同时新增了许多请求方法，如PUT、HEAD等</p>
<ul>
<li>1.1与2.0的区别：</li>
</ul>
<p>2.0使用了多路复用，允许在一个tcp连接里客户端与服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，避免队头堵塞</p>
<p>2.0使用了二进制协议，规定头信息和数据体都是二进制</p>
<p>2.0使用了数据流的概念，它将每个情感求或回应的所有数据包称为一个数据流</p>
<p>2.0使用了头信息压缩，由于1.1协议不带状态，每次请求都必须附上全部信息，所以请求的很多字段都是重复的，这既浪费带款也影响速度</p>
<p>2.0允许服务器端主动向客户端推送必要的资源，这样可以减少延迟时间，推送的是静态资源</p>
<ul>
<li>http协议与https协议的区别：</li>
</ul>
<p>https协议需要ca证书，费用较高，而http协议不需要</p>
<p>http协议是超文本传输协议，信息是明文传输；https协议是具有安全性的ssl加密传输协议</p>
<p>使用不同的连接方式，端口也不同，http协议是80端口，https协议是443</p>
<p>http协议连接时无状态的，https协议是有ssl和http协议构建的可进行加密传输 、身份认证的网络协议，更加安全</p>
<ul>
<li>对keep-alive的理解：</li>
</ul>
<p>keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，可以避免建立或者重新建立连接，这就会长连接</p>
<p>1.0默认是没有keep-alive的要想连接得到保持需要手动配置connection:keep-allive字段，关闭则发送connection:close字段</p>
<p>1.1规定了默认保持长连接</p>
<ul>
<li>keep-alive的建立过程：</li>
</ul>
<ol>
<li>客户端向服务器在发送请求报文同时在首部添加connection字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送connection:keep-alive字段给客户端</li>
<li>客户端收到connection字段</li>
<li>keep-alive建立成功 </li>
</ol>
<ul>
<li>开启keep-alive的优点：</li>
</ul>
<p>较少的CPU和内存的使用（由于同时打开的连接少了）</p>
<p>允许请求和应答的http管线化</p>
<p>降低拥塞控制（tcp连接少了）</p>
<p>减少了后续请求的延迟（无需再进行握手）</p>
<ul>
<li>缺点：</li>
</ul>
<p>长时间的连接容易导致系统资源无效占用，浪费系统资源</p>
<ul>
<li>http状态码：</li>
</ul>
<p>2开头：请求成功处理（200：请求成功处理，一般用于get与post请求；201：已创建，成功请求并创建了新的资源；202：已接受，已经接受请求但是未处理成功；204：成功处理请求但是无内容返回）</p>
<p>3开头：重定向相关（301：永久性重定向，返回信息会包括新的url，浏览器会自动定向到新的url；302：暂时性重定向；304：协商缓存时返回的状态码，当允许从本地读取缓存时返回）</p>
<p>4开头：客户端错误（400：客户端请求的语法错误，服务器无法理解；401：请求要求用户的身份认证；403：服务端理解用户客户端请求但是拒绝执行；404：服务器无法根据客户端请求找到资源）</p>
<p>5开头：服务端错误（500：服务器不支持请求的功能，无法完成请求；505：服务器不支持此请求http版本，无法完成处理）</p>
<ul>
<li>同样是重定向，307,302,303的区别：</li>
</ul>
<p>302是http1.0的状态码，在http1.1版本中为了细化302状态码多出了303与307。303表示客户端应当采用get方法获取资源，它会把post请求变为get请求进行重定向；307表示遵照浏览器标准，不会从post变为get方法。</p>
<ul>
<li>JS数据为什么分别存在栈和堆：</li>
</ul>
<p>在JS中栈是用来存储基本类型数据的，如boolean、number、string等，这些数据类型在栈内存中分别占有固定大小的空间，我们通过值来对数据进行访问，基本数据类型在当前执行环境结束时就会在栈中销毁；由于引用类型大小不固定所以不能保存在栈中，所以使用堆来对引用数据类型进行保存，而在栈中保存这些引用类型的地址，这样当查询引用数据类型的变量时就会先从栈中读取内存地址然后再去堆中找到相应的值。堆中的数据是不会对执行环境结束而销毁的，只有当所有引用它的变量不存在时这个对象才会被回收机制回收。</p>
<ul>
<li>如何设置httponly：</li>
</ul>
<p>在服务器返回响应头的cookie中添加http only属性为true</p>
<ul>
<li>TCP三次握手：</li>
</ul>
<p>浏览器先向服务器发送一个SYN包以及seq序列号，然后服务器接收到syn包后也向浏览器发送一个syn包以及ACK确认应答，然后浏览器接收到服务器发来的包后再向服务器发送一个确认应答，此包发送完毕后客户端与服务器连接成功，三次握手结束。</p>
<ul>
<li>TCP四次挥手：</li>
</ul>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放报文首部FIN=1，序列号seq等于前面传送过来的数据最后一个字节的序号+1，此时客户端进入终止等待状态1。</li>
<li>服务器收到连接释放报文后发出确认应答ACK，并且带上自己的序列号，然后服务器进入等待关闭状态</li>
<li>客户端收到服务器的确认应答后客户端进入终止等待状态2，等待服务器发送连接释放报文</li>
<li>服务器将最后的数据发送完毕后向客户端发送连接释放报文，此时服务器进入最后确认状态，等待客户端的确认</li>
<li>客户端收到服务器的连接释放报文后向服务器发送确认应答，此时客户端进入时间等待状态，等待一段时间后才进入关闭状态</li>
<li>服务器收到客户端的确认 应答后立即进入关闭状态，服务器结束TCP连接的时间要比客户端早一些</li>
</ol>
<ul>
<li>为什么需要四次挥手：</li>
</ul>
<p>因为当服务器接收到客户端的连接释放报文后需要发送确认应答ACK与FIN包，但是由于服务器接收到报文之后还有数据需要传输，所以先发送一个确认应答，等到数据全部发送完了才能够发送FIN报文。（FIN报文是终结连接请求）</p>
<ul>
<li>浏览器渲染过程：</li>
</ul>
<p>1、根据HTML构建DOM树</p>
<p>2、根据CSS构建stylesheet</p>
<p>3、将DOM树与stylesheet合并为渲染树</p>
<p>4、根据渲染树来布局，以计算每个节点的几何信息</p>
<p>5、将各个节点绘制到屏幕上</p>
<ul>
<li>在浏览器输入baidu.com并且按下回车之后发生了什么：</li>
</ul>
<p>1、解析url：首先对url进行解析，分析所需要的传输协议和请求的资源路径，如果输入的url中的协议或者主机名不合法将会把地址栏输入的内容传递给搜索引擎。如果没问题就会检查url中是否出现了非法字符，如果存在非法字符则对非法字符进行转义后再进行下一过程。</p>
<p>2、缓存判断：浏览器会判断所请求的资源是否在缓存里，如果在缓存里并且没有失效，就直接使用，否则向服务器发起新的请求。</p>
<p>3、DNS解析：下一步首先需要获取输入的url的域名的ip地址，首先会先判断浏览器是否有该域名的ip地址的缓存，如果有则使用，没有则继续所搜操作系统的DNS缓存，如果没有再向本地DNS服务器发起请求。本地的服务器会先检查是否存在缓存，没有就会向根域名服务器发起请求，获得负责的顶级域名服务器的地址后再向顶级域名服务器发起请求，然后获得负责的权威域名服务器地址后再向权威域名服务器发起请求最终获得域名的IP地址，本地DNS服务器再将这个ip地址返回给请求的用户。</p>
<p>4、获得MAC地址：当浏览器得到ip地址后，数据传输还需要知道目的主机MAC地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的ip地址作为目的地址然后下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，本机的MAC作为源MAC地址，目的MAC地址需要分情况处理。通过将IP地址与本机的子网掩码相比较可以判断是否与请求主机在同一子网中，如果在同一子网中可以使用APR协议获取到目的主机的MAC地址，如果不在一个子网中那么请求应该转发给网关，由它代为转发，此时同样可以通过APR协议来获取网关的Mac地址，此时目的主机的MAC地址应该为网关的地址</p>
<p>5、TCP三次握手：首先客户端向服务器发送一个SYN连接请求报文段和一个随机序列号，服务器接收到请求后向客户端发送一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收到确认应答后进入连接建立状态，同时向服务器发送一个ACK确认报文段，服务器接收到确认后，也进入连接建立状态，此时双方连接就建立起来了</p>
<p>6、https握手：如果使用的是https协议，在通信前还存在一个TLS的四次握手过程。首先客户端向服务器发送使用协议的版本号、一个随机数和可以使用的加密方法。服务器接收到之后确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端接收到之后首先检查数字证书是否有效，如果有效则再生成一个随机数并使用证书中的公钥对随机数加密，然后发送给服务器，并且还会提供一个前面所有内容的hash值给服务器进行检验。服务器接收后使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的hash值给客户端检验，这个时候双方都有了三个随机数，按照之前所约定的加密方法使用这三个随机数生成一把密钥以后双方通信前就使用这个密钥对数据进行加密后再传输</p>
<p>7、返回数据：当页面请求发送到服务器后，服务器会返回一个html文件作为响应，浏览器接收到响应后开始对文件进行解析，开始页面的渲染过程</p>
<p>8、页面渲染：浏览器首先会根据html文件构建DOM树，根据解析到的css文件构建 CSSOM树，如果遇到script标签则判断是否含有defer或者async属性，不然script标签的加载和执行会造成页面的渲染的阻塞。当DOM数和CSSOM树建立好之后根据他们来构建渲染树。渲染树构建好之后会根据渲染树进行布局。布局完成后最后使用浏览器的ui接口对页面进行绘制，这个时候页面就显示出来了。</p>
<p>9、TCP四次挥手：最后一步是TCP断开连接的四次挥手过程。若客户端认为数据发送完毕需要向服务器发送连接释放请求，服务器收到连接释放请求后会告诉应用层要释放TCP连接，然后发送ACK包，并进入CLOSE_WAIT状态，此时表明客户端到服务器的连接已经释放不再接受客户端发来的数据。因为TCP连接是双向的所以服务器仍旧可以发送数据给客户端。服务器如果此时还有没发完的数据会继续发送完毕后向客户端发送释放连接请求，然后服务器进入LAST-ACK状态，客户端收到释放请求后向服务器发送确认应答，此时客户端进入TIME-WAIT状态，该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间超时会被抛弃）时间。若时间段内没有服务器的重发请求的话就进入CLOSED状态，当服务器收到确认应答后也进入CLOSED状态。</p>
<ul>
<li>页面中有多张图片，http是怎样加载的：</li>
</ul>
<p>在http1下，浏览器对一个域名下最大TCP连接数是6，可以使用多域名部署解决，这样可以提高同时请求的数目，加快页面图片的获取速度</p>
<p>在http2下，可以一瞬间加载出来很多资源因为http2支持多路复用，可以在一个TCP连接中发送多个http请求</p>
<ul>
<li>http2的头部压缩算法是怎样的：</li>
</ul>
<p>http2的头部压缩算法是HPCK算法，在客户端与服务器两端建立字典，用索引表示重复的字符串，采用哈弗曼编码来压缩整数和字符串可以达到50%~90%的压缩率</p>
<p>具体来说：</p>
<p>在客户端与服务器使用首部表来跟踪和存储之前发送的键值对，对于相同的数据不再通过每次请求和响应发送</p>
<p>首部表在http2的连接存续期内始终存在，由客户端与服务器共同渐近的更新</p>
<p>每个新的首部键值要么被追加到当前表的末尾要么替换表中之前的值</p>
<ul>
<li>说一下http3.0：</li>
</ul>
<p>http3是基于udp协议实现类似于tcp的多路复用数据流，传输可靠等功能，这套功能被称为QUIC协议</p>
<p>1、流量控制。传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制以及其他tcp中的特性</p>
<p>2、集成TCP加密功能：目前QUIC使用TLS1.3减少了握手所花费的RTT数</p>
<p>3、多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头堵塞问题</p>
<p>4、快速握手：由于基于UDP可以实现使用0~1个RRT来建立连接</p>
<ul>
<li>队头堵塞：</li>
</ul>
<p>http传输的报文必须是一发一收，但是里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会堵塞后面的请求的处理，这就是队头堵塞</p>
<p>队头阻塞的解决方案：</p>
<p>1、并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其他所有任务</p>
<p>2、域名分片：将域名分出很多二级域名，他们都指向同样的一台服务器，能够并发的长连接数量变多，解决了队头堵塞的问题</p>
<ul>
<li>TLS/SSL的工作原理：</li>
</ul>
<p>TLS/SSL称为安全传输层协议，是介于TCP与HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能主要依赖三类基本算法：散列函数hash、对称加密和非对称加密，作用如下：</p>
<p>基于散列函数验证信息的完整性；对称加密算法采用协商的密钥对数据加密；非对称加密实现身份认证和密钥加密</p>
<p>散列函数：常见的散列函数有MD5、SHA1、SHA256，该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以防止信息篡改并验证信息的完整性。</p>
<p>对称加密：对称加密的方法是双方使用同一个密钥对数据进行加密和解密，但是对称加密的一个问题就是如何保证密钥传输的安全性，因为密钥还是会通过网络传输，一旦密钥被其他人获取到，那么整个加密过程就毫无作用了，这就要用到非对称加密</p>
<p>非对称加密：我们拥有两个密钥一个是私钥一个是公钥，公钥是公开的，私钥是保密的，用私钥加密的数据只有对应的公钥才能解密，用公钥加密的数据只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户都可以使用我们提供的公钥对数据进行加密然后我们使用私钥进行解密，这样就能保证数据的安全了。掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信。但是有一个缺点就是加密的过程很慢。</p>
<p>TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的密钥，对称加密算法采用协商密钥对信息以及信息摘要进行加密通信。</p>
<ul>
<li>数字证书是什么：</li>
</ul>
<p>因为没有办法确定得到的公钥就一定是安全的，可能存在一个中间人，截取了对方发给我们的公钥然后将它自己的公钥发送给我们，当我们使用它的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后伪装成我们以同样的方法向对方发送信息这样我们的信息就被窃取了。为了解决这个问题可以使用数字证书。</p>
<p>首先使用一种hash算法对公钥和其他信息进行加密，生成一个消息摘要，然后让有公信力的认证中心（CA）用它的私钥对消息摘要进行加密形成签名，最后将原始信息与签名合成在一起，称之为数字证书。当接收方接收到证书时，先根据原始信息使用同样的hash算法生成一个摘要，然后使用公证处的公钥对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>一般浏览器会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<ul>
<li>https的通信过程（握手过程）：</li>
</ul>
<p>1、客户端向服务器发起请求，请求中包含使用的协议版本号，生成的一个随机数，以及客户端支持的加密方法</p>
<p>2、服务器接收到请求后，确认双方使用的加密方法，并给出服务器的证书，以及一个服务器生成的随机数</p>
<p>3、客户端确认服务器的证书有效后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发给服务器，并且还会提供一个前面所有内容的hash值，用来供服务器检验</p>
<p>4、服务器使用自己的私钥，来解密客户端发送过来的随机数，并提供前面所有内容的hash值来供客户端检验</p>
<p>5、客户端和服务器根据自己约定的加密方法使用前面三个随机数，生成对话密钥，以后的对话过程都使用这个密钥进行加密信息。</p>
<ul>
<li>DNS协议是什么：</li>
</ul>
<p>DNS是域名系统，提供一种主机名到IP地址的转换服务，它是由一个分层的DNS服务器组成的 分布式数据库，定义了主机如何查询这个分布式数据库的方式的应用层协议。</p>
<p>作用：将域名解析为IP地址，客户端向DNS服务器发送域名查询请求，DNS服务器告知客户端服务器的IP地址。</p>
<ul>
<li>DNS同时使用TCP与UDP协议：</li>
</ul>
<p>1、在区域传输的时候使用TCP协议：辅域名服务器会定时向主域名服务器查询以便了解数据是否有变动，如有变动会执行一次区域传送，进行数据同步。TCP是一种可靠连接，保证了数据的准确性。</p>
<p>2、在域名解析的时候使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容不超过512字节，用UDP协议传送即可。因为不用经过三次握手所以响应DNS服务器负载更低，响应更快。</p>
<ul>
<li>DNS完整的查询过程：</li>
</ul>
<p>1、首先会在浏览器缓存中查找对应的IP地址，找到则返回，否则进入下一步</p>
<p>2、将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，找到则返回，否则进入下一步</p>
<p>3、本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</p>
<p>4、本地DNS服务器向顶级域名服务器发送请求，接收请求的服务器查询自己的缓存，如果有记录则返回查询结果，否则返回 相关的下一级的权威服务器的地址</p>
<p>5、本地DNS服务器向权威服务器发送请求，域名服务器返回对应的结果</p>
<p>6、本地DNS服务器将返回的结果保存在缓存中便于下次使用 </p>
<p>7、本地DNS服务器将返回结果返回给浏览器、、</p>
<ul>
<li>DNS解析是包含递归查询与迭代查询的过程：</li>
</ul>
<p>递归查询：查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果，使用递归查询用户只需要发出一次查询请求</p>
<p>迭代查询：查询请求后，域名服务器返回单次查询的结果，下一级查询由用户自己请求，使用迭代查询用户需要发起多次的查询请求</p>
<p>一般我们向本地DNS服务器发送请求的方式是递归查询，而本地服务器向其他域名服务器请求的过程是迭代请求的过程。</p>
<ul>
<li>说说常见的content-type：</li>
</ul>
<p><em>text/html：html格式</em></p>
<p><em>text/plain：纯文本格式</em></p>
<p><em>image/gif：gif格式</em></p>
<p><em>application/json：json数据格式</em></p>
<p><em>application/pdf：pdf数据格式</em></p>
<p><em>application/msword：word文档格式</em></p>
<p><em>application/octet-stream：二进制流格式</em></p>
<p><em>application/x-www-form-unlencoded：表单的默认提交数据格式，将键值对的参数使用&amp;连接起来，如果有空格则转换为+号，如有特殊字符则进行转义。</em></p>
<p><em>mulitipart/form-data：需要在表单中进行二进制文件上传时，需要使用该格式，也可用于键值对参数，最后连接成一串字符传输。</em></p>
<ul>
<li>URL有哪些组成部分：</li>
</ul>
<p>协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分（从？到#之间的部分都是参数部分，参数之间用&amp;作为分隔符）、锚部分（从#开始到最后都是锚部分）。</p>
<ul>
<li>HTTPS的特点：</li>
</ul>
<p><strong>优点：</strong></p>
<p>1、可以认证用户和服务器，确保数据发送到正确的客户端和服务器</p>
<p>2、可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取，修改，保证数据的安全性</p>
<p>3、不是绝对安全的但是大幅增加了中间人攻击的成本</p>
<p><strong>缺点：</strong></p>
<p>1、需要做服务器与客户端双方的加密解密处理，耗费更多的服务器资源，过程复杂</p>
<p>2、握手阶段比较费时，增加页面加载时间</p>
<p>3、SSL证书是收费的，功能越强大的证书费用越高</p>
<p>4、连接服务器资源占用高很多，支持访客稍多的网站需要投入更多的成本</p>
<p>5、需要绑定IP，不能在同一个IP绑定多个域名</p>
<ul>
<li>说一说什么是大端、小端，如何判断大端和小端 </li>
</ul>
<p>1、字节序</p>
<p><strong>字节顺序</strong>，又称<strong>端序</strong>或<strong>尾序</strong>（英语：<strong>Endianness</strong>）。在计算机科学计算机科学”)领域中，是跨越多字节的程序对象的存储规则。<br>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>2、大小端</p>
<p>在计算机中一般讲字节序分为两类：Big-Endian（大端字节序） 和Little-Endian。<br>a) Little-Endian 高位字节在前，低位字节在后。<br>b) Big-Endian 低位字节在前，高位字节在后。<br>c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</p>
<ul>
<li>XSS攻击是什么？</li>
</ul>
<p>XSS是跨站脚本攻击(Cross Site Scripting)，不写为CSS是为了避免和层叠样式表（Cascading Style Sheets）的缩写混淆，所以将跨站脚本攻击写为XSS。攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。XSS的危害一般是泄露用户的登录信息cookie，攻击者可以通过cookie绕过登录步骤直接进入站点。XSS的分类分为反射型和存储型。反射型就是临时通过url访问网站，网站服务端将恶意代码从url中取出，拼接在HTML中返回给浏览器，用户就会执行恶意代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。预防XSS攻击的方案基本是对数据进行严格的输出编码，比如HTML元素的编码，JavaScript编码，css编码，url编码等等。</p>
<p>加分回答</p>
<p>XSS的危害：</p>
<p>•  获取cookie：网站中的登录一般都是用cookie作为某个用户的身份证明，这是服务器端返回的一串字符。如果cookie被攻击者拿到，那么就可以绕过密码登录。当空间、论坛如果可以被插入script代码，那么进入空间或者论坛的人的账号就可以轻易被攻击者获取。</p>
<p>•  恶意跳转：直接在页面中插入window.location.href进行跳转。</p>
<p>XSS的分类：<br>•  反射型XSS（非持久型XSS）：通过URL参数直接注入<br>•  存储型XSS（持久型XSS）：存储到数据库后读取时注入</p>
<p>XSS的预防：</p>
<p>•  浏览器的防御和“X-XSS-Protection”有关，默认值为1，即默认打开XSS防御，可以防御反射型的XSS，不过作用有限，只能防御注入到HTML的节点内容或属性的XSS，例如URL参数中包含script标签。不建议只依赖此防御手段。</p>
<p>•  防御HTML节点内容，通过转义&lt;为&amp;lt以及&gt;为&amp;gt来实现防御HTML节点内容。</p>
<p>•  预防HTML属性，通过转义”-&gt;&amp;quto来实现防御，一般不转义空格，但是这要求属性必须带引号。</p>
<p>•  预防JavaScript代码，通过将数据进行JSON序列化。</p>
<p>•  防御富文本是比较复杂的工程，因为富文本可以包含HTML和script，这些难以预测与防御，建议是通过白名单的方式来过滤允许的HTML标签和标签的属性来进行防御，大概的实现方式是：</p>
<p>1、将HTML代码段转成树级结构的数据<br>2、遍历树的每一个节点，过滤节点的类型和属性，或进行特殊处理<br>3、处理完成后，将树级结构转化成HTML代码</p>
<p>•  开启浏览器XSS防御：Http Only cookie，禁止 JavaScript 读取某些敏感 Cookie，攻击者完成XSS注入后也无法窃取此 Cookie。</p>
<ul>
<li>合法的IPv4 或 IPv6 地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 合法的IPv4:</span><br><span class="line">1.1 .分割为4组</span><br><span class="line">1.2 每组不为空</span><br><span class="line">1.3 每组长度 &lt;= 3</span><br><span class="line">1.4 每组在0~255之间</span><br><span class="line">1.5 每组不包含前导0, 除非本身为0</span><br><span class="line">/^[1-9]\d&#123;0,2&#125;$/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2. 合法的IPv6:</span><br><span class="line">2.1 : 分割为8组</span><br><span class="line">2.2 每组不为空</span><br><span class="line">2.3 每组长度 &lt;=4</span><br><span class="line">2.4 每组为一个16进制数: 即字符范围为: 0~9, a~f, A~F</span><br><span class="line">/^[0-9a-fA-F]&#123;1,4&#125;$/</span><br></pre></td></tr></table></figure>

<ul>
<li>说一说进程通信的方式有哪些？</li>
</ul>
<p>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：</p>
<ol>
<li><p>管道</p>
<p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</p>
</li>
<li><p>命名管道</p>
<p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
</li>
<li><p>信号</p>
<p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>消息队列</p>
<p>消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。</p>
</li>
<li><p>共享内存</p>
<p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
</li>
<li><p>内存映射</p>
<p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
</li>
<li><p>信号量</p>
<p>信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</p>
</li>
<li><p>Socket</p>
<p>套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</p>
</li>
</ol>
<ul>
<li>UDP(用户数据报协议)是什么？</li>
</ul>
<p>UDP是OSI参考模型中的传输层协议，是一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>UDP协议有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说UDP协议不能得知报文是否安全完成到达，由于UDP协议只负责将应用程序给IP层的数据报发送出去，不用在客户端与服务器之间建立连接且没有超时重发等机制，所以UDP协议的传输速度很快。</p>
<p>绝大部分UDP应用都不需要可靠机制，甚至可能因为引入可靠机制降低性能，比如流媒体、即时多媒体游戏等应用。如果一个应用需要很高的可靠性可以选择TCP协议。</p>
<ul>
<li>TCP协议的流量控制：</li>
</ul>
<p>流量控制就是为了让发送方发送数据的速度不要太快，TCP采用大小可变的滑动窗口进行流量控制。</p>
<p>当一个连接建立时，连接的每一端会分配一个缓冲区来保存输入的数据并将缓冲区的大小发送给另一端；当数据到达时接收方发送确认其中包含自己剩余的缓冲区大小；如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告；如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口，发送方收到一个零窗口通告的时候必须停止发送，直到接收方重新通告一个正的窗口。</p>
<ul>
<li>TCP的拥塞控制：</li>
</ul>
<p>TCP的拥塞控制算法包含了：慢启动，拥塞避免，快速重传，快速恢复</p>
<p>慢启动：开始的时候不要发送大量数据，先测试一下网络的拥塞程度，由小到大增加拥塞窗口（cwnd）的大小。为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（sssthresh）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当cwnd&lt;sssthresh时，使用慢开始算法</span><br><span class="line">当cwnd=sssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</span><br><span class="line">当cwnd》sssthresh时，使用拥塞避免算法</span><br></pre></td></tr></table></figure>

<p>拥塞避免：让拥塞窗口缓慢的增大，每经过一个返回时间RRT就把发送方的拥塞控制窗口加一。无论是慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为拥塞时发送窗口大小的一半，然后拥塞窗口设置为1，执行慢开始算法。</p>
<p>快速重传：要求接收方在收到一个失序的报文段后就立即发出重复确认，发送方只要一连续收到三个重复的确认应发就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器时间到期。</p>
<p>快速恢复：当发送方连续收到三个重复确认就执行乘法减小算法，将门限减半，然后接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<ul>
<li>进程与线程</li>
</ul>
<p>进程是操作系统资源分配的基本单位；线程是进程的一个执行单元，是处理器任务调度和执行的基本单位。</p>
<p>线程共享本进程的地址空间和资源，但进程之间是独立的地址空间；</p>
<p>在一个进程中一个线程奔溃会导致整个进程都死掉，但是多进程中一个进程奔溃不会影响其他进程；</p>
<p>每个独立的进程有程序运行的入口、执行顺序和程序出口；但线程是依存在应用程序中的，由应用程序提供多个线程执行控制，两者均可并发执行。</p>
<ul>
<li>线程切换为什么比进程切换容易？</li>
</ul>
<p>操作系统需要保存进程运行所需要的所有状态信息，也就是进程的上下文。在任何时刻，单处理器系统只能执行一个进程，所以当操作系统将控制权从一个进程切换到另一个进程时，需要保存原先进程的上下文，并恢复新进程的上下文，然后将控制权传递给新进程。</p>
<p>但是对线程而言，进程内的所有线程共享进程的虚拟地址空间，在线程进行切换时不会涉及虚拟地址空间的切换。</p>
<ul>
<li>计算机的原码、反码、补码</li>
</ul>
<p>原码就是符号位加上真值的绝对值</p>
<p>反码的话，正数的反码是它本身，负数的反码就是符号位不变，其余各个位取反</p>
<p>补码的话，正数的补码是它本身，负数的补码就是符号位不变，其余各个位取反，最后+1</p>

      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202107/6c6c2317050c2adfbd8f0fe2f41d2e59--2227376625.jpg"></div>
    
    <div class="card-text">
      
        <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Vue/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">Vue篇</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
      <div class="card-cover" background-image-lazy data-img="http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202105/8cdc6ed3420d690280e291bb30f0adda--2098717666.jpg"></div>
    
    <div class="card-text">
      
        <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JavaScript/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">JavaScript篇</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  
    <div class="valine-container comments-container content-padding--primary soft-size--large soft-style--box">
      <div id="valine_thread" class="valine-thread"></div>
    </div>
    <script type="text/javascript" src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script type="text/javascript" src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <script type="text/javascript">
      new Valine({
        el: "#valine_thread",
        appId: "zPxT1BH5qC6JYqXmizvClRGk-gzGzoHsz",
        appKey: "kU1QKKjUJco1Gyjj0Usl4bwM",
        avatar: "ChenZehong",
        placeholder: "随便说点什么叭～",
        notify: true,
        visitor: true,
        pageSize: 10,
      });
    </script>
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202007/f9c696aa27edaddf87257e5e70d1eb62--1437661584.jpg" class="soft-size--round soft-style--box" alt="ChenZehong">
    
    
      <h2>ChenZehong</h2>
    
    
      <p>贵在坚持</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>15</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        6
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        1
      </div>
    </div>
  </div>
</section>

      

      

      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/categories/TensorFlow-js/">
            TensorFlow.js (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">
            大三寒假日报 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">
            大三上日报 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">
            网站介绍 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">
            面试准备 (9)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%AE%97%E6%B3%95/">
            算法 (2)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;" class="tags-cloud-0">介绍</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/Web200OK" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">ChenZehong</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->




  


  


  <!-- Baidu Analytics START -->
  <script>
    var _hmt = _hmt || [];
    (function () {
      if (window.location.hostname === "localhost" || window.location.hostname.startsWith("192.168")) {
        return console.log("本地调试");
      }
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a923e14e6dbf862c2b287e6c1266764";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <!-- Baidu Analytics End -->

  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>