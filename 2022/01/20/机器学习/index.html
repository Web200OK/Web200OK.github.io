<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>神经网络 | 大三下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="神经网络的层：  第一层称为输入层，节点数量取决于数据集中存在的特征数量 最后一层称为输出层，数量取决于要预测的内容，对于回归和二元分类任务可以使用单个节点；对于多类问题，将使用多个节点，具体取决于类的数量 中间的层称为隐藏层，隐藏层可以任意深或宽，计算时间会随深入而增加  权重与偏差：  权重：衡量某个特征对预测的贡献程度的确定程度 偏差：预测必须从其开始的基值  激活函数：  激活函数由神经">
<meta property="og:type" content="article">
<meta property="og:title" content="神经网络">
<meta property="og:url" content="http://example.com/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="大三下">
<meta property="og:description" content="神经网络的层：  第一层称为输入层，节点数量取决于数据集中存在的特征数量 最后一层称为输出层，数量取决于要预测的内容，对于回归和二元分类任务可以使用单个节点；对于多类问题，将使用多个节点，具体取决于类的数量 中间的层称为隐藏层，隐藏层可以任意深或宽，计算时间会随深入而增加  权重与偏差：  权重：衡量某个特征对预测的贡献程度的确定程度 偏差：预测必须从其开始的基值  激活函数：  激活函数由神经">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-01-20T14:30:12.238Z">
<meta property="article:modified_time" content="2022-01-24T01:12:45.308Z">
<meta property="article:author" content="ChenZehong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="大三下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">大三下</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-机器学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-01-20T14:30:12.238Z" itemprop="datePublished">2022-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TensorFlow-js/">TensorFlow.js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      神经网络
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>神经网络的层：</li>
</ul>
<p>第一层称为输入层，节点数量取决于数据集中存在的特征数量</p>
<p>最后一层称为输出层，数量取决于要预测的内容，对于回归和二元分类任务可以使用单个节点；对于多类问题，将使用多个节点，具体取决于类的数量</p>
<p>中间的层称为隐藏层，隐藏层可以任意深或宽，计算时间会随深入而增加</p>
<ul>
<li>权重与偏差：</li>
</ul>
<p>权重：衡量某个特征对预测的贡献程度的确定程度</p>
<p>偏差：预测必须从其开始的基值</p>
<ul>
<li>激活函数：</li>
</ul>
<p>激活函数由神经网络隐藏层中的每个节点计算</p>
<p>输出层计算的结果不是通过另一个激活函数传递，而是通过输出函数传递，取决于要预测的内容</p>
<ul>
<li>损失函数：</li>
</ul>
<p>损失函数是一种衡量模型预测好坏的方法，可以调整权重和偏差</p>
<p>必须正确设计损失函数，以便可以正确地惩罚错误的模型奖励正确的模型，这意味着希望损失表明所做的预测是远离还是接近真实预测。损失函数取决于任务，对于分类问题可以使用交叉熵损失。</p>
<ul>
<li>前进：前向传播</li>
</ul>
<p>前向传播是神经网络在做出预测之前执行的一系列计算的名称</p>
<ul>
<li>反向传播：</li>
</ul>
<p>反向传播是通过更新其权重和偏差来训练神经网络的过程的名称</p>
<p>神经网络通过不断尝试不同的权重然后比较损失来学习预测正确的值，如果损失函数减少，那么当前的权重比之前的要好，反之亦然。这意味着神经网络必须经过多次训练和更新循环才能获得最佳权重和偏差。这个循环就是训练阶段，寻找合适的权重的过程就是优化。</p>
<ul>
<li>训练和测试网络：</li>
</ul>
<p>将数据拆分为训练集和测试集</p>
<p>对其进行标准化</p>
<p>初始化一个模型</p>
<p>使用模型进行训练和预测</p>
<h3>卷积神经网络（CNN）</h3>

<ul>
<li>CNN是如何工作的？</li>
</ul>
<p>1、图像由像素组成，每个像素由0~255之间的数字表示，这是计算机处理图像的方式。</p>
<p>卷积过程中需要三个重要的项目：输入图像、特征检测器和特征图。输入图像是被检测的图像，特征检测器是一个矩阵，也称为内核或过滤器。直观地说，输入图像的矩阵表示与特征检测器逐元素相乘以产生特征图，也称为卷积特征或激活图。此步骤目的是为了减少图像大小并处理更快、更容易，在此步骤中丢失了图像的一些特征。</p>
<p>2、在此步骤中应用整流函数（Relu）来增加CNN中的非线性，图像由彼此非线性的不同对象组成。</p>
<p>3、池化</p>
<p>由于物体的空间不变性，即一个物体在图像中的位置不会影响神经网络检测其特定特征的能力。池化使CNN能够检测各种图像中的特征，而不考虑图像中的照明差异和图像的不同角度。</p>
<p>由不同类型的池化：如最小池化和最大池化。最大池化的工作原理是在特征图上放置一个2*2矩阵，并在该框中挑选最大的值，然后从左向右移动，穿过整个特征图，每次挑选最大的值。</p>
<p>这些值最后形成一个新的矩阵，成为池化特征图，作用是保留主要特征，同时减少图像大小，这有助于减少过度拟合。</p>
<p>4、展平</p>
<p>将整个池化特征图矩阵转换为单个列，然后将其馈送到神经网络中进行处理。</p>
<p>5、全连接</p>
<p>这一步由输入层、全连接层和输出层组成，全连接层相当于人工神经网络中的隐藏层，但它是全连接的。</p>
<ul>
<li>使用TensorFlow的Keras库实现卷积神经网络</li>
</ul>
<p>1、导入需要的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Convolution2D</span><br><span class="line">from keras.layers import MaxPooling2D</span><br><span class="line">from keras.layers import Flatten</span><br><span class="line">from keras.layers import Dense</span><br></pre></td></tr></table></figure>

<p>Sequential：初始化神经网络</p>
<p>Convolution2D：用于制作处理图像的卷积网络</p>
<p>MaxPooling2D：用于添加池化层</p>
<p>Flatten：将池化特征图转换为单个列并传递给全连接层的函数</p>
<p>Dense：将全连接层添加到神经网络</p>
<p>2、初始化神经网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier = Sequential()</span><br></pre></td></tr></table></figure>

<p>3、卷积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Convolution2D(32, 3, 3, input_shape = (256, 256, 3), activation=’relu’))</span><br></pre></td></tr></table></figure>

<p>添加卷积层，第一个参数是想要创建的特征检测器的数量，通常是以32个开始，第二和第三个参数是特征检测器矩阵的尺寸。input_shape是输入图形的形状，黑白图像转换为二维数组，彩色转换为三维数组。最后一个参数是激活函数，图像分类是一个非线性问题，使用relu函数可以确保在计算过程中没有负数像素值。</p>
<p>4、池化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(MaxPooling2D(pool_size=(2,2)))</span><br></pre></td></tr></table></figure>

<p>通常创建一个2*2的池大小。</p>
<p>5、展平</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Flatten())</span><br></pre></td></tr></table></figure>

<p>6、全连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Dense(output_dim = 128, activation=’relu’))</span><br></pre></td></tr></table></figure>

<p>通过使用Dense函数将上面得到的向量作为神经网络的输入，第一个参数是全连接层的节点数，维数越多，拟合模型所需要的计算资源越多，一般选择2的幂。第二个函数时激活函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Dense(output_dim=1, activation=’sigmoid’))</span><br></pre></td></tr></table></figure>

<p>添加输出层。期望得到二元结果使用sigmoid函数，期望得到两个以上结果，使用softmax函数。</p>
<p>7、编译CNN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.compile(optimizer=’adam’, loss=’binary_crossentropy’,metrics=[‘accuracy’])</span><br></pre></td></tr></table></figure>

<p>使用编译函数编译CNN，需要三个参数：优化器、损失函数和性能指标。</p>
<p>8、拟合CNN</p>
<p>进行图像增强处理防止过度拟合，是通过翻转、重新缩放、缩放和裁剪图像来进行工作的。第一个参数是确保图像被重新缩放后值介于0~1之间，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line">train_datagen = ImageDataGenerator(rescale=1./255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True)</span><br><span class="line">test_datagen = ImageDataGenerator(rescale=1./255)</span><br></pre></td></tr></table></figure>

<p>测试数据不需要跟训练数据一样采用图像增强。接下来是创建训练集和测试集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training_set = train_datagen.flow_from_directory(‘training_set’, target_size=(256, 256), batch_size=32, class_mode=’binary’)</span><br><span class="line">test_set = test_datagen.flow_from_directory(‘test_set’, target_size=(64, 64), batch_size=32, class_mode=’binary’)</span><br></pre></td></tr></table></figure>

<p>第一个参数是训练集的路径，第二个参数是CNN期望的图像大小。btach_size是在权重更新之前通过网路的图像数量，class_mode指示分类是否是二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.fit_generator(training_set, steps_per_epoch=5000, epochs=25, validation_data=test_set, nb_val_samples=1000)</span><br></pre></td></tr></table></figure>

<p>最后调用拟合函数并使用测试集测试其性能，第一个参数是训练集，第二个参数是训练集中的参数数量，第三个参数是训练的次数，第四个参数是测试集，最后一个参数是测试集的参数数量。</p>
<p>9、进行单一预测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">from keras.preprocessing import image</span><br></pre></td></tr></table></figure>

<p>使用预测函数使用新图像进行预测，在这之前需要对其进行预处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_image = image.load_img(‘brain_image1.jpg’, target_size=(256, 256))</span><br></pre></td></tr></table></figure>

<p>加载想要预测的图像，第一个参数是图像的路径，第二个参数是图像的大小，应与训练过程中的大小相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_image = image.img_to_array(test_image)</span><br></pre></td></tr></table></figure>

<p>使用彩色图像则将图像转换为一个三维数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_image = np.expand_dims(test_image, axis=0)</span><br><span class="line">prediction = classifier.predict(test_image)</span><br></pre></td></tr></table></figure>

<p>预测需要四个维度，第四个维度对应批量大小，这是因为在神经网络中要预测的数据通常作为批次传入。使用np.expand_dims函数添加这个维度，最后使用predict预测图像。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" data-id="cl0x9xz320006tsug89w18597" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/12/%E7%AE%97%E6%B3%95/LeetCode/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          leetcode
        
      </div>
    </a>
  
  
    <a href="/2022/01/13/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">春招加油！</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/TensorFlow-js/">TensorFlow.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">大三上日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">大三寒假日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">网站介绍</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%8B%E7%BB%8D/" rel="tag">介绍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;">介绍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/">手写系列</a>
          </li>
        
          <li>
            <a href="/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          </li>
        
          <li>
            <a href="/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/">node.js</a>
          </li>
        
          <li>
            <a href="/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/">webpack基础</a>
          </li>
        
          <li>
            <a href="/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/">项目相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 ChenZehong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>