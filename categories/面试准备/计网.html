<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <meta name="generator" content="Hexo 5.4.0">

  

  

  
    <meta name="author" content="ChenZehong">
  

  

  

  <title>Category: 面试准备 | 好好学习，天天向上</title>

  

  
    <link rel="shortcut icon" href="/happy.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/css/style.css">

</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container">
  
    <div class="post-image" style="background-image: url(http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202111/19a1b73a4f201a00a3da538a73add9bd--2226138859.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          好好学习，天天向上
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div>
  </div>
</nav>

  
  

  
  

  
  
    
    <div class="header-content">
      <div class="post-text layout-block layout-padding">
        <h1 class="title-wrap">面试准备</h1>
        <h2 class="title-sub-wrap">当前分类下共有10篇文章</h2>
      </div>
    </div>
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block layout-padding">
        <h1 class="title-wrap">计算机网络篇</h1>
        
      </div>
    </div>
  
  
</header>

    <!-- 分页(其他自定义页面) -->

<!-- 自定义页面 -->

<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <ul>
<li>知道哪些计算机网络模型？OSI 和 TCP/IP</li>
</ul>
<p>OSI模型一共有七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP模型有五层：应用层（HTTP协议、DNS协议、FTP协议）、传输层（TCP协议、UDP协议）、网络层（IP协议）、数据链路层、物理层</p>
<ul>
<li>TCP协议与UDP协议的区别：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/26468b56ce599668.png"></p>
<ul>
<li>为什么UDP有时候比TCP有优势：</li>
</ul>
<p>UDP以其简单、传输快的优势，在越来越多的场景下取代了TCP如实时游戏</p>
<p>1、网速的提升给UDP 的稳定性提供了可靠的网络保障，丢包率很低，如果使用应用层重传，能够保证传输的可靠性</p>
<p>2、TCP为了实现网络通信的可靠性使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于是在TCP内置的系统协议栈中，所以极难对其进行改进。</p>
<p>采用TCP一旦发生丢包会将后续的包缓存起来，等前面的包重传并接收后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下采用自定义重传机制能够把丢包产生的延迟降低到最低，尽量减少网络问题对游戏造成影响。</p>
<ul>
<li>UDP协议为什么不可靠：</li>
</ul>
<p>1、不保证信息交付：不确认、不重传、无超时</p>
<p>2、不保证交付顺序：不设置包序号，不重排，不会发生队首堵塞</p>
<p>3、不跟踪连接状态：不必建立连接或重启状态机</p>
<p>4、不进行拥塞控制：不内置客户端或网络反馈机制</p>
<ul>
<li>TCP三次握手：</li>
</ul>
<p>浏览器先向服务器发送一个SYN包以及seq序列号，然后服务器接收到SYN包后也向浏览器发送一个SYN包以及ACK确认应答（seq+1），然后浏览器接收到服务器发来的包后再向服务器发送一个确认应答ACK（服务器seq+1），此包发送完毕后客户端与服务器连接成功，三次握手结束。</p>
<ul>
<li>泛洪攻击：</li>
</ul>
<p>在三次握手中当服务器发送SYN-ACK包给客户端之后，可能不会接收到客户端回应的ACK包，这个就是半开放连接，服务器需要消耗一定数量的系统内存来等待这个连接。攻击者通过创建很多的半开放连接来发动泛洪攻击。</p>
<ul>
<li>TCP四次挥手：</li>
</ul>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放报文首部FIN=1，序列号seq等于前面传送过来的数据最后一个字节的序号+1，此时客户端进入终止等待状态1。</li>
<li>服务器收到连接释放报文后发出确认应答ACK，并且带上自己的序列号，然后服务器进入等待关闭状态</li>
<li>客户端收到服务器的确认应答后客户端进入终止等待状态2，等待服务器发送连接释放报文</li>
<li>服务器将最后的数据发送完毕后向客户端发送连接释放报文，此时服务器进入最后确认状态，等待客户端的确认</li>
<li>客户端收到服务器的连接释放报文后向服务器发送确认应答，此时客户端进入时间等待状态，等待一段时间后才进入关闭状态</li>
<li>服务器收到客户端的确认 应答后立即进入关闭状态，服务器结束TCP连接的时间要比客户端早一些</li>
</ol>
<ul>
<li>为什么需要四次挥手：</li>
</ul>
<p>因为当服务器接收到客户端的连接释放报文后需要发送确认应答ACK与FIN包，但是由于服务器接收到报文之后还有数据需要传输，所以先发送一个确认应答，等到数据全部发送完了才能够发送FIN报文。（FIN报文是终结连接请求）</p>
<ul>
<li>TCP如何实现可靠性：</li>
</ul>
<p>TCP通过序列号（报文所发送的数据的第一个字节的序号）、检验和、确认应答信号（期望收到对方的下一个报文段的数据的第一个字节的序号）、重发控制、连接管理、窗口控制、流量控制。拥塞控制实现可靠性。</p>
<ul>
<li>TCP的重传机制（针对数据包丢失或者定时器超时）：</li>
</ul>
<p>由于TCP的下层网络层可能出现丢失、重复或者失序的情况，为保证数据传输的正确性，TCP会重传认为已丢失的包。TCP在发送一个数据之后会开启一个定时器，若是在这个时间内没有收到发送数据的确认应答，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。TCP使用两套独立的机制来完成重传，一个是基于时间，一个是基于确认信息。</p>
<p>超时重传（RTO）：超时重传时间应该略大于报文往返的RRT值。实际上RTO是经常变化的，因为我们的网络也是经常变化的。</p>
<p>快速重传：不以时间为驱动，而是以数据为驱动重传。快速重传的工作方式就是当收到三个相同的ACK报文时吗，会在定时器过期之前，重传丢失的报文。为了解决是重传之前的一个还是重传所有的问题，于是有了SACK方法。</p>
<p>选择性确认（SACK）：这种方式只需要在TCP头部字段中加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据接收到了，然后重传丢失的数据。</p>
<p>D-SACK：可以让发送方知道是发出去的包丢了哈市接收方回应的ACK包丢了，还可以知道是不是发送方的数据包被网络延迟了；还可以知道网络中是不是把发送方的数据包复制了。</p>
<ul>
<li>TCP协议的流量控制（针对避免网络拥堵）：</li>
</ul>
<p>流量控制就是为了让发送方发送数据的速度不要太快，TCP采用大小可变的滑动窗口进行流量控制。</p>
<p>当一个连接建立时，连接的每一端会分配一个缓冲区来保存输入的数据并将缓冲区的大小发送给另一端；当数据到达时接收方发送确认其中包含自己剩余的缓冲区大小（即自己的接收窗口大小rwnd）。如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告；如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口，发送方收到一个零窗口通告的时候必须停止发送，直到接收方重新通告一个正的窗口。但有两种情况除外，一个是可以发送紧急数据；一个是发送方可以发送一个1字节的数据包来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<ul>
<li>接收窗口与拥塞窗口的区别：</li>
</ul>
<p>接收窗口由接收方管理，接收方将窗口大小发送给发送方，窗口大小表示接收方缓冲区仍然空闲的字节数。拥塞窗口是发送方强加的窗口，它的实现是为了避免网络路径中间的一些路由器溢出，拥塞窗口是发送方允许自己发送更多未完成的数据而出现，当发送方检测到数据丢失时对将窗口切成两半，背后的原理是发送方假设数据包丢失是因为某个地方的缓冲区溢出而发生的，因此发送方希望保持较少的数据“在运行中”，以避免将来进一步包的丢失。</p>
<ul>
<li>TCP的拥塞控制（避免刚开始启动时避免一下子发送大量数据导致网络瘫痪）：</li>
</ul>
<p>TCP的拥塞控制算法包含了：慢启动，拥塞避免，快速重传，快速恢复</p>
<p>慢启动：开始的时候不要发送大量数据，先测试一下网络的拥塞程度，由小到大增加拥塞窗口（cwnd）的大小。为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（sssthresh）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当cwnd&lt;sssthresh时，使用慢开始算法</span><br><span class="line">当cwnd=sssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</span><br><span class="line">当cwnd》sssthresh时，使用拥塞避免算法</span><br></pre></td></tr></table></figure>

<p>拥塞避免：让拥塞窗口缓慢的增大，每经过一个返回时间RRT就把发送方的拥塞控制窗口加一。无论是慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为拥塞时发送窗口大小的一半，然后拥塞窗口设置为1，执行慢开始算法。</p>
<p>快速重传：要求接收方在收到一个失序的报文段后就立即发出重复确认，发送方只要一连续收到三个重复的确认应发就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器时间到期。</p>
<p>快速恢复：当发送方连续收到三个重复确认就执行乘法减小算法，将门限减半，然后接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<ul>
<li>TCP的停止等待协议：</li>
</ul>
<p>停止等待协议是为了实现可靠传输的，它的原理是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。每个分组发送完会开启一个超时计时器，如果超时则自动重传数据，这种重传方式叫做自动重传请求ARQ。在停止等待协议中若收到重复分组就丢弃该分组，但同时还要再发送确认。连续ARQ协议可提高信道利用率，发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一把采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>确认丢失和确认迟到：</strong></p>
<p>1、确认丢失：确认信息在传输过程中丢失。</p>
<p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<p>丢弃这个重复的M1消息，不向上层交付；</p>
<p>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>2、确认迟到 ：确认消息在传输过程中迟到</p>
<p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>
<p>A收到重复的确认后，直接丢弃。</p>
<p>B收到重复的M1后，也直接丢弃重复的M1。</p>
<ul>
<li>为什么四次握手发送最后一次报文之后需要等待2MSL的时间：</li>
</ul>
<p>1、为了保证A发送的最后一个确认报文能够到达B，如果A不等待2MSL，若A返回的最后确认报文段丢失，则B不能进入正常状态，而此时A已经关闭，不能再重传。</p>
<p>2、防止出现“已失效的连接请求报文段”，在A发送完最后一个确认报文段后再经过2MSL可保证本连接持续的时间内所产生的所有报文从网络中消失。</p>
<ul>
<li>为什么超时事件发生时cwnd设置为1，而受到三个重复的ACK时cwnd只是减半：</li>
</ul>
<p>超时事件发生时网络拥塞更严重，说明网络可能已经拥塞得连ACK报文都传输不了了；而受到三个重复的ACK时，虽然网络拥塞但是至少ACK报文能被正确交付，网路拥塞相对不是很严重。</p>
<ul>
<li>是否TCP和UDP都需要计算往返时间RRT：</li>
</ul>
<p>TCP需要根据RRT来动态设置超时计时器的超时时间，UDP没有确认和重传机制，因此RRT对UDP没有什么意义。</p>
<ul>
<li>为什么TCP在建立连接时不能每次都选择相同的、固定的序列号：</li>
</ul>
<p>1、假如A和B频繁的建立连接，传送一些TCP报文段后再释放连接，然后又不断建立新的连接，传送报文段和释放连接；</p>
<p>2、假如每一次建立连接时主机A都选择相同的固定的初始序号1</p>
<p>3、若主机A发送出的某些TCP报文在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段</p>
<p>4、若有一些网络中滞留较久的TCP报文最后终于到达了主机B，但这是传送该报文段的连接早已释放了，而在此时到达主机B的TCP连接时一条新的连接</p>
<p>以上情况可能会导致在新的TCP连接中的主机B有可能会接收在旧的连接传送的已经没有意义的过时的TCP报文段（因为这个TCP报文段的序号有可能正好处于新的链接所使用的序号范围内）。因此必须使得迟到的TCP报文段中的序号不在新的连接中使用的序号范围内。不同的TCP连接不能使用相同的初始序号。</p>
<ul>
<li>在使用TCP传输数据时如果有一个确认报文段丢失了，也不一定会引起与该确认报文段相对应的数据的重传：</li>
</ul>
<p>因为发送方可能还未重传时就收到了更高序号的确认。例如主机A连续发送两个报文段，均正确到达主机B。B连续发送两个确认ACK1和ACK2(ACK2的序号比ACK1的序号高)。但前一个确认帧在传输时丢失了。若在超时前，ACK2被A接收，更高的序号代表该序号之前的所有字节都被接收了，所以A知道前一个报文也被正确的接收了，这种情况下A不会重传第一个报文段。</p>
<ul>
<li>Cookie Session Token的原理</li>
</ul>
<p>cookie的原理：</p>
<ol>
<li>客户端第一次发送请求时发送数据到服务器</li>
<li>服务器返回响应消息的同时传回一个cookie</li>
<li>客户端接收到服务器的响应后将cookie存放在一个统一的地方</li>
<li>客户端再次向服务器发送请求时会把cookie写进请求头然后发给服务器</li>
</ol>
<p>session的原理：</p>
<ol>
<li>服务器在处理客户端请求过程中会创建session，并为session生成一个唯一的ID</li>
<li>服务器将sessionID发送给客户端</li>
<li>当客户端再次发送请求时会带上这个sessionID</li>
<li>服务器接收到请求之后会根据ID找到相对应的session，完成请求</li>
</ol>
<p>token的原理：</p>
<ol>
<li>客户端第一次请求时，发送用户信息到服务器，服务器对用户信息使用加密算法和密钥进行签名，再将这个签名和数据一起作为token返回给客户端</li>
<li>服务端不再保存token，客户端保存token</li>
<li>当客户端再次发送请求时在请求信息中将token一起发送给服务器</li>
<li>服务器使用相同的加密算法和密钥对数据再进行一次签名，和token的签名作比较</li>
<li>如果相同则知道客户端登录过</li>
</ol>
<ul>
<li>跨域：</li>
</ul>
<p>同源：指域名、协议、端口相同</p>
<p>跨域就是指浏览器不能执行其他网站的脚本，是浏览器对Javascript实施的安全限制。之所以有同源策略是浏览器对于用户安全的考虑，会导致Cookie、LocalStorage无法读取，DOM和JS对象无法获取、Ajax请求发送不出去。</p>
<p>解决跨域的方法：</p>
<p>1、jsonp是利用script脚本不受同源策略的限制</p>
<p>2、CORS（跨域资源共享）</p>
<p>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头origin;后端在接收到请求确定响应后会在响应头加上Access-Control-Allow-Origin。浏览器判断响应中的Access-Control-Allow-Origin与当前地址值是否相同，匹配成功则继续相应处理，否则报错。</p>
<p>需要浏览器和服务器的支持，浏览器在发送请求时在请求头中添加origin字段，然后在服务器里面配置Access-Control-Allow-Origin，服务器接收到请求时会根据origin字段在Access-Control-Allow-Origin查找，如果有则允许跨域，没有则不允许。</p>
<p>3、代理跨域请求</p>
<p>前端发送请求经过代理，请求需要的服务器资源</p>
<p>4、HTML5 postMessage方法</p>
<p>允许来自不同源的脚本采用异步方式进行有限的通信</p>
<p>5、基于HTML5的websocket协议</p>
<p>基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求</p>
<ul>
<li>HTTP缓存：</li>
</ul>
<p>有效减少网络请求的体积和数量</p>
<p>强缓存：在第一次请求返回的响应头中添加cache-control，设置max-age有效时间，这样当发送下一次请求时如果在有效期内则直接在缓存中获取资源。</p>
<p>协商缓存：服务器端缓存策略，在第一次发送请求的响应头中加入资源标识，如果第二次请求发现资源并没有修改过则返回304状态码直接从缓存中获取资源。如果资源已经修改则返回200状态码和最新的资源以及最新的资源标识。资源标识有last-modified和etag，last-modified对应需要在第二次请求的请求中中添加if-modified-since；etag对应需要在第二次请求的请求中中添加if-none-match。</p>
<p>etag优先级更高，因为last-modified只能精确到秒，而且文件如果隔一段时间重复生成即使内容相同last-modified会每次返回资源文件，而etag可以判断内容相同则返回304从缓存中获取资源。</p>
<ul>
<li>js事件循环：</li>
</ul>
<p>浏览器由很多模块组成，有解析html和css的模块，有解析js的模块，有定时器模块，有ajax模块。</p>
<p>宏任务：script标签中的整体代码、setTimeout、setInterval、I/O、UI渲染</p>
<p>微任务：process.nextTick、Promise、MutationObserver</p>
<p>事件循环：一开始整个脚本作为一个宏任务执行，执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列。当前宏任务执行完毕后立即执行微任务队列中的所有微任务。当前宏任务执行完毕开始检查渲染，然后GUI线程接管渲染（浏览器会在两个宏任务交接期间，对页面进行重新渲染）。渲染完毕后JS线程继续接管，开始下一个宏任务，依此循环，直到宏任务与微任务队列都为空。</p>
<ul>
<li>GET 和 POST 的区别：</li>
</ul>
<p>GET是通过URl传递参数，post是通过请求体传递参数</p>
<p>GET请求在url中是有长度限制的，而post没有</p>
<p>get比post不安全，因为参数是直接暴露在url中的，所以不能传递敏感信息</p>
<p>get是一个幂等的请求不会产生对服务器资源产生影响，post不是一个幂等的请求一般用以对服务器资源产生影响的情景，如注册用户</p>
<p>get请求参数会被完整地保留在浏览器的历史记录里，而post不会</p>
<ul>
<li>post请求与put请求的区别：</li>
</ul>
<p>put请求是向服务器端发送数据，从而修改数据的内容，但是不会更新数据的种类，可以理解为更新数据</p>
<p>post请求是向服务器发送数据，该请求会改变数据的种类等资源，它会创建新的内容。</p>
<ul>
<li>常见http请求头：</li>
</ul>
<p>Accept：浏览器可处理的内容类型</p>
<p>Accept-Charset：浏览器能够显示的字符集</p>
<p>Accept-Encoding：浏览器能够处理的压缩编码</p>
<p>Connection：浏览器与服务器之间连接的类型</p>
<p>Cookie：当前页面设置的任何Cookie</p>
<p>Host：发出请求页面所在的域</p>
<p>Referer：发出请求的页面的URL</p>
<p>User-Agent：浏览器的用户代理字符串</p>
<ul>
<li>常见http响应头：</li>
</ul>
<p>Date：发送消息的时间</p>
<p>server：服务器名称</p>
<p>Cache-Control：控制http缓存</p>
<p>content-type：表示后面的文档属于什么MIME类型</p>
<ul>
<li>http码是304多好还是不好？</li>
</ul>
<p>304是协商缓存中服务器向客户端返回，允许客户端调用缓存内容的状态码，它不是一种错误。</p>
<p>但是当304状态码多了之后，搜 索引擎蜘蛛可能会降低对网站的抓取次数，相反如果每次抓取都能获取新内容，回访率也会增加。</p>
<ul>
<li>options的主要用途：</li>
</ul>
<p>获取服务器支持的所有http请求方法</p>
<p>用来检查访问权限，例如在进行CORS进行跨域资源共享时，对于复杂请求就是使用options方法发送嗅探请求，以判断是否有对指定资源的访问权限</p>
<ul>
<li>http1.0与http1.1之间的区别：</li>
</ul>
<p>连接方面：1.0使用非持久连接，1.1使用持久长连接，支持多个http请求使用同一个tcp连接</p>
<p>资源请求方面：1.0中当客户端需要某个对象的一部分，服务器只能一整个对象，而1.1中引入range允许只请求资源的某个部分，返回码是206</p>
<p>缓存方面：1.0主要使用If-Modified-Since、Expries来作为缓存判断的标准，1.1则引入了Etag、if-Undified-Since、If-Match、If-None-Match等更多缓存头来控制缓存策略</p>
<p>1.1新增了host字用来指定服务器的域名，同时新增了许多请求方法，如PUT、HEAD等</p>
<ul>
<li>1.1与2.0的区别：</li>
</ul>
<p><strong>二进制分帧</strong>：流式连接中的一个虚拟信道，可以承载双向消息传输，每个流有唯一整数标识符，为了防止两端流ID冲突，客户端发起的流具有奇数ID。服务器发起的流具有偶数ID一个独立的双向的帧存在于客户端和服务器之间的http2连接中。一个http2连接上可以包含多个并发打开的流，这个并发的数量由客户端设置。在二进制分帧层上http2会将所有传输信息分割为更小的消息或帧，并对他们采用二进制格式的编码进行封装。</p>
<p><strong>多路复用</strong>：多路复用允许同时通过一个单一的http2连接发起多重的请求-响应消息，有了新的分帧机制后，http2可以不再依赖多个TCP连接。每个数据流都拆分为很多互不依赖的帧，而这些帧可以交错，还可以分优先级发送，最后在另一端重新组合。</p>
<p><strong>头部压缩</strong>：由于1.1协议不带状态，每次请求都必须附上全部信息，所以请求的很多字段都是重复的，这既浪费带宽也影响速度。http2使用encoder来减少需要传输的请求头大小，通讯双方各自缓存一份头部字段表，既避免了重复请求头的传输，也减小了需要传输的大小。对于相同的数据，不再需要每次请求和响应发送，通信期间几乎不会改变通用键值对。如果首部发生了变化则只需将变化的部分加入到请求头中，改变的部分会加入到头部字段表中。</p>
<p><strong>请求优先级</strong>：把http消息分为很多独立帧之后可以通过优化这些帧的交错与传输顺序进一步优化性能，每个流可以带有优先值。服务器根据流的优先级控制资源分配，而在响应数据准备好之后优先将最高优先级的帧发送给客户端。一般html文件优先级最高，css文件次之，之后是js文件等资源。</p>
<p><strong>服务端推送</strong>：服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确的请求，服务器能把客户端需要的资源伴随着index.html一起发送给客户端。这种服务器推送的是基于客户端的请求响应确定的。</p>
<ul>
<li>http协议与https协议的区别：</li>
</ul>
<p>https协议需要ca证书，费用较高，而http协议不需要</p>
<p>http协议是超文本传输协议，信息是明文传输；https协议是具有安全性的ssl加密传输协议</p>
<p>使用不同的连接方式，端口也不同，http协议是80端口，https协议是443</p>
<p>http协议连接时无状态的，https协议是有ssl和http协议构建的可进行加密传输 、身份认证的网络协议，更加安全</p>
<ul>
<li>对keep-alive的理解：</li>
</ul>
<p>keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，可以避免建立或者重新建立连接，这就会长连接</p>
<p>1.0默认是没有keep-alive的要想连接得到保持需要手动配置connection:keep-allive字段，关闭则发送connection:close字段</p>
<p>1.1规定了默认保持长连接</p>
<ul>
<li>keep-alive的建立过程：</li>
</ul>
<ol>
<li>客户端向服务器在发送请求报文同时在首部添加connection字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送connection:keep-alive字段给客户端</li>
<li>客户端收到connection字段</li>
<li>keep-alive建立成功 </li>
</ol>
<ul>
<li>开启keep-alive的优点：</li>
</ul>
<p>较少的CPU和内存的使用（由于同时打开的连接少了）</p>
<p>允许请求和应答的http管线化</p>
<p>降低拥塞控制（tcp连接少了）</p>
<p>减少了后续请求的延迟（无需再进行握手）</p>
<ul>
<li>缺点：</li>
</ul>
<p>长时间的连接容易导致系统资源无效占用，浪费系统资源</p>
<ul>
<li>http状态码：</li>
</ul>
<p>2开头：请求成功处理（200：请求成功处理，一般用于get与post请求；201：已创建，成功请求并创建了新的资源；202：已接受，已经接受请求但是未处理成功；204：成功处理请求但是无内容返回）</p>
<p>3开头：重定向相关（301：永久性重定向，返回信息会包括新的url，浏览器会自动定向到新的url；302：暂时性重定向；304：协商缓存时返回的状态码，当允许从本地读取缓存时返回）</p>
<p>4开头：客户端错误（400：客户端请求的语法错误，服务器无法理解；401：请求要求用户的身份认证；403：服务端理解用户客户端请求但是拒绝执行；404：服务器无法根据客户端请求找到资源）</p>
<p>5开头：服务端错误（500：服务器不支持请求的功能，无法完成请求；505：服务器不支持此请求http版本，无法完成处理）</p>
<ul>
<li>同样是重定向，307,302,303的区别：</li>
</ul>
<p>302是http1.0的状态码，在http1.1版本中为了细化302状态码多出了303与307。303表示客户端应当采用get方法获取资源，它会把post请求变为get请求进行重定向；307表示遵照浏览器标准，不会从post变为get方法。</p>
<ul>
<li>JS数据为什么分别存在栈和堆：</li>
</ul>
<p>在JS中栈是用来存储基本类型数据的，如boolean、number、string等，这些数据类型在栈内存中分别占有固定大小的空间，我们通过值来对数据进行访问，基本数据类型在当前执行环境结束时就会在栈中销毁；由于引用类型大小不固定所以不能保存在栈中，所以使用堆来对引用数据类型进行保存，而在栈中保存这些引用类型的地址，这样当查询引用数据类型的变量时就会先从栈中读取内存地址然后再去堆中找到相应的值。堆中的数据是不会对执行环境结束而销毁的，只有当所有引用它的变量不存在时这个对象才会被回收机制回收。</p>
<ul>
<li>如何设置httponly：</li>
</ul>
<p>在服务器返回响应头的cookie中添加http only属性为true</p>
<ul>
<li>浏览器渲染过程：</li>
</ul>
<p>1、根据HTML构建DOM树</p>
<p>2、根据CSS构建stylesheet</p>
<p>3、将DOM树与stylesheet合并为渲染树</p>
<p>4、根据渲染树来布局，以计算每个节点的几何信息</p>
<p>5、将各个节点绘制到屏幕上</p>
<ul>
<li>在浏览器输入baidu.com并且按下回车之后发生了什么：</li>
</ul>
<p>1、解析url：首先对url进行解析，分析所需要的传输协议和请求的资源路径，如果输入的url中的协议或者主机名不合法将会把地址栏输入的内容传递给搜索引擎。如果没问题就会检查url中是否出现了非法字符，如果存在非法字符则对非法字符进行转义后再进行下一过程。</p>
<p>2、缓存判断：浏览器会判断所请求的资源是否在缓存里，如果在缓存里并且没有失效，就直接使用，否则向服务器发起新的请求。</p>
<p>3、DNS解析：下一步首先需要获取输入的url的域名的ip地址，首先会先判断浏览器是否有该域名的ip地址的缓存，如果有则使用，没有则继续所搜操作系统的DNS缓存，如果没有再向本地DNS服务器发起请求。本地的服务器会先检查是否存在缓存，没有就会向根域名服务器发起请求，获得负责的顶级域名服务器的地址后再向顶级域名服务器发起请求，然后获得负责的权威域名服务器地址后再向权威域名服务器发起请求最终获得域名的IP地址，本地DNS服务器再将这个ip地址返回给请求的用户。</p>
<p>4、获得MAC地址：当浏览器得到ip地址后，数据传输还需要知道目的主机MAC地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的ip地址作为目的地址然后下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，本机的MAC作为源MAC地址，目的MAC地址需要分情况处理。通过将IP地址与本机的子网掩码相比较可以判断是否与请求主机在同一子网中，如果在同一子网中可以使用APR协议获取到目的主机的MAC地址，如果不在一个子网中那么请求应该转发给网关，由它代为转发，此时同样可以通过APR协议来获取网关的Mac地址，此时目的主机的MAC地址应该为网关的地址</p>
<p>5、TCP三次握手：首先客户端向服务器发送一个SYN连接请求报文段和一个随机序列号，服务器接收到请求后向客户端发送一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收到确认应答后进入连接建立状态，同时向服务器发送一个ACK确认报文段，服务器接收到确认后，也进入连接建立状态，此时双方连接就建立起来了</p>
<p>6、https握手：如果使用的是https协议，在通信前还存在一个TLS的四次握手过程。首先客户端向服务器发送使用协议的版本号、一个随机数和可以使用的加密方法。服务器接收到之后确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端接收到之后首先检查数字证书是否有效，如果有效则再生成一个随机数并使用证书中的公钥对随机数加密，然后发送给服务器，并且还会提供一个前面所有内容的hash值给服务器进行检验。服务器接收后使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的hash值给客户端检验，这个时候双方都有了三个随机数，按照之前所约定的加密方法使用这三个随机数生成一把密钥以后双方通信前就使用这个密钥对数据进行加密后再传输</p>
<p>7、返回数据：当页面请求发送到服务器后，服务器会返回一个html文件作为响应，浏览器接收到响应后开始对文件进行解析，开始页面的渲染过程</p>
<p>8、页面渲染：浏览器首先会根据html文件构建DOM树，根据解析到的css文件构建 CSSOM树，如果遇到script标签则判断是否含有defer或者async属性，不然script标签的加载和执行会造成页面的渲染的阻塞。当DOM数和CSSOM树建立好之后根据他们来构建渲染树。渲染树构建好之后会根据渲染树进行布局。布局完成后最后使用浏览器的ui接口对页面进行绘制，这个时候页面就显示出来了。</p>
<p>9、TCP四次挥手：最后一步是TCP断开连接的四次挥手过程。若客户端认为数据发送完毕需要向服务器发送连接释放请求，服务器收到连接释放请求后会告诉应用层要释放TCP连接，然后发送ACK包，并进入CLOSE_WAIT状态，此时表明客户端到服务器的连接已经释放不再接受客户端发来的数据。因为TCP连接是双向的所以服务器仍旧可以发送数据给客户端。服务器如果此时还有没发完的数据会继续发送完毕后向客户端发送释放连接请求，然后服务器进入LAST-ACK状态，客户端收到释放请求后向服务器发送确认应答，此时客户端进入TIME-WAIT状态，该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间超时会被抛弃）时间。若时间段内没有服务器的重发请求的话就进入CLOSED状态，当服务器收到确认应答后也进入CLOSED状态。</p>
<ul>
<li>页面中有多张图片，http是怎样加载的：</li>
</ul>
<p>在http1下，浏览器对一个域名下最大TCP连接数是6，可以使用多域名部署解决，这样可以提高同时请求的数目，加快页面图片的获取速度</p>
<p>在http2下，可以一瞬间加载出来很多资源因为http2支持多路复用，可以在一个TCP连接中发送多个http请求</p>
<ul>
<li>http2的头部压缩算法是怎样的：</li>
</ul>
<p>http2的头部压缩算法是HPCK算法，在客户端与服务器两端建立字典，用索引表示重复的字符串，采用哈弗曼编码来压缩整数和字符串可以达到50%~90%的压缩率</p>
<p>具体来说：</p>
<p>在客户端与服务器使用首部表来跟踪和存储之前发送的键值对，对于相同的数据不再通过每次请求和响应发送</p>
<p>首部表在http2的连接存续期内始终存在，由客户端与服务器共同渐近的更新</p>
<p>每个新的首部键值要么被追加到当前表的末尾要么替换表中之前的值</p>
<ul>
<li>说一下http3.0：</li>
</ul>
<p>http2的多路复用在丢包场景下会出现队头堵塞问题。http3采用UDP作为传输层协议重新实现了无需连接，并在此基础上通过有序的QUIC Stream提供了多路复用。</p>
<p>http3是基于udp协议实现类似于tcp的多路复用数据流，传输可靠等功能，这套功能被称为QUIC协议</p>
<p>1、流量控制。传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制以及其他tcp中的特性。</p>
<p>2、集成TCP加密功能：目前QUIC使用TLS1.3减少了握手所花费的RTT数</p>
<p>3、多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头堵塞问题</p>
<p>4、快速握手：由于基于UDP可以实现使用0~1个RRT来建立连接</p>
<ul>
<li>队头堵塞：</li>
</ul>
<p>http传输的报文必须是一发一收，但是里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会堵塞后面的请求的处理，这就是队头堵塞</p>
<p>队头阻塞的解决方案：</p>
<p>1、并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其他所有任务</p>
<p>2、域名分片：将域名分出很多二级域名，他们都指向同样的一台服务器，能够并发的长连接数量变多，解决了队头堵塞的问题</p>
<ul>
<li>TLS/SSL的工作原理：</li>
</ul>
<p>TLS/SSL称为安全传输层协议，是介于TCP与HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能主要依赖三类基本算法：散列函数hash、对称加密和非对称加密，作用如下：</p>
<p>基于散列函数验证信息的完整性；对称加密算法采用协商的密钥对数据加密；非对称加密实现身份认证和密钥加密</p>
<p>散列函数：常见的散列函数有MD5、SHA1、SHA256，该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以防止信息篡改并验证信息的完整性。</p>
<p>对称加密：对称加密的方法是双方使用同一个密钥对数据进行加密和解密，但是对称加密的一个问题就是如何保证密钥传输的安全性，因为密钥还是会通过网络传输，一旦密钥被其他人获取到，那么整个加密过程就毫无作用了，这就要用到非对称加密</p>
<p>非对称加密：我们拥有两个密钥一个是私钥一个是公钥，公钥是公开的，私钥是保密的，用私钥加密的数据只有对应的公钥才能解密，用公钥加密的数据只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户都可以使用我们提供的公钥对数据进行加密然后我们使用私钥进行解密，这样就能保证数据的安全了。掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信。但是有一个缺点就是加密的过程很慢。</p>
<p>TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的密钥，对称加密算法采用协商密钥对信息以及信息摘要进行加密通信。</p>
<ul>
<li>数字证书是什么：</li>
</ul>
<p>因为没有办法确定得到的公钥就一定是安全的，可能存在一个中间人，截取了对方发给我们的公钥然后将它自己的公钥发送给我们，当我们使用它的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后伪装成我们以同样的方法向对方发送信息这样我们的信息就被窃取了。为了解决这个问题可以使用数字证书。</p>
<p>首先使用一种hash算法对公钥和其他信息进行加密，生成一个消息摘要，然后让有公信力的认证中心（CA）用它的私钥对消息摘要进行加密形成签名，最后将原始信息与签名合成在一起，称之为数字证书。当接收方接收到证书时，先根据原始信息使用同样的hash算法生成一个摘要，然后使用公证处的公钥对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>一般浏览器会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<ul>
<li>https的通信过程（握手过程）：</li>
</ul>
<p>1、客户端向服务器发起请求，请求中包含使用的协议版本号，生成的一个随机数，以及客户端支持的加密方法</p>
<p>2、服务器接收到请求后，确认双方使用的加密方法，并给出服务器的证书，以及一个服务器生成的随机数</p>
<p>3、客户端确认服务器的证书有效后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发给服务器，并且还会提供一个前面所有内容的hash值，用来供服务器检验</p>
<p>4、服务器使用自己的私钥，来解密客户端发送过来的随机数，并提供前面所有内容的hash值来供客户端检验</p>
<p>5、客户端和服务器根据自己约定的加密方法使用前面三个随机数，生成对话密钥，以后的对话过程都使用这个密钥进行加密信息。</p>
<ul>
<li>DNS协议是什么：</li>
</ul>
<p>DNS是域名系统，提供一种主机名到IP地址的转换服务，它是由一个分层的DNS服务器组成的 分布式数据库，定义了主机如何查询这个分布式数据库的方式的应用层协议。</p>
<p>作用：将域名解析为IP地址，客户端向DNS服务器发送域名查询请求，DNS服务器告知客户端服务器的IP地址。</p>
<ul>
<li>DNS同时使用TCP与UDP协议：</li>
</ul>
<p>1、在区域传输的时候使用TCP协议：辅域名服务器会定时向主域名服务器查询以便了解数据是否有变动，如有变动会执行一次区域传送，进行数据同步。TCP是一种可靠连接，保证了数据的准确性。</p>
<p>2、在域名解析的时候使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容不超过512字节，用UDP协议传送即可。因为不用经过三次握手所以响应DNS服务器负载更低，响应更快。</p>
<ul>
<li>DNS完整的查询过程：</li>
</ul>
<p>1、首先会在浏览器缓存中查找对应的IP地址，找到则返回，否则进入下一步</p>
<p>2、将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，找到则返回，否则进入下一步</p>
<p>3、本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</p>
<p>4、本地DNS服务器向顶级域名服务器发送请求，接收请求的服务器查询自己的缓存，如果有记录则返回查询结果，否则返回 相关的下一级的权威服务器的地址</p>
<p>5、本地DNS服务器向权威服务器发送请求，域名服务器返回对应的结果</p>
<p>6、本地DNS服务器将返回的结果保存在缓存中便于下次使用 </p>
<p>7、本地DNS服务器将返回结果返回给浏览器、、</p>
<ul>
<li>DNS解析是包含递归查询与迭代查询的过程：</li>
</ul>
<p>递归查询：查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果，使用递归查询用户只需要发出一次查询请求</p>
<p>迭代查询：查询请求后，域名服务器返回单次查询的结果，下一级查询由用户自己请求，使用迭代查询用户需要发起多次的查询请求</p>
<p>一般我们向本地DNS服务器发送请求的方式是递归查询，而本地服务器向其他域名服务器请求的过程是迭代请求的过程。</p>
<ul>
<li>说说常见的content-type：</li>
</ul>
<p><em>text/html：html格式</em></p>
<p><em>text/plain：纯文本格式</em></p>
<p><em>image/gif：gif格式</em></p>
<p><em>application/json：json数据格式</em></p>
<p><em>application/pdf：pdf数据格式</em></p>
<p><em>application/msword：word文档格式</em></p>
<p><em>application/octet-stream：二进制流格式</em></p>
<p><em>application/x-www-form-urlencoded：表单的默认提交数据格式，将键值对的参数使用&amp;连接起来，如果有空格则转换为+号，如有特殊字符则进行转义。</em></p>
<p><em>mulitipart/form-data：需要在表单中进行二进制文件上传时，需要使用该格式，也可用于键值对参数，最后连接成一串字符传输。</em></p>
<ul>
<li>URL有哪些组成部分：</li>
</ul>
<p>协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分（从？到#之间的部分都是参数部分，参数之间用&amp;作为分隔符）、锚部分（从#开始到最后都是锚部分）。</p>
<ul>
<li>HTTPS的特点：</li>
</ul>
<p><strong>优点：</strong></p>
<p>1、可以认证用户和服务器，确保数据发送到正确的客户端和服务器</p>
<p>2、可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取，修改，保证数据的安全性</p>
<p>3、不是绝对安全的但是大幅增加了中间人攻击的成本</p>
<p><strong>缺点：</strong></p>
<p>1、需要做服务器与客户端双方的加密解密处理，耗费更多的服务器资源，过程复杂</p>
<p>2、握手阶段比较费时，增加页面加载时间</p>
<p>3、SSL证书是收费的，功能越强大的证书费用越高</p>
<p>4、连接服务器资源占用高很多，支持访客稍多的网站需要投入更多的成本</p>
<p>5、需要绑定IP，不能在同一个IP绑定多个域名</p>
<ul>
<li>说一说什么是大端、小端，如何判断大端和小端 </li>
</ul>
<p>1、字节序</p>
<p><strong>字节顺序</strong>，又称<strong>端序</strong>或<strong>尾序</strong>（英语：<strong>Endianness</strong>）。在计算机科学计算机科学”)领域中，是跨越多字节的程序对象的存储规则。<br>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>2、大小端</p>
<p>在计算机中一般讲字节序分为两类：Big-Endian（大端字节序） 和Little-Endian。<br>a) Little-Endian 高位字节在前，低位字节在后。<br>b) Big-Endian 低位字节在前，高位字节在后。<br>c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</p>
<ul>
<li>XSS攻击是什么？</li>
</ul>
<p>XSS是跨站脚本攻击(Cross Site Scripting)，攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。XSS的危害一般是泄露用户的登录信息cookie，攻击者可以通过cookie绕过登录步骤直接进入站点。XSS的分类分为反射型和存储型。反射型需要欺骗用户去点击才能触发XSS代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。</p>
<p>一切用户可控并且能够输出在页面代码中的地方都可能出现XSS漏洞，比如评论区、留言区等。</p>
<p><strong>预防</strong>：对用户输入进行过滤，对输出进行html编码。也就是对用户提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉导致脚本执行的相关内容，然后对动态输出到页面的内容进行html编码使脚本无法在浏览器中执行。还可以在服务端设置会话cookie的http only属性，这样客户端的JS脚本就不能获取到cookie信息了 。</p>
<ul>
<li>说说CSRF：</li>
</ul>
<p>CSRF是跨站请求伪造，可以在用户毫不知情的情况下以用户的名义伪造请求发送给攻击站点，从而在未授权的情况下进行权限保护内的操作，比如以用户的名义发送邮件，购买商品等。</p>
<p><strong>预防</strong>：</p>
<p>同源检测：验证http Referer字段，http头中的字段Referer中记录了http请求的来源地址，可以通过对每一个请求验证其Referer值，如果是其他网站则拒绝请求；</p>
<p>随机数一致性检测：令牌同步模式：CSRF token：用户登录后生成随机的token值，用户提交的操作类请求中，提交的表单中携带CSRF token值，服务器判断CSRF token值是否正确。</p>
<ul>
<li>XSS攻击与CSRF攻击的区别：</li>
</ul>
<p>CSRF不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击；</p>
<p>CSRF攻击成本比XSS低。</p>
<ul>
<li>合法的IPv4 或 IPv6 地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 合法的IPv4:</span><br><span class="line">1.1 .分割为4组</span><br><span class="line">1.2 每组不为空</span><br><span class="line">1.3 每组长度 &lt;= 3</span><br><span class="line">1.4 每组在0~255之间</span><br><span class="line">1.5 每组不包含前导0, 除非本身为0</span><br><span class="line">/^[1-9]\d&#123;0,2&#125;$/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2. 合法的IPv6:</span><br><span class="line">2.1 : 分割为8组</span><br><span class="line">2.2 每组不为空</span><br><span class="line">2.3 每组长度 &lt;=4</span><br><span class="line">2.4 每组为一个16进制数: 即字符范围为: 0~9, a~f, A~F</span><br><span class="line">/^[0-9a-fA-F]&#123;1,4&#125;$/</span><br></pre></td></tr></table></figure>

<ul>
<li>说一说进程通信的方式有哪些？</li>
</ul>
<p>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：</p>
<ol>
<li><p>管道</p>
<p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</p>
</li>
<li><p>命名管道</p>
<p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
</li>
<li><p>信号</p>
<p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>消息队列</p>
<p>消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。</p>
</li>
<li><p>共享内存</p>
<p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
</li>
<li><p>内存映射</p>
<p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
</li>
<li><p>信号量</p>
<p>信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</p>
</li>
<li><p>Socket</p>
<p>套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</p>
</li>
</ol>
<ul>
<li>UDP(用户数据报协议)是什么？</li>
</ul>
<p>UDP是OSI参考模型中的传输层协议，是一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>UDP协议有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说UDP协议不能得知报文是否安全完成到达，由于UDP协议只负责将应用程序给IP层的数据报发送出去，不用在客户端与服务器之间建立连接且没有超时重发等机制，所以UDP协议的传输速度很快。</p>
<p>绝大部分UDP应用都不需要可靠机制，甚至可能因为引入可靠机制降低性能，比如流媒体、即时多媒体游戏等应用。如果一个应用需要很高的可靠性可以选择TCP协议。</p>
<ul>
<li>进程与线程</li>
</ul>
<p>进程是操作系统资源分配的基本单位；线程是进程的一个执行单元，是处理器任务调度和执行的基本单位。</p>
<p>线程共享本进程的地址空间和资源，但进程之间是独立的地址空间；</p>
<p>在一个进程中一个线程奔溃会导致整个进程都死掉，但是多进程中一个进程奔溃不会影响其他进程；</p>
<p>每个独立的进程有程序运行的入口、执行顺序和程序出口；但线程是依存在应用程序中的，由应用程序提供多个线程执行控制，两者均可并发执行。</p>
<ul>
<li>线程切换为什么比进程切换容易？</li>
</ul>
<p>操作系统需要保存进程运行所需要的所有状态信息，也就是进程的上下文。在任何时刻，单处理器系统只能执行一个进程，所以当操作系统将控制权从一个进程切换到另一个进程时，需要保存原先进程的上下文，并恢复新进程的上下文，然后将控制权传递给新进程。</p>
<p>但是对线程而言，进程内的所有线程共享进程的虚拟地址空间，在线程进行切换时不会涉及虚拟地址空间的切换。</p>
<ul>
<li>计算机的原码、反码、补码</li>
</ul>
<p>原码就是符号位加上真值的绝对值</p>
<p>反码的话，正数的反码是它本身，负数的反码就是符号位不变，其余各个位取反</p>
<p>补码的话，正数的补码是它本身，负数的补码就是符号位不变，其余各个位取反，最后+1</p>
<ul>
<li>请描述一下cookies,sessionStorage和localStorage的区别：</li>
</ul>
<p>sessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p>
<p>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage 对象也是不同的。</p>
<p>由于webstorage容易受到xss攻击，所以不建议在其中保存比较敏感的信息，避免xss攻击可能通过提前对保存进webstorage中的数据进行加密，以及在读取数据后对数据进行编码、转义。</p>
<p>cookies会发送到服务器端。其余两个不会。</p>
<ul>
<li><p>Cookie</p>
<ul>
<li>每个域名存储量比较小（各浏览器不同，大致4K）</li>
<li>所有域名的存储量有限制（各浏览器不同，大致4K）</li>
<li>有个数限制（各浏览器不同）</li>
<li>会随请求发送到服务器</li>
</ul>
</li>
<li><p>LocalStorage</p>
<ul>
<li>永久存储</li>
<li>Localstorage可以跨窗口与选项卡共享</li>
<li>单个域名存储量比较大（推荐5MB，各浏览器不同）</li>
<li>总体数量无限制</li>
</ul>
</li>
<li><p>SessionStorage</p>
<ul>
<li>只在 Session 内有效</li>
<li>Sessionstorage可以跨窗口与选项卡共享</li>
<li>存储量更大（推荐没有限制，但是实际上各浏览器也不同）</li>
</ul>
</li>
<li><p>如果要保存的cookie数据大于4k，又不想保存在webstorage中怎么办：</p>
</li>
</ul>
<p>可以对cookie数据进行压缩，将cookie中多个键值对看成文本，用文本压缩的方式进行压缩，可以使用gzip或者deflate算法，由于cookie中key,value必须是ascii字符，不能是Unicode字符，所以需要将压缩后的数据进行base64或者base32编码。</p>

      </section>

      
      

      
      
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="http://cdn-ali-img-shstaticbz.shanhutech.cn/bizhi/staticwp/202007/f9c696aa27edaddf87257e5e70d1eb62--1437661584.jpg" class="soft-size--round soft-style--box" alt="ChenZehong">
    
    
      <h2>ChenZehong</h2>
    
    
      <p>贵在坚持</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>32</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        9
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        1
      </div>
    </div>
  </div>
</section>

      

      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/categories/TensorFlow-js/">
            TensorFlow.js (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">
            网站介绍 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            前端学习笔记 (6)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%AE%9E%E4%B9%A0%E7%9B%B8%E5%85%B3/">
            实习相关 (3)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%97%A5%E6%8A%A5/">
            日报 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%AE%97%E6%B3%95/">
            算法 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">
            面试准备 (10)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            react学习笔记 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/Vue3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
            Vue3学习笔记 (5)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;" class="tags-cloud-0">介绍</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>


    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/Web200OK" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">ChenZehong</a></p>

    

    <p>Powered by <a href="https://hexo.io" target="_blank" rel="noopener noreferrer">Hexo</a> Theme - <a href="https://github.com/miiiku/flex-block" target="_blank" rel="noopener noreferrer author">flex-block</a></p>

    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->




  


  


  <!-- Baidu Analytics START -->
  <script>
    var _hmt = _hmt || [];
    (function () {
      if (window.location.hostname === "localhost" || window.location.hostname.startsWith("192.168")) {
        return console.log("本地调试");
      }
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a923e14e6dbf862c2b287e6c1266764";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <!-- Baidu Analytics End -->

  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>