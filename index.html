<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>大三下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="大三下">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="大三下">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ChenZehong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="大三下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">大三下</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试准备/手写系列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/" class="article-date">
  <time datetime="2022-03-18T09:30:13.060Z" itemprop="datePublished">2022-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/">手写系列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>手写promise：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注：promise对象状态与结果只能改变一次</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//初始哈Promise状态：pending</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseState = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">    <span class="comment">//定义Promise结果</span></span><br><span class="line">    <span class="built_in">this</span>.PromiseResult = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">    <span class="comment">//用self接收this指向：Promise构造函数</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//声明resolve函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//Promise状态只能改变一次</span></span><br><span class="line">        <span class="keyword">if</span> (self.PromiseState !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        self.PromiseState = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">        self.PromiseResult = data;</span><br><span class="line">        <span class="comment">//异步任务then方法执行回调</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            self.callbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">                item.onresolved(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//Promise状态只能改变一次</span></span><br><span class="line">        <span class="keyword">if</span> (self.PromiseState !== <span class="string">&quot;pending&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">        self.PromiseState = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">        self.PromiseResult = data;</span><br><span class="line">        <span class="comment">//异步任务then方法执行回调</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            self.callbacks.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">                item.onrejected(data);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//executor构造器，里面为resolve与reject函数</span></span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="comment">//当throw抛出错误时进行捕获执行reject回调</span></span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Promise对象的then方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onresolved, onrejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//用self接收this指向：promise对象</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//对接收的实参进行判断，如果不是函数则将实参定义为函数并返回该实参</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onresolved !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        onresolved = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对接收的实参进行判断，如果不是函数则将实参定义为函数并返回该实参</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onrejected !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        onrejected = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//then方法返回值是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//声明callback方法实现函数复用</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//判断返回的promise对象的结果</span></span><br><span class="line">                <span class="keyword">let</span> result = type(self.PromiseResult);</span><br><span class="line">                <span class="comment">//如果是promise对象则调用then方法，改变promise状态与结果</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                    result.then(</span><br><span class="line">                        <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                            resolve(v);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">                            reject(r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果不是promise对象则调用resolve函数改变promise对象状态与结果</span></span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是抛出错误则调用reject函数改变promise对象状态与结果</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现then方法异步执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                callback(onresolved);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现then方法异步执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                callback(onrejected);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每执行一次then方法当promise状态为pending时就将onresolved与onrejected函数放入callbacks中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.PromiseState === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.callbacks.push(&#123;</span><br><span class="line">                <span class="attr">onresolved</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    callback(onresolved);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onrejected</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    callback(onrejected);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//promise对象catch方法的实现，当抛出错误时进行捕获执行onrejected函数</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onrejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">undefined</span>, onrejected);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//promise内置方法resolve实现</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//resolve返回结果是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//当传入实参为promise对象时，实参调用then方法改变返回promise对象状态与结果</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            value.then(</span><br><span class="line">                <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    resolve(v);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//如果实参不是promise对象，执行resolve函数改变返回promise对象状态与结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//promise内置方法reject实现</span></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//reject返回结果是一个promise对象，直接调用reject方法改变promise结果与状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//promise内置方法all实现</span></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//all返回结果是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//用count进行计数</span></span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="comment">//遍历promises数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            <span class="comment">//数组元素调用then方法，执行resolve函数则count自增</span></span><br><span class="line">            promises[i].then(</span><br><span class="line">                <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//用arr接收每一个promise调用resolve结果</span></span><br><span class="line">                    arr[i] = v;</span><br><span class="line">                    <span class="comment">//当全部数组元素都执行resolve方法，才会执行resolve方法改变返回promise对象状态与结果</span></span><br><span class="line">                    <span class="keyword">if</span> (count == promises.length) &#123;</span><br><span class="line">                        resolve(arr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//只要执行一次reject方法则直接改变返回promise对象状态与结果</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//promise内置方法race实现</span></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//race方法返回结果是一个promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">            <span class="comment">//哪一个数组元素先执行resolve或者reject函数即改变返回promise对象结果与状态</span></span><br><span class="line">            promises[i].then(</span><br><span class="line">                <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    resolve(v);</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>手写instanceof：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手写insatancof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Instanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = left._proto_</span><br><span class="line">    <span class="keyword">while</span>(left)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === right) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        left = left._proto_</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>防抖与节流：</li>
</ul>
<h4 id="防抖实现"><a href="#防抖实现" class="headerlink" title="防抖实现"></a>防抖实现</h4><p>所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<h4 id="节流实现"><a href="#节流实现" class="headerlink" title="节流实现"></a>节流实现</h4><p>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防抖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout) <span class="comment">//与节流区别重点在这句</span></span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(aaa)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;scroll&quot;</span>,debounce(fn1,<span class="number">5000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> begin = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">		<span class="keyword">if</span>(cur - begin &gt; delay)&#123;</span><br><span class="line">			fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">			begin = cur</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(bbb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,throttle(fn2,<span class="number">5000</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>数组扁平化：数组扁平化就是把多维数组转化成一维数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]]</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat())</span><br><span class="line"><span class="built_in">console</span>.log(arr.flat(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item) === <span class="literal">true</span>))&#123;</span><br><span class="line">         arr = [].concat(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>深浅拷贝：</p>
</li>
<li><p><input disabled="" type="checkbox">  浅拷贝：仅仅是复制了引用，彼此之间的操作会互相影响</p>
</li>
<li><p><input disabled="" type="checkbox">  深拷贝：在堆中重新分配内存，不同的地址，相同的值，互不影响</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">initalObj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        obj[i] = initalObj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(obj) !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">var</span> a = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            a[key] = <span class="keyword">typeof</span>(obj[key]) === <span class="string">&quot;object&quot;</span> ? deepClone(obj[key]) : obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>apply、call、bind三个方法的区别：</li>
</ul>
<p>这三个方法都可以显式指定调用函数的this指向，其中apply方法接收两个参数：一个是this绑定的对象，一个是参数数组。call方法接收的参数一个是this绑定的对象，后面的其余参数是传入函数执行的参数，参数是以列举的形式传进去的；bind方法通过传入一个对象返回一个this绑定了传入对象的新函数，这个函数的this指向除了使用new时会被改变，其他情况下都不会改变。</p>
<ul>
<li>实现一个apply函数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myApply</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&quot;type error&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> t = argements[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">    t.fn = self</span><br><span class="line">    <span class="comment">//因为传入的第二个参数是数组，所以直接用扩展运算符生成参数序列即可</span></span><br><span class="line"> 	t.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">delete</span> t.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现一个call函数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">functinon <span class="function"><span class="title">myCall</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function) return console.log(&quot;</span>type error<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    const args = Array.prototype.slice.call(auguments)</span></span><br><span class="line"><span class="string">    //新this的值</span></span><br><span class="line"><span class="string">    let t = args.shift()</span></span><br><span class="line"><span class="string">    //旧this就是要执行的函数</span></span><br><span class="line"><span class="string">    let self = this</span></span><br><span class="line"><span class="string">    //把函数作为新this的方法，这样调用时this默认指向新this</span></span><br><span class="line"><span class="string">    t.fn = self</span></span><br><span class="line"><span class="string">    t.fn(...args)</span></span><br><span class="line"><span class="string">    //函数执行完毕后删除新this中的fn方法</span></span><br><span class="line"><span class="string">    delete t.fn</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现一个bind函数</li>
</ul>
<p>原理：通过apply或call方法实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于在new一个bind过生成的新函数时，必须的条件就是要继承原函数的原型</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将类数组参数转换为数组</span></span><br><span class="line">	<span class="keyword">const</span> arg = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//获取传进的新对象，新的this</span></span><br><span class="line">    <span class="keyword">const</span> t = arg.shift()</span><br><span class="line">    <span class="comment">//获取旧的this，一个函数</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//定义返回的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">newArg</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//新函数可能传入新的参数，需要与旧参数进行拼接</span></span><br><span class="line">        arg = arg.concat.calll(<span class="built_in">Array</span>.prototype.slice.call(newArg))</span><br><span class="line">        <span class="comment">//新函数里需要保持跟旧函数一样的返回值,所以需要执行旧函数，使用apply改变this的值</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(t,arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>用setTimeout实现setInterval：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetTimeout</span>(<span class="params">fn,millisec</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(interval,millisec)</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(interval,millisec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/" data-id="cl0x9xz79001jtsuge9ue6u5a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/数据库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2022-03-12T08:48:54.049Z" itemprop="datePublished">2022-03-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>介绍一下SQL中的聚合函数 </li>
</ul>
<ol>
<li>COUNT()函数：统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数。<ul>
<li>COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。</li>
<li>COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。</li>
</ul>
</li>
<li>AVG()函数：通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。</li>
<li>SUM()函数：是一个求总和的函数，返回指定列值的总和。</li>
<li>MAX()函数：返回指定列中的最大值，不仅适用于查找数值类型，也可应用于字符类型。</li>
<li>MIN()函数：返回查询列中的最小值，不仅适用于查找数值类型，也可应用于字符类型。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="cl0x9xz78001itsug1c1y0r3a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/nodeJS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/" class="article-date">
  <time datetime="2022-03-08T00:56:35.313Z" itemprop="datePublished">2022-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/">node.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>在node中使用axios：</li>
</ul>
<p>axios是基于promise的http请求库，可以用在浏览器和node.js中，一般使用node.js来开发接口，但是当我们需要对第三方的接口进行测试时，除了可以使用一些app比如postman进行测试之外，还可以在node中使用axios向第三方接口发送请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/" data-id="cl0x9xz42000ttsug1rzpe82c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/webpack基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-02-23T01:03:18.400Z" itemprop="datePublished">2022-02-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/">webpack基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>webpack打包原理：</li>
</ul>
<p>webpack将一切文件视为模块，通过定义entry.js对所有的依赖文件进行跟踪，将各个模块通过loader和plugins处理，然后打包在一起。</p>
<ul>
<li> loader 和 plugin 区别是什么？</li>
</ul>
<p>loader是模块转换器，因为webpack只支持对js文件的打包，如果需要进行css、html等文件的打包需要使用相对应的loader，针对的是一个单纯的文件。</p>
<p>plugin是插件，是用于增强webpack功能尚未，针对的是webpack打包的整个过程，比如使用插件将css提取到一个单独的文件中（miini-css-extract-plugin）</p>
<ul>
<li>常用loader与插件（需要使用require引入）及其使用：</li>
</ul>
<h4 id="开发环境下："><a href="#开发环境下：" class="headerlink" title="开发环境下："></a>开发环境下：</h4><p>打包css文件：style-loader、css-loader</p>
<p>打包less文件：style-loader、css-loader、less-loader、less</p>
<p>打包html文件：引入Html-Webpack-Plugin插件，然后在plugins中进行配置，使用template声明复制的html文件</p>
<p>打包jpg/png/gif文件：url-loader，可以在options中配置，limit：图片小于指定大小使用base64处理，esModule指定是否使用es6模块化，name给图片重命名</p>
<p>打包html中的图片：html-loader</p>
<p>打包其他资源：file-loader</p>
<h4 id="生产环境："><a href="#生产环境：" class="headerlink" title="生产环境："></a>生产环境：</h4><p>提取css为单独文件：使用mini-css-extract-plugin插件，然后在plugins中进行配置，可以对输出的css文件重命名,然后使用MiniCssExtractPlugin.loader取代style-loader</p>
<p>css兼容性处理：postcss-loader、postcss-preset-env</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置loader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,</span><br><span class="line">    use:[</span><br><span class="line">        MiniCssExtractPlugin.loader,</span><br><span class="line">        <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">loader</span>:<span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>:&#123;</span><br><span class="line">                <span class="attr">ident</span>:<span class="string">&quot;postcss&quot;</span>,</span><br><span class="line">                <span class="attr">Plugins</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">					<span class="comment">//postcss的插件</span></span><br><span class="line">                    <span class="built_in">require</span>(<span class="string">&quot;postcss-preset-env&quot;</span>)()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置package.json</span></span><br><span class="line"><span class="string">&quot;browserslist&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;development&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;last 1 chrome version&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 1 firefox version&quot;</span>,</span><br><span class="line">    <span class="string">&quot;last 1 safari version&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;production&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;&gt;0.2%&quot;</span>,</span><br><span class="line">    <span class="string">&quot;not dead&quot;</span>,</span><br><span class="line">    <span class="string">&quot;not op_mini all&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压缩CSS：optimize-css-assets-webpack-plugin，直接在plugins中新建一个对象即可</p>
<p>js语法检查：eslint-loader、eslint、eslint-config-airbnb-base、eslint-plugin-import</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在loader中配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">text</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader:<span class="string">&quot;eslint-loader&quot;</span>,</span><br><span class="line">    <span class="attr">options</span>:&#123;</span><br><span class="line">        <span class="attr">fix</span>:<span class="literal">true</span></span><br><span class="line">        <span class="comment">//自动修复语法错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在package.json中进行配置</span></span><br><span class="line"><span class="string">&quot;eslintConfig&quot;</span>:&#123;</span><br><span class="line">    <span class="comment">//设置语法规则</span></span><br><span class="line">    <span class="string">&quot;extends&quot;</span>:<span class="string">&quot;airbnb-base&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js兼容性处理：babel-loader、@babel/core、@babel/preset-env、@babel/ployfill、core-js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在loader中配置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader:<span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">    <span class="attr">options</span>:&#123;</span><br><span class="line">        <span class="comment">//预设：指示babel做怎么样的兼容性处理</span></span><br><span class="line">        <span class="attr">presets</span>:[</span><br><span class="line">            [</span><br><span class="line">                <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//按需加载</span></span><br><span class="line">                    <span class="attr">useBuitIns</span>:<span class="string">&quot;usage&quot;</span>,</span><br><span class="line">                    <span class="comment">//指定core-js版本</span></span><br><span class="line">                    core.js:&#123;</span><br><span class="line">                    	<span class="attr">version</span>:<span class="number">3</span></span><br><span class="line">                	&#125;,</span><br><span class="line">                	<span class="comment">//指定兼容性做到哪个版本的浏览器</span></span><br><span class="line">                	<span class="attr">target</span>:&#123;</span><br><span class="line">                		<span class="attr">chrome</span>:<span class="string">&quot;60&quot;</span>,</span><br><span class="line">                		<span class="attr">firefox</span>:<span class="string">&quot;60&quot;</span>,</span><br><span class="line">                		<span class="attr">ie</span>:<span class="string">&quot;9&quot;</span>,</span><br><span class="line">                		<span class="attr">safari</span>:<span class="string">&quot;10&quot;</span></span><br><span class="line">                	&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js压缩：生产环境下默认压缩代码</p>
<p>html压缩：在Html-Webpack-Plugin中进行配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在插件中进行配置</span></span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">    <span class="attr">minify</span>:&#123;</span><br><span class="line">        <span class="comment">//溢出空格</span></span><br><span class="line">        <span class="attr">collapseWhitespace</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//溢出注释</span></span><br><span class="line">        <span class="attr">removeComments</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>性能优化：</li>
</ul>
<h4 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h4><p>HMR：模块热替换，当一个模块发生变化只会重新打包这个莫快递，无需重新加载整个页面，将dev-serve配置中hot属性更改为true即可。HMR模块对js的处理只能处理非入口js文件的其他文件；html文件默认不能使用HMR功能。</p>
<p>source-map：一种可以提供源代码到构建后的代码映射的技术，有了它以后除错工具可以显示原始代码错误，而不是转换后的代码，在配置文件webpack.config.js中添加键值对：devtool:”eval-source-map”，有多个选项可以根据开发环境或生产环境进行选择。</p>
<p>oneOf：正常来说一个文件一般只需要被一个loader处理，但是在打包过程中全部loader都会匹配一次，可以在rules中声明的oneOf数组可以用来表示不能有两个配置处理同一类型的文件。</p>
<p>缓存：</p>
<ol>
<li>babel缓存：在babel-loader配置添加cacheDirectory:true；</li>
<li>文件资源缓存：在输出文件命名中添加hash值，使用contenthash可以根据文件的内容hash最好的使用缓存，webpack产生的hash与chunkhash都存在弊端。</li>
</ol>
<p>tree-shaking：去除无用代码，没有用到的不会被打包，减少文件体积。前提需要使用es6模块化和开启生产环境，然后在package.json中配置“sideEffects”:”false”，这样所有的代码都会被tree-shaking，可以使用”sideEffects”:[“<code>*.css*</code>“]在数组中声明不需要tree-shaking的文件。</p>
<p>代码分割：</p>
<p>1、在entry配置多个入口文件，最终就会输出多个bundle</p>
<p>2、在webpack.config.js中进行如下配置，可以将node-modules中代码单独打包成一个chunk输出，还可以分析多入口的chunk中，如果一个文件被重复使用，也会打包成一个chunk</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>懒加载：在引入文件的时候使用一下配置实现懒加载，webpackChunkName指定chunk的命名，webpackPrefetch指定是否使用预加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 懒加载~：当文件需要使用时才加载~</span></span><br><span class="line">  <span class="comment">// 预加载 prefetch：会在使用之前，提前加载js文件 </span></span><br><span class="line">  <span class="comment">// 正常加载可以认为是并行加载（同一时间加载多个文件）  </span></span><br><span class="line">  <span class="comment">// 预加载 prefetch：等其他资源加载完毕，浏览器空闲了，再偷偷加载资源</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &#x27;test&#x27;, webpackPrefetch: true */</span><span class="string">&#x27;./test&#x27;</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PWA：渐进式网络开发框架（离线可访问），需要下载workbox-webpack-plugin然后在plugins进行配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">new</span> WorkboxWebpackPlugin.GenerateSW(&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 帮助serviceworker快速启动</span></span><br><span class="line"><span class="comment">        2. 删除旧的 serviceworker</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        生成一个 serviceworker 配置文件~</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="attr">clientsClaim</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">skipWaiting</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//js文件中，由于eslint不认识navigator，window这些对象，所以需要修改eslintConfig配置中的&quot;env“:&#123;&quot;browser&quot;:true&#125;</span></span><br><span class="line"><span class="comment">//同时还需要将sw代码运行在服务器上，需要使用node将资源作为静态资源保存在服务器中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">&#x27;/service-worker.js&#x27;</span>)</span><br><span class="line">      .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册成功了~&#x27;</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sw注册失败了~&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多进程打包：开启多进程打包可以使用thread-loader，但是由于进程启动需要600ms，而且进程通信也有开销，所以只有在js文件多且大的情况下才需要多进程打包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">options</span>: &#123;</span><br><span class="line">                  <span class="attr">workers</span>: <span class="number">2</span> <span class="comment">// 进程2个</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              ]</span><br></pre></td></tr></table></figure>

<p>externals：在webpack.config.js中声明，指定哪些文件不需要进行打包，而是使用外部CDN资源加载</p>
<p>DDL：把第三方代码完全分离开，每次只打包自身的代码，第三方代码只需要打包一次就行。首先先配置webpck.dll.js，如下；然后再在webpack.config.js中进行配置，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包</span></span><br><span class="line"><span class="comment">    当你运行 webpack 时，默认查找 webpack.config.js 配置文件</span></span><br><span class="line"><span class="comment">    需求：需要运行 webpack.dll.js 文件</span></span><br><span class="line"><span class="comment">      --&gt; webpack --config webpack.dll.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="comment">// 最终打包生成的[name] --&gt; jquery</span></span><br><span class="line">    <span class="comment">// [&#x27;jquery&#x27;] --&gt; 要打包的库是jquery</span></span><br><span class="line">    <span class="attr">jquery</span>: [<span class="string">&#x27;jquery&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll&#x27;</span>),</span><br><span class="line">    <span class="attr">library</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span> <span class="comment">// 打包的库里面向外暴露出去的内容叫什么名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 打包生成一个 manifest.json --&gt; 提供和jquery映射</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash]&#x27;</span>, <span class="comment">// 映射库的暴露的内容名称</span></span><br><span class="line">      <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>) <span class="comment">// 输出文件路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> AddAssetHtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 告诉webpack哪些库不参与打包，同时使用时的名称也得变~</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      <span class="attr">manifest</span>: resolve(__dirname, <span class="string">&#x27;dll/manifest.json&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 将某个文件打包输出去，并在html中自动引入该资源</span></span><br><span class="line">    <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="attr">filepath</span>: resolve(__dirname, <span class="string">&#x27;dll/jquery.js&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如何提高webpack打包速度：</li>
</ul>
<p>优化loader：</p>
<p>对babel-loader的文件搜索范围进行优化，配置include以及exclude属性声明在哪里查找js文件以及不去查找的路径，通过cacheDirectory属性对babel文件进行缓存。</p>
<p>HappyPack：将loader的同步执行转换为并行的，使用HappyPack插件。也可以使用官方推荐的thread-loader，</p>
<p>DDLPlugin：将特定的类库提前打包然后引入，这样以后每次打包只会在类库有更新才需要重新打包。</p>
<p>代码压缩：将环境改为生产环境即可</p>
<p>。。。</p>
<ul>
<li>如何减少webpack打包体积：</li>
</ul>
<p>按需加载：在开发单页面应用时对一些路由页面使用按需加载，他们会被单独打包成一个文件，使用import异步引入的方式。</p>
<p>Scope Hoisting：分析模块之间的依赖关系，尽可能把打包的模块合并到一个函数中去，只需要在optimization里面配置concatenateModules为true即可。</p>
<p>tree-shaking：删除项目中没有被引用的代码，开启生产环境就会自动启用这个功能。如果不希望css文件执行tree-shaking，可以在package.json中对”sideEffects”:[“<code>*.css*</code>“]进行配置。</p>
<ul>
<li>bundle、chunk、module是什么：</li>
</ul>
<p>bundle：是由webpack打包出来的文件</p>
<p>chunk：代码块，一个chunk由多个模块组成，用于代码的合并和分割</p>
<p>module：是开发中的单个模块，在webpack中一切皆模块，一个模块对应一个文件，webpack会从入口文件递归开始找出所有依赖的模块</p>
<ul>
<li>webpack构建流程：</li>
</ul>
<p>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>
<p>1、初始化参数：从配置文件和shell语句中读取与合并参数，得出最终的参数</p>
<p>2、开始编译：用上一次得到的参数初始爱compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译</p>
<p>3、确定入口：根据配置中的entry找出所有的入口文件</p>
<p>4、编译模块：从入口文件出发，调用所以配置的loader对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有的入口文件依赖的文件都经过本步骤的处理</p>
<p>5、完成模块编译：在经过第四步使用loader翻译完所以模块后，得到每个模块被翻译后的最终内容以及他们之间的依赖关系</p>
<p>6、输出资源：根据入口与模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转换为一个单独的文件加入到输出列表。</p>
<p>7、输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</p>
<p>在以上过程中，webpack会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用webpack提供的API改变webpack运行结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/" data-id="cl0x9xz46000xtsug5qjs7qas" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/项目相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2022-02-22T10:25:59.228Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/">项目相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>项目难点：</li>
</ul>
<p>在添加商品模块上传图片的时候，因为在elementUi中并没有声明上传图片并不是使用axios请求，所以在将图片发送给服务端的时候失败了，原因是因为axios有在请求拦截器中为每个请求添加服务器返回的token，所以需要手动给图片上传的请求头中添加token ，可以存在cookie，同时在后端开启http only，这样通过document.cookie就读取不到了。</p>
<ul>
<li>项目性能优化：</li>
</ul>
<ol>
<li><p>为项目的开发环境和生产环境配置不同的入口文件：在vue.config.js中配置chainWebpack，config.when为两个环境指定两个不同的入口文件</p>
</li>
<li><p>路由懒加载：将路由相关的组件不再直接导入而是改成异步组件的写法，只有函数被调用时才去加载对应的组件，可以指定webpackChunkName来规定哪些组件打包为一个js文件，如果没有指定则各自打包为一个js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//传统写法：</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line">import Login from &#x27;@/views/login/index.vue&#x27;</span><br><span class="line">import Home from &#x27;@/views/home/home.vue&#x27;</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line"> routes: [</span><br><span class="line">    &#123; path: &#x27;/login&#x27;, component: Login &#125;,</span><br><span class="line">    &#123; path: &#x27;/home&#x27;, component: Home &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line">export default router</span><br><span class="line"></span><br><span class="line">//路由懒加载</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import VueRouter from &#x27;vue-router&#x27;</span><br><span class="line"> </span><br><span class="line">//const  Login = ()=&gt; &#123;</span><br><span class="line">//    return  import(&#x27;@/views/login/index.vue&#x27;)</span><br><span class="line">//&#125;</span><br><span class="line">//const  Home = ()=&gt; &#123;</span><br><span class="line">//    return  import(&#x27;@/views/home/home.vue&#x27;)</span><br><span class="line">//&#125;</span><br><span class="line">//有return且函数体只有一行，所以省略后为</span><br><span class="line">const  Login = ()=&gt; import(&#x27;@/views/login/index.vue&#x27;) </span><br><span class="line"> </span><br><span class="line">const  Home = ()=&gt;  import(&#x27;@/views/home/home.vue&#x27;)</span><br><span class="line"> </span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line"> routes: [</span><br><span class="line">    &#123; path: &#x27;/login&#x27;, component: Login &#125;,</span><br><span class="line">    &#123; path: &#x27;/home&#x27;, component: Home &#125;</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line">export default router</span><br></pre></td></tr></table></figure></li>
<li><p>通过webpack的externals加载外部CDN资源：CDN是内容分发网络，网络请求所需要的时间会受到客户端与服务器距离的影响，CDN就是将资源部署在全国各地，类似于缓存服务器，当请求资源时，会向离客户端最近的CDN服务器请求资源，这样就大大减少了请求所需要的时间，同时vue在打包时会将项目中import的资源都打包进一个包，在vue.config.js中配置externals中声明的资源不会被打包，也会减少包的体积。向CDN请求的资源会在第一次获取到之后缓存在本地，刷新页面会从本地直接读取这些资源，因此第二次打开网页用时更短。</p>
</li>
<li><p>开启gzip资源压缩：使用express的compression实例对文本内容进行压缩。 compression 是 一个express的中间件，主要用于进行gzip 压缩。通常用于web性能优化的，主要是能对你的文本内容进行压缩。一般用于html的文件。</p>
</li>
</ol>
<ul>
<li>echarts：</li>
</ul>
<p>基于一个元素，使用echarts.init来初始化一个实例，然后配置options,使用setOption来使用指定的配置项和数据显示图表。</p>
<ul>
<li>开发git的工作流程：</li>
</ul>
<p>1、新建一个Git仓库，此时默认创建master分支，由于master是用于生产环境的所以必须保证master分支上代码的稳定性，所以要基于master分支创建一个develop分支</p>
<p>2、当需要进行开发时从develop分支中创建新的开发分支，然后编写代码，开发完成后合并到develop分支上</p>
<p>3、新功能合并到develop分支上后如果想要发布到生产环境中需要在develop分支上创建release分支进行测试，测试完成后将该分支分别合并到master分支和develop分支上</p>
<p>4、release分支合并到master分支后需要打上便签用于发布</p>
<p>5、如果在生产环境中出现bug此时需要基于master分支创建一个hotfix分支用于修改bug，bug改完之后在将hotfix分支分别合并到master分支和develop分支上</p>
<ul>
<li>项目还有哪些可以优化的地方：</li>
</ul>
<p><em>优化搜索：</em></p>
<p>由于项目中很多地方出现了搜索框，每一次搜索都需要点击，可以取消点击按钮，在输入之后自动发起请求进行搜索，为了避免短时间内修改搜索框内容多次发起请求，可以使用防抖函数进行优化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> submit = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input&quot;</span>)</span><br><span class="line">      submit.addEventListener(<span class="string">&quot;click&quot;</span>,jieliu(fn))</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(e)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//防抖函数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> t = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(t !== <span class="literal">null</span>) <span class="built_in">clearTimeout</span>(t)</span><br><span class="line">              t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">              &#125;,<span class="number">1000</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//节流函数</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">jieliu</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> begin = <span class="number">0</span></span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">let</span> cur = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">              <span class="keyword">if</span>(cur - begin &gt; <span class="number">1000</span>)&#123;</span><br><span class="line">                  fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">                  begin = cur</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><em>优化token安全性：</em></p>
<p>在项目中只是单纯的将token存放在sessionStorage中，由于sessionStorage很容易拿到所以存在安全隐患。</p>
<ol>
<li>客户端通过用户名密码登录服务器并获取token</li>
<li>客户端生成时间戳并将时间戳作为下次请求的其中一个参数</li>
<li>客户端将所有参数包括token、时间戳按照自己的算法进行排序加密得到签名</li>
<li>将token、时间戳和签名作为请求时必须携带的参数发送给服务器，只有在token有效，时间戳与当前时间戳间隔不超过固定时间段、服务器中不存在签名三种情况同时满足才请求有效</li>
</ol>
<p>使用路由守卫对路由进行优化：</p>
<p>当用户直接跳过登录页面进入网页时，通过在路由守卫中判断是否可以获取到用户的token，如果获取到则允许访问，否则则重定向到登录页。</p>
<h3 id="小程序："><a href="#小程序：" class="headerlink" title="小程序："></a>小程序：</h3><p>项目难点：</p>
<p>视频页实现视频进度的保存：通过一个数组，以每个视频的独有的id作为键，播放时间作为值，当播放一个视频暂停时将当前视频播放时间存进数组中，当重新点击时，通过视频id获取到播放时间，用视频上下文的API实现自动跳转播放。</p>
<p>实现在每日推荐页面听歌实现歌曲切换：用到了两个消息订阅发布，第一个是当切换歌曲时将切换类型，就是歌曲的下一曲或上一曲，通过消息发布给每日推荐页面，然后在每日推荐页面获取到该歌曲的id，然后再通过消息发布给歌曲播放页面。另一种做法可以是在歌曲播放页面直接发送请求获得每日推荐的数据，然后切换歌曲时在数据中查找对应的歌曲然后进行播放。</p>
<p>项目优化：</p>
<p>可以在视频页渲染的时候使用posterAPI让图片代替视频，只有当点击观看视频时才加载视频，这样就不用在视频页一开始就把所有视频加载好，加快页面渲染时间。</p>
<p>由于项目中的搜索框是在输入之后自动发送请求获取相对应的歌曲名，为了避免短时间内修改搜索框内容多次发起请求，可以使用防抖函数进行优化。</p>
<p>由于视频页的视频数据一次请求是有限的，当视频看完之后如果想要继续更新视频数据，由于后端接口设置是隔一段时间才会更新数据，所以不能实现立即下滑刷新的效果。</p>
<ul>
<li>使用vue的element实现大文件的断点续传：</li>
</ul>
<p>1、使用element自带的upload组件，关闭文件加载自动上传（auto-upload），然后自己封装网络请求</p>
<p>2、使用组件的@change监听文件加载，在响应函数参数中file可以得到关于文件的信息，可以进行文件校验（指定提交文件的格式）</p>
<p>3、定义一个文件解析函数fileparse，使用内置函数FileReader构造一个实例对象来解析转换用户存储在计算机上的文件为指定的数据格式，用一个变量result进行接收</p>
<p>用到的事件处理：FileReader.onload：该事件在读取操作完成时触发</p>
<p>用到的方法：</p>
<p>FileReader.readAsArrayBuffer()：将文件对象转换为ArrayBuffer数据对象</p>
<p>FileReader.readAsDataURL()：将文件对象转换为base64的数据对象</p>
<p>4、发送axios请求，将数据对象进行JSON序列化之后再进行传输，服务器接收之后重新转换为数据对象，然后再转换为buffer，最后再转换为文件数据</p>
<p>5、使用spark-md5插件根据buffer生成hash值作为文件名，这样可以避免重复提交相同文件</p>
<p>6、使用fs.writeFileSync将文件写进服务器路径中，给客户端返回响应信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="comment">// 上传BASE64</span></span><br><span class="line">app.post(<span class="string">&#x27;/single2&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">        chunk,</span><br><span class="line">        filename</span><br><span class="line">    &#125; = req.body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk的处理：转换为buffer</span></span><br><span class="line">    chunk = <span class="built_in">decodeURIComponent</span>(chunk);</span><br><span class="line">    chunk = chunk.replace(<span class="regexp">/^data:image\/\w+;base64,/</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    chunk = Buffer.from(chunk, <span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储文件到服务器</span></span><br><span class="line">    <span class="keyword">let</span> spark = <span class="keyword">new</span> SparkMD5.ArrayBuffer(),</span><br><span class="line">        suffix = <span class="regexp">/\.([0-9a-zA-Z]+)$/</span>.exec(filename)[<span class="number">1</span>],</span><br><span class="line">        path;</span><br><span class="line">    spark.append(chunk);</span><br><span class="line">    path = <span class="string">`<span class="subst">$&#123;uploadDir&#125;</span>/<span class="subst">$&#123;spark.end()&#125;</span>.<span class="subst">$&#123;suffix&#125;</span>`</span>;</span><br><span class="line">    fs.writeFileSync(path, chunk);</span><br><span class="line">    res.send(&#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">originalFilename</span>: filename,</span><br><span class="line">        <span class="attr">path</span>: path.replace(__dirname, <span class="string">`http://127.0.0.1:<span class="subst">$&#123;PORT&#125;</span>`</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">changeFile</span>(<span class="params">file</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span><br><span class="line">      file = file.raw;</span><br><span class="line">      <span class="comment">// 继续做格式校验</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 把上传的文件先进行解析（FileReader）</span></span><br><span class="line"><span class="comment">       * 把其转换base64编码格式</span></span><br><span class="line"><span class="comment">       * 自己基于axios把信息传递给服务器</span></span><br><span class="line"><span class="comment">       * ...</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">await</span> fileParse(file, <span class="string">&quot;base64&quot;</span>);</span><br><span class="line">      result = <span class="keyword">await</span> axios.post(</span><br><span class="line">        <span class="string">&quot;/single2&quot;</span>,</span><br><span class="line">        qs.stringify(&#123;</span><br><span class="line">          <span class="attr">chunk</span>: <span class="built_in">encodeURIComponent</span>(result),</span><br><span class="line">          <span class="attr">filename</span>: file.name,</span><br><span class="line">        &#125;),</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">      result = result.data;</span><br><span class="line">      <span class="keyword">if</span> (result.code == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.img = result.path;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileParse</span>(<span class="params">file, type = <span class="string">&quot;base64&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileRead = <span class="keyword">new</span> FileReader();</span><br><span class="line">        <span class="keyword">if</span> (type === <span class="string">&quot;base64&quot;</span>) &#123;</span><br><span class="line">            fileRead.readAsDataURL(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&quot;buffer&quot;</span>) &#123;</span><br><span class="line">            fileRead.readAsArrayBuffer(file);</span><br><span class="line">        &#125;</span><br><span class="line">        fileRead.onload = <span class="function">(<span class="params">ev</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(ev.target.result);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>断点续传：</p>
<p>1、先把文件解析成buffer数据后，根据切片大小或者是切片数量进行分割</p>
<p>2、对切片命名，可以根据文件生成统一的hash值然后再加上一个序号对切片进行命名</p>
<p>3、将切片存放在一个数组中然后遍历数组发送上传请求，用一个变量记录上传切片的数量，一个变量记录上传状态，每上传成功一次变量加1，然后移除数组中已上传的切片。</p>
<p>4、可以设置一个暂停上传按钮，当用户点击暂停时更改上传状态停止上传，如果点击继续上传按钮则根据记录上传切片数量的变量继续发送未发送的文件。</p>
<p>5、后端接收到切片文件之后，将切片文件数据统一存放在一个服务器路径中，然后当所有切片上传完毕之后，按照序列号对切片进行拼接成原来的文件。</p>
<ul>
<li>有在项目中封装过axios吗：</li>
</ul>
<p>有，在项目中需要多次向后端接口发起http请求，如果不对axios进行封装，每一次都需要设置请求头、错误处理、请求路径，会让代码冗杂且浪费时间，所以在项目中对axios进行了封装。</p>
<p>在main.js文件中，安装引入axios，我将axios添加为vue实例方法，即用Vue.prototype将axios设置为所有组件共享的方法，然后在main.js中配置基本路径baseURL，以及因为在每次发送请求都需要携带登录成功后端返回的token，所以通过请求拦截器在每次请求之前在请求头添加上token。因为想要实现网络请求进度条的效果，我使用一个NProgress插件，然后分别在请求时开启进度条，在拦截请求器中结束进度条实现想要的效果。</p>
<ul>
<li>前端怎么做权限管理：</li>
</ul>
<p><strong>接口权限</strong>：采用jwt形式验证，没有通过则跳转到登录页，通过则拿到token保存起来，通过axios请求拦截器在每次请求时在请求头加上token</p>
<p><strong>路由权限</strong>：</p>
<p>1、把所有的页面都放在路由表中，只要在访问的时候判断一下角色权限即可。vue-router在构建路由的时候提供了元信息meta，将能访问到该路由的角色添加到roles中，添加路由守卫，在访问路由前将meta属性与用户角色进行对比，如果用户角色出现在路由中就是可以访问。</p>
<p>缺点：</p>
<p>需要加载所有的路由，如果路由很多对性能有影响；是在全局路由守卫进行配置每次路由跳转都要做权限判断；菜单信息写在前端，任何更改都需要重新编译。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">routes:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&quot;./login&quot;</span>,</span><br><span class="line">		<span class="attr">name</span>:<span class="string">&quot;login&quot;</span>,</span><br><span class="line">		<span class="attr">meta</span>:&#123;</span><br><span class="line">			<span class="attr">roles</span>:[<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;user&quot;</span>]</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">component</span>:<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../component/Login.vue&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2、初始化时先挂载不需要权限控制的路由，比如登录页，404错误页等，如果用户强制进行访问则直接进入404。在vuex中添加获取用户权限信息的方法以及根据权限信息生成可访问路由表的方法，最后在全局路由守卫里调用vue-router的addRoutes方法添加路由。</p>
<p>缺点：在全局路由守卫中配置，每次路由跳转都需要做判断，菜单信息写在前端，更改需要重新编译。</p>
<p><strong>菜单权限</strong>：</p>
<p>1、菜单与路由分离，菜单由后端返回，前端定义路由信息。前端在路由配置时添加name字段，用于与后端返回的菜单信息进行比较。每次路由跳转时都要判断权限，即判断菜单的name与路由的name，如果根据路由name找不到对应的菜单就表示用户没有权限访问。</p>
<p>缺点：菜单与路由需要做一一对应；全局路由守卫，每次路由跳转都需要判断</p>
<p>2、菜单与路由都由后端返回。在前端定义路由组件，后端返回以下格式的路由组件，通过vue-router的addRoutes动态挂载路由。需要前后端配合度更高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;home&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/userinfo&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="string">&quot;userInfo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>按钮权限</strong>：</p>
<p>1、用v-if进行判断用户权限role与路由表中的metabtnPermissions</p>
<p>2、通过自定义指令进行按钮权限的判断</p>
<ul>
<li>使用代理服务器解决跨域问题：</li>
</ul>
<p>1、通过vue-cli搭建的项目可以通过webpack起一个本地服务器作为请求的代理对象，通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是最终发布上线时如果web应用和接口服务器不再一起仍会跨域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js</span></span><br><span class="line">amodule.exports = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="comment">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&quot;&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后通过axios发送请求中配置请求根路径</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;/api&quot;</span></span><br></pre></td></tr></table></figure>

<p>2、通过服务端实现代理请求转发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以express为例</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.use(express.static(__dirname + <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">app.use(<span class="string">&#x27;/api&#x27;</span>, proxy(&#123; <span class="attr">target</span>: <span class="string">&#x27;http://localhost:4000&#x27;</span>, <span class="attr">changeOrigin</span>: <span class="literal">false</span></span><br><span class="line">                      &#125;));</span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br></pre></td></tr></table></figure>

<p>3、配置nginx实现代理</p>
<ul>
<li>怎么处理项目中的错误：</li>
</ul>
<p><strong>后端接口错误</strong>：使用axios的响应拦截器先进行一层拦截，如果如果出错则直接报错。</p>
<p><strong>代码逻辑错误</strong>：</p>
<p>1、全局设置错误处理：</p>
<p>errorHandle：这个处理函数被调用时可获取错误信息与vue实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = function(err,vm,info)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>2、生命周期函数errorCaptured：捕获来自后代组件的错误时被调用，此钩子会受到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串，此构子可以返回false来阻止该错误继续向上传。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/" data-id="cl0x9xz7b001ktsug7ghbg8mp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法/LeetCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/12/%E7%AE%97%E6%B3%95/LeetCode/" class="article-date">
  <time datetime="2022-02-12T09:04:45.227Z" itemprop="datePublished">2022-02-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/12/%E7%AE%97%E6%B3%95/LeetCode/">leetcode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>冒泡排序（空间复杂度O(1)，时间复杂度O(n平方)）：</li>
</ul>
<p>冒泡排序就是从数组头开始比较两个相邻的数，如果前面的数大于后面的数就将两个数交换，然后开始下一对数字的比较，直到数组最后的数字比较完。</p>
<p>然后继续重复刚刚的步骤，除了最后一个数字不用，因为它已经是最大的。</p>
<p>这样一步步重复，直到没有数字需要交换位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>选择排序（空间复杂度O(1)，时间复杂度O(n平方)）：</li>
</ul>
<p>选择排序就是从未排序的数组中找到最小的那一个数放到数组最前面，再从剩余未排序的数组中继续找到最小的数放到已排序的数后面，这样不断的重复直到数组排序完毕。</p>
<ul>
<li>快速排序<strong>（O (n*log n)）</strong>：</li>
</ul>
<p>1、将问题分解成一个个子问题：先把数组按照中点分为两组，对两个数组内的数字按照下标从小到大与中点分别进行比较，如果左边的数组数值比中点小则下标加1更新，右边的比中点大则下标减1，不满足条件则暂停下标更新。</p>
<p>2、当左边或者右边的数组值都暂停更新时，将左右数组两个数互换，这一步的目标是将比中点大的换到数组右边，小的放到左边。</p>
<p>3、每个子问题通过递归完成，由于都是在原数组中进行操作，所以最后数组就是排序好的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span></span><br><span class="line">	<span class="keyword">let</span> i = l - <span class="number">1</span></span><br><span class="line">	<span class="keyword">let</span> j = r + <span class="number">1</span></span><br><span class="line">	<span class="keyword">let</span> t = arr[r + l &gt;&gt; <span class="number">1</span>]</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;i++&#125; <span class="keyword">while</span>(arr[i] &lt; t)</span><br><span class="line">		<span class="keyword">do</span> &#123;j--&#125; <span class="keyword">while</span>(arr[j] &gt; t)</span><br><span class="line">		<span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">			<span class="keyword">let</span> temp = arr[i]</span><br><span class="line">			arr[i] = arr[j]</span><br><span class="line">			arr[j] = arr[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	quickSort(arr,l,j)</span><br><span class="line">	quickSort(arr,j + <span class="number">1</span>,r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序（O (n*log n)：</li>
</ul>
<p>归并与快排的基本思想都是分治，但是归并是一上来就递归。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> mid = r + l &gt;&gt; <span class="number">1</span></span><br><span class="line">    mergeSort(arr,l,mid)</span><br><span class="line">    meergeSort(arr,mid + <span class="number">1</span>,r)</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> i = l</span><br><span class="line">    <span class="keyword">let</span> j = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="built_in">Array</span>(r - l + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[t++] = arr[i++]</span><br><span class="line">        <span class="keyword">else</span> temp[t++] = arr[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[t++] = arr[i++]</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[t++] = arr[j++]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = l,t = <span class="number">0</span>;i &lt;= r;i++,t++)&#123;</span><br><span class="line">        arr[i] = temp[t]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>斐波拉契数列：</li>
</ul>
<p><em>F</em>(<em>n</em>)=<em>F</em>(<em>n</em>−1)+<em>F</em>(<em>n</em>−2)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">let</span> p = <span class="number">0</span>,q = <span class="number">0</span>,r = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		p = q</span><br><span class="line">		q = r</span><br><span class="line">		r = (p + q) % <span class="number">1000000007</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></p>
<p>使用栈，将左边括号存储进数组中，当出现右括号时，弹出最顶层元素与之比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">let</span> arr = s.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="string">&quot;(&quot;</span> || arr[i] == <span class="string">&quot;[&quot;</span> || arr[i] == <span class="string">&quot;&#123;&quot;</span>) stack.push(arr[i])</span><br><span class="line">        <span class="keyword">switch</span>(arr[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;)&quot;</span> : &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == <span class="string">&quot;(&quot;</span>) <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;]&quot;</span> : &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == <span class="string">&quot;[&quot;</span>) <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;&#125;&quot;</span> : &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.pop() == <span class="string">&quot;&#123;&quot;</span>) <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">最小栈</a></p>
<p>用一个栈存储数，一个栈存储所有数中的最小数，每一次push和pop两个栈都需要添加渔删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MinStack = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">    <span class="built_in">this</span>.minStack = []</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">val</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.push(val)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.minStack.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.minStack.push(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.minStack.push(<span class="built_in">this</span>.minStack[<span class="built_in">this</span>.minStack.length - <span class="number">1</span>] &lt;= val ? <span class="built_in">this</span>.minStack[<span class="built_in">this</span>.minStack.length - <span class="number">1</span>] : val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stack.pop()</span><br><span class="line">    <span class="built_in">this</span>.minStack.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.top = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MinStack.prototype.getMin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minStack[<span class="built_in">this</span>.minStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">回文链表</a></p>
<p>先用数组存储链表中所有元素，然后用双指针比较左半边与右半边的元素是否相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr= []</span><br><span class="line">    <span class="keyword">while</span>(head !== <span class="literal">null</span>)&#123;</span><br><span class="line">        arr.push(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="built_in">Math</span>.ceil(arr.length);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] !== arr[arr.length - <span class="number">1</span> - i]) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-string/">字符串解码</a></p>
<p>用栈存储每一个字符，当遇到”]”时将前面的字母弹出，并弹出次数然后重复之后重新压入栈中，最后将栈返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> decodeString = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> arr = s.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] !== <span class="string">&quot;]&quot;</span>) &#123;</span><br><span class="line">            stack.push(arr[i]) <span class="comment">//将&quot;]&quot;左边的元素压栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">let</span> cur = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span>(stack[stack.length - <span class="number">1</span>] !== <span class="string">&quot;[&quot;</span>)&#123;</span><br><span class="line">                str = str + stack.pop() <span class="comment">//弹出字母并拼接成串</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop() <span class="comment">//弹出&quot;[&quot;</span></span><br><span class="line">            <span class="keyword">let</span> num = <span class="string">&quot;&quot;</span></span><br><span class="line">            cur = stack.pop() </span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">isNaN</span>(num))&#123;</span><br><span class="line">                num = cur + num <span class="comment">//记录重复次数</span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(cur) <span class="comment">//因为上面的while最后多弹出了一个元素，所以重新压栈</span></span><br><span class="line">            stack.push(str.repeat(num)) <span class="comment">//将重复好的字符串继续压进栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>) <span class="comment">//将栈数组返回为字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/"> 最短无序连续子数组</a></p>
<p>浅拷贝数组然后进行比较，从左往右第一个就是最短无序连续子数组的第一个数，从右往左第一个就是子数组的最后一个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findUnsortedSubarray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSorted(nums)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> numsSorted = [...nums].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[left] === numsSorted[left]) &#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (nums[right] == numsSorted[right]) &#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSorted = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">每日温度 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
<p>暴力算法：直接遍历两次数组，用一个新数组保存更高温度天数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span>(<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; temperatures.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>;j &lt; temperatures.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &lt; temperatures[j])&#123;</span><br><span class="line">                arr.push(j - i)</span><br><span class="line">                j = temperatures.length</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j === temperatures.length - <span class="number">1</span>)&#123;</span><br><span class="line">                arr.push(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>单调栈算法：只需要遍历一次数组，从后往前遍历温度数组，新建一个栈，遍历数组同时将元素索引放入栈中，当下一个元素比栈中元素大时，将小项元素索引弹出，让大项元素索引入栈，最后直接让索引相减就是当前元素的结果，再用一个数组保存起来。当下一个元素比栈顶元素小时，直接让其索引入栈即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyT = <span class="function">(<span class="params">T</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(T.length).fill(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = T.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(stack.length &amp;&amp; T[i] &gt;= T[stack[stack.length - <span class="number">1</span>]])&#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.length)&#123;</span><br><span class="line">            res[i] = stack[stack.length - <span class="number">1</span>] - i</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a>:</li>
</ul>
<p>使用二叉树的前序遍历，用一个数组保存遍历的节点，由于左子节点需要是null，所以使用for循环对数组节点左子节点赋值为null，然后右子节点设置为下一个索引值。</p>
<p>也可以将for循环改为while循环，优化了空间存储。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> list= []</span><br><span class="line">    a(root,list)</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; list.length - <span class="number">1</span>)&#123;</span><br><span class="line">        list[i].left = <span class="literal">null</span></span><br><span class="line">        list[i].right = list[++i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前序遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">node,list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        list.push(node)</span><br><span class="line">        a(node.left,list)</span><br><span class="line">        a(node.right,list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">最长有效括号</a></li>
</ul>
<p>从左到右遍历字符串数组，创建一个栈，如果出现左括号则让该位置的索引入栈，如果栈中有元素且扫描到右括号则进行出栈操作，让max长度为当前索引减去栈顶元素。为了避免一组括号出现之后继续出现括号，max无法计算到前面的一对括号长度，所以在初始化栈的时候将-1压入栈中，如果-1被出栈，那么需要有一个新的参照数进栈，则就是匹配到右括号时且栈长度为0时将当前索引进栈作为参照数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestValidParentheses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = s.split(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    stack.push(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] === <span class="string">&quot;(&quot;</span>)&#123; <span class="comment">//左括号的索引进栈</span></span><br><span class="line">            stack.push(i)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//遍历到右括号</span></span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">if</span>(stack.length)&#123;</span><br><span class="line">                max = <span class="built_in">Math</span>.max((i - stack[stack.length -<span class="number">1</span>]),max)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//栈空了</span></span><br><span class="line">                stack.push(i) <span class="comment">//入栈当参照物</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">对称二叉树</a></li>
</ul>
<p>方法一：使用递归对左右子树的子节点进行比较，对称需要满足：</p>
<ol>
<li>它们的两个根结点具有相同的值</li>
<li>每个树的右子树都与另一个树的左子树镜像对称</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root,root)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//!node1 &amp;&amp; !node2这个判断需要放在第一个，这样当两个元素都是null的时候就会直接返回true，如果让!node1 || !node2判断放在第一会返回false</span></span><br><span class="line">    <span class="keyword">if</span>(!node1 &amp;&amp; !node2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(!node1 || !node2) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> node1.val === node2.val &amp;&amp; check(node1.left,node2.right) &amp;&amp; check(node1.right,node2.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用队列，每一次比较弹出队首两个元素进行比较，使用while循环迭代</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代版本</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> check(root,root)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> queue = []</span><br><span class="line">   queue.push(node1)</span><br><span class="line">   queue.push(node2)</span><br><span class="line">   <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">       <span class="keyword">let</span> p = queue.shift()</span><br><span class="line">       <span class="keyword">let</span> q = queue.shift()</span><br><span class="line">       <span class="comment">//!node1 &amp;&amp; !node2这个判断还是需要放在第一，但是不是返回true而是直接跳出本次循环</span></span><br><span class="line">       <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">continue</span></span><br><span class="line">       <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       <span class="keyword">if</span>(p.val === q.val)&#123;</span><br><span class="line">            queue.push(p.left)</span><br><span class="line">            queue.push(q.right)</span><br><span class="line">            queue.push(p.right)</span><br><span class="line">            queue.push(q.left)</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></li>
</ul>
<p>方法一：深度搜索。节点为空时说明高度为 0，所以返回 0；节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> f = maxDepth(root.left)</span><br><span class="line">    <span class="keyword">let</span> r = maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(f,r) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：广度搜索</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    queue.push(root)</span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//需要使用一个变量保存队列长度，不然下面的循环如果加入新节点会改变队列长度</span></span><br><span class="line">        <span class="keyword">let</span> size = queue.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            <span class="keyword">if</span>(node.left) queue.push(node.left)</span><br><span class="line">            <span class="keyword">if</span>(node.right) queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></li>
</ul>
<p>使用递归从叶子节点开始翻转，最后回溯到根节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span> </span><br><span class="line">    <span class="keyword">let</span> l =invertTree(root.left)</span><br><span class="line">    <span class="keyword">let</span> r = invertTree(root.right)</span><br><span class="line">    root.left = r</span><br><span class="line">    root.right = l</span><br><span class="line">    <span class="keyword">return</span> root </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/"> 二叉树的直径</a></li>
</ul>
<p>使用递归从叶子节点开始回溯，返回值是当前节点的深度，树的直径用max接收，每回溯一次就更新一次，它相当于所有节点的最大左子树深度+所有节点的最大右子树深度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> l = check(node.left)</span><br><span class="line">        <span class="keyword">let</span> r = check(node.right)</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max,l + r)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(l,r) + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    check(root)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">合并二叉树</a></li>
</ul>
<p>使用dfs深度遍历，每一次递归返回一个节点，回溯的时候将返回的节点作为新节点的左节点或者右节点，最终回溯到根节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当一个节点为null时，返回另一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2</span><br><span class="line">    <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(</span><br><span class="line">        root1.val + root2.val,</span><br><span class="line">        mergeTrees(root1.left,root2.left),</span><br><span class="line">        mergeTrees(root1.right,root2.right)</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/12/%E7%AE%97%E6%B3%95/LeetCode/" data-id="cl0x9xz3a000atsug4ktsftwr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-机器学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-01-20T14:30:12.238Z" itemprop="datePublished">2022-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TensorFlow-js/">TensorFlow.js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">神经网络</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>神经网络的层：</li>
</ul>
<p>第一层称为输入层，节点数量取决于数据集中存在的特征数量</p>
<p>最后一层称为输出层，数量取决于要预测的内容，对于回归和二元分类任务可以使用单个节点；对于多类问题，将使用多个节点，具体取决于类的数量</p>
<p>中间的层称为隐藏层，隐藏层可以任意深或宽，计算时间会随深入而增加</p>
<ul>
<li>权重与偏差：</li>
</ul>
<p>权重：衡量某个特征对预测的贡献程度的确定程度</p>
<p>偏差：预测必须从其开始的基值</p>
<ul>
<li>激活函数：</li>
</ul>
<p>激活函数由神经网络隐藏层中的每个节点计算</p>
<p>输出层计算的结果不是通过另一个激活函数传递，而是通过输出函数传递，取决于要预测的内容</p>
<ul>
<li>损失函数：</li>
</ul>
<p>损失函数是一种衡量模型预测好坏的方法，可以调整权重和偏差</p>
<p>必须正确设计损失函数，以便可以正确地惩罚错误的模型奖励正确的模型，这意味着希望损失表明所做的预测是远离还是接近真实预测。损失函数取决于任务，对于分类问题可以使用交叉熵损失。</p>
<ul>
<li>前进：前向传播</li>
</ul>
<p>前向传播是神经网络在做出预测之前执行的一系列计算的名称</p>
<ul>
<li>反向传播：</li>
</ul>
<p>反向传播是通过更新其权重和偏差来训练神经网络的过程的名称</p>
<p>神经网络通过不断尝试不同的权重然后比较损失来学习预测正确的值，如果损失函数减少，那么当前的权重比之前的要好，反之亦然。这意味着神经网络必须经过多次训练和更新循环才能获得最佳权重和偏差。这个循环就是训练阶段，寻找合适的权重的过程就是优化。</p>
<ul>
<li>训练和测试网络：</li>
</ul>
<p>将数据拆分为训练集和测试集</p>
<p>对其进行标准化</p>
<p>初始化一个模型</p>
<p>使用模型进行训练和预测</p>
<h3>卷积神经网络（CNN）</h3>

<ul>
<li>CNN是如何工作的？</li>
</ul>
<p>1、图像由像素组成，每个像素由0~255之间的数字表示，这是计算机处理图像的方式。</p>
<p>卷积过程中需要三个重要的项目：输入图像、特征检测器和特征图。输入图像是被检测的图像，特征检测器是一个矩阵，也称为内核或过滤器。直观地说，输入图像的矩阵表示与特征检测器逐元素相乘以产生特征图，也称为卷积特征或激活图。此步骤目的是为了减少图像大小并处理更快、更容易，在此步骤中丢失了图像的一些特征。</p>
<p>2、在此步骤中应用整流函数（Relu）来增加CNN中的非线性，图像由彼此非线性的不同对象组成。</p>
<p>3、池化</p>
<p>由于物体的空间不变性，即一个物体在图像中的位置不会影响神经网络检测其特定特征的能力。池化使CNN能够检测各种图像中的特征，而不考虑图像中的照明差异和图像的不同角度。</p>
<p>由不同类型的池化：如最小池化和最大池化。最大池化的工作原理是在特征图上放置一个2*2矩阵，并在该框中挑选最大的值，然后从左向右移动，穿过整个特征图，每次挑选最大的值。</p>
<p>这些值最后形成一个新的矩阵，成为池化特征图，作用是保留主要特征，同时减少图像大小，这有助于减少过度拟合。</p>
<p>4、展平</p>
<p>将整个池化特征图矩阵转换为单个列，然后将其馈送到神经网络中进行处理。</p>
<p>5、全连接</p>
<p>这一步由输入层、全连接层和输出层组成，全连接层相当于人工神经网络中的隐藏层，但它是全连接的。</p>
<ul>
<li>使用TensorFlow的Keras库实现卷积神经网络</li>
</ul>
<p>1、导入需要的包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Convolution2D</span><br><span class="line">from keras.layers import MaxPooling2D</span><br><span class="line">from keras.layers import Flatten</span><br><span class="line">from keras.layers import Dense</span><br></pre></td></tr></table></figure>

<p>Sequential：初始化神经网络</p>
<p>Convolution2D：用于制作处理图像的卷积网络</p>
<p>MaxPooling2D：用于添加池化层</p>
<p>Flatten：将池化特征图转换为单个列并传递给全连接层的函数</p>
<p>Dense：将全连接层添加到神经网络</p>
<p>2、初始化神经网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier = Sequential()</span><br></pre></td></tr></table></figure>

<p>3、卷积</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Convolution2D(32, 3, 3, input_shape = (256, 256, 3), activation=’relu’))</span><br></pre></td></tr></table></figure>

<p>添加卷积层，第一个参数是想要创建的特征检测器的数量，通常是以32个开始，第二和第三个参数是特征检测器矩阵的尺寸。input_shape是输入图形的形状，黑白图像转换为二维数组，彩色转换为三维数组。最后一个参数是激活函数，图像分类是一个非线性问题，使用relu函数可以确保在计算过程中没有负数像素值。</p>
<p>4、池化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(MaxPooling2D(pool_size=(2,2)))</span><br></pre></td></tr></table></figure>

<p>通常创建一个2*2的池大小。</p>
<p>5、展平</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Flatten())</span><br></pre></td></tr></table></figure>

<p>6、全连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Dense(output_dim = 128, activation=’relu’))</span><br></pre></td></tr></table></figure>

<p>通过使用Dense函数将上面得到的向量作为神经网络的输入，第一个参数是全连接层的节点数，维数越多，拟合模型所需要的计算资源越多，一般选择2的幂。第二个函数时激活函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.add(Dense(output_dim=1, activation=’sigmoid’))</span><br></pre></td></tr></table></figure>

<p>添加输出层。期望得到二元结果使用sigmoid函数，期望得到两个以上结果，使用softmax函数。</p>
<p>7、编译CNN</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.compile(optimizer=’adam’, loss=’binary_crossentropy’,metrics=[‘accuracy’])</span><br></pre></td></tr></table></figure>

<p>使用编译函数编译CNN，需要三个参数：优化器、损失函数和性能指标。</p>
<p>8、拟合CNN</p>
<p>进行图像增强处理防止过度拟合，是通过翻转、重新缩放、缩放和裁剪图像来进行工作的。第一个参数是确保图像被重新缩放后值介于0~1之间，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from keras.preprocessing.image import ImageDataGenerator</span><br><span class="line">train_datagen = ImageDataGenerator(rescale=1./255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True)</span><br><span class="line">test_datagen = ImageDataGenerator(rescale=1./255)</span><br></pre></td></tr></table></figure>

<p>测试数据不需要跟训练数据一样采用图像增强。接下来是创建训练集和测试集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">training_set = train_datagen.flow_from_directory(‘training_set’, target_size=(256, 256), batch_size=32, class_mode=’binary’)</span><br><span class="line">test_set = test_datagen.flow_from_directory(‘test_set’, target_size=(64, 64), batch_size=32, class_mode=’binary’)</span><br></pre></td></tr></table></figure>

<p>第一个参数是训练集的路径，第二个参数是CNN期望的图像大小。btach_size是在权重更新之前通过网路的图像数量，class_mode指示分类是否是二进制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classifier.fit_generator(training_set, steps_per_epoch=5000, epochs=25, validation_data=test_set, nb_val_samples=1000)</span><br></pre></td></tr></table></figure>

<p>最后调用拟合函数并使用测试集测试其性能，第一个参数是训练集，第二个参数是训练集中的参数数量，第三个参数是训练的次数，第四个参数是测试集，最后一个参数是测试集的参数数量。</p>
<p>9、进行单一预测</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">from keras.preprocessing import image</span><br></pre></td></tr></table></figure>

<p>使用预测函数使用新图像进行预测，在这之前需要对其进行预处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_image = image.load_img(‘brain_image1.jpg’, target_size=(256, 256))</span><br></pre></td></tr></table></figure>

<p>加载想要预测的图像，第一个参数是图像的路径，第二个参数是图像的大小，应与训练过程中的大小相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_image = image.img_to_array(test_image)</span><br></pre></td></tr></table></figure>

<p>使用彩色图像则将图像转换为一个三维数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_image = np.expand_dims(test_image, axis=0)</span><br><span class="line">prediction = classifier.predict(test_image)</span><br></pre></td></tr></table></figure>

<p>预测需要四个维度，第四个维度对应批量大小，这是因为在神经网络中要预测的数据通常作为批次传入。使用np.expand_dims函数添加这个维度，最后使用predict预测图像。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" data-id="cl0x9xz320006tsug89w18597" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-大三寒假日报" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/13/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/" class="article-date">
  <time datetime="2022-01-13T03:42:21.000Z" itemprop="datePublished">2022-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">大三寒假日报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/13/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">春招加油！</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="寒假目标："><a href="#寒假目标：" class="headerlink" title="寒假目标："></a>寒假目标：</h3><p>学英语、学习typescript、面试准备、完成后台和VR项目、上手Vue3、数据库（备选）</p>
<h4 id="寒假第一天："><a href="#寒假第一天：" class="headerlink" title="寒假第一天："></a>寒假第一天：</h4><p>Vue：</p>
<p>后台管理项目商品模块完善（P167）</p>
<h4 id="2022-1-18"><a href="#2022-1-18" class="headerlink" title="2022-1-18"></a>2022-1-18</h4><p>Vue:</p>
<p>后台管理系统订单及数据报表模块完成（P198）</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/f3e7ed16517c8fd8.png"></p>
<h4 id="2022-1-19"><a href="#2022-1-19" class="headerlink" title="2022-1-19"></a>2022-1-19</h4><p>Vue：</p>
<p>复盘项目代码，整理笔记</p>
<p>TensorFlow.js：</p>
<p>完成线性回归模型可视化面板的搭建</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/6e6be5a25c40e898.png"></p>
<h4 id="2022-1-20"><a href="#2022-1-20" class="headerlink" title="2022-1-20"></a>2022-1-20</h4><p>小程序：</p>
<p>代码复盘，完善简历</p>
<p>面试准备：</p>
<p>复习html面试题，模拟面试两次</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/e6aa81e9d10b2e04.png"></p>
<h4 id="2022-1-21"><a href="#2022-1-21" class="headerlink" title="2022-1-21"></a>2022-1-21</h4><p>TensorFlow：</p>
<p>完成模型保存、加载与预测</p>
<p>面试：</p>
<p>完成模拟面试两次</p>
<p>看书：</p>
<p>阅读《百年孤独》</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/b7b46f1d529fdb65.png"></p>
<h4 id="2022-1-22"><a href="#2022-1-22" class="headerlink" title="2022-1-22"></a>2022-1-22</h4><p>学习<code>typescript</code></p>
<p>面试准备</p>
<h4 id="2022-1-23"><a href="#2022-1-23" class="headerlink" title="2022-1-23"></a>2022-1-23</h4><p>学习<code>typescript</code></p>
<h4 id="2022-1-24"><a href="#2022-1-24" class="headerlink" title="2022-1-24"></a>2022-1-24</h4><p>TensorFlow.js：</p>
<p>学习了卷积网络的基础知识</p>
<p>安装了双系统为了在linux上运行TensorFlow.js</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/c1c98a83d42ebf7e.png"></p>
<h4 id="2022-1-25"><a href="#2022-1-25" class="headerlink" title="2022-1-25"></a>2022-1-25</h4><p>Vue：</p>
<p>学习了Vue2响应式的实现：发布订阅加数据劫持</p>
<p>TensorFlow.js：</p>
<p>折腾了一下午，bug还是没能解决~~~</p>
<p>面试准备：</p>
<p>自我介绍以及排序算法和计网知识的巩固</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/68fbcf143fd8f250.png"></p>
<h4 id="2022-1-26"><a href="#2022-1-26" class="headerlink" title="2022-1-26"></a>2022-1-26</h4><p>面试准备：</p>
<p>看完了计网相关的面试题，以及JS的闭包和事件循环机制</p>
<p>看书：<br>看完了鬼谷子的第一章节内容</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/01/08124c7cf4f332b3.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/13/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/" data-id="cl0x9xz2r0003tsugba8h2ku8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-算法/基本算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/10/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-12-10T12:00:24.925Z" itemprop="datePublished">2021-12-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/10/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/">acwing打卡题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a><strong>1、快速排序</strong></h3><p>给定你一个长度为 nn 的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<p><strong>输入格式</strong></p>
<p>输入共两行，第一行包含整数 nn。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出共一行，包含 nn 个整数，表示排好序的数列。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>快速排序的本质思想是分治。</p>
<p>时间复杂度：<strong>O (n*log n)</strong></p>
<p>步骤：</p>
<p>1、将问题分解成一个个子问题：先把数组按照中点分为两组，对两个数组内的数字按照下标从小到大与中点分别进行比较，如果左边的数组数值比中点小则下标加1更新，右边的比中点大则下标减1，不满足条件则暂停下标更新。</p>
<p>2、当左边或者右边的数组值都暂停更新时，将左右数组两个数互换，这一步的目标是将比中点大的换到数组右边，小的放到左边。</p>
<p>3、每个子问题通过递归完成，由于都是在原数组中进行操作，所以最后数组就是排序好的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = getInputArgs(line)</span><br><span class="line">            quickSort(rr,<span class="number">0</span>,arr.length - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(arr.join(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//快排函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = r + <span class="number">1</span></span><br><span class="line">    <span class="comment">//此处将i-1，j+1是为了解决边界问题，避免死循环</span></span><br><span class="line">    <span class="keyword">let</span> t = arr[r + l &gt;&gt; <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;i++&#125; <span class="keyword">while</span>(arr[i] &lt; t)</span><br><span class="line">        <span class="keyword">do</span> &#123;j--&#125; <span class="keyword">while</span>(arr[j] &gt; t)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">            arr[j] = arr[i]</span><br><span class="line">            arr[i] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里使用i或者j作为实参都可以，但是只能使用一个，而且两个使用不同</span></span><br><span class="line">    quickSort(arr,l,j)</span><br><span class="line">    quickSort(arr,j + <span class="number">1</span>,r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、第k个数"><a href="#2、第k个数" class="headerlink" title="2、第k个数"></a>2、第k个数</h3><p>给定一个长度为 nn 的整数数列，以及一个整数 kk，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 nn 和 kk。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示数列的第 kk 小数。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000,<br>1≤k≤n1≤k≤n</p>
<p>输入样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>使用快排的代码进行排序，由于是输出从小到大第k个数，基于这个条件约束可以对代码进行调整，每一个只快速排序有k的一边即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getInputArgs = <span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">l,r,k</span>)</span>&#123;</span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">            k = getInputArgs(line)[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="number">1</span>)&#123;</span><br><span class="line">            arr = getInputArgs(line)</span><br><span class="line">            <span class="built_in">console</span>.log(quickSort(<span class="number">0</span>,arr.length - <span class="number">1</span>,k))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">l,r,k</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> arr[r]</span><br><span class="line">    <span class="keyword">let</span> i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> j = r + <span class="number">1</span></span><br><span class="line">    <span class="comment">//此处将i-1，j+1是为了解决边界问题，避免死循环</span></span><br><span class="line">    <span class="keyword">let</span> t = arr[r + l &gt;&gt; <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;i++&#125; <span class="keyword">while</span>(arr[i] &lt; t)</span><br><span class="line">        <span class="keyword">do</span> &#123;j--&#125; <span class="keyword">while</span>(arr[j] &gt; t)</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">            arr[j] = arr[i]</span><br><span class="line">            arr[i] = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(l.j,k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quickSort(j + <span class="number">1</span>,r,k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、归并排序"><a href="#3、归并排序" class="headerlink" title="3、归并排序"></a>3、归并排序</h3><p>给定你一个长度为 nn 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<p><strong>输入格式</strong></p>
<p>输入共两行，第一行包含整数 nn。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出共一行，包含 nn 个整数，表示排好序的数列。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>归并排序的主要思想也是分治。</p>
<p>时间复杂度：<strong>O（nlogn）</strong></p>
<p>步骤：</p>
<p>1、与快排最后才递归不同，归并一上来先用中点将数组分为左右两个数组，然后用递归将问题分解为一个个子问题，</p>
<p>2、处理子问题：左右两个数组分别从左往右比较，如果左边数组的值比右边的小则将左边的数推进（<code>push</code>）新建的数组中，并更新左边数组下标（加1），反之则将右边的数存进新数组。</p>
<p>3、当左边的数组或者右边的数组没有数可以进行比较时，将剩下数组的数全部存进新数组中（由于 先递归，所以数组会被一直分割到最小长度，然后从最小长度数组进行比较，所以第三步剩下数组后面的数都是具有单调性的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> getInputArgs = <span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">line,lineIdx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lineIdx === <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> arr = getInputArgs(line)</span><br><span class="line">            mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(arr.join(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> mid = r + l &gt;&gt; <span class="number">1</span></span><br><span class="line">    mergeSort(arr,l,mid)</span><br><span class="line">    meergeSort(arr,mid + <span class="number">1</span>,r)</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> i = l</span><br><span class="line">    <span class="keyword">let</span> j = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="built_in">Array</span>(r - l + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[t++] = arr[i++]</span><br><span class="line">        <span class="keyword">else</span> temp[t++] = arr[j++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[t++] = arr[i++]</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[t++] = arr[j++]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = l,t = <span class="number">0</span>;i &lt;= r;i++,t++)&#123;</span><br><span class="line">        arr[i] = temp[t]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4、逆序对的数量"><a href="#4、逆序对的数量" class="headerlink" title="4、逆序对的数量"></a>4、逆序对的数量</h3><p>给定一个长度为 nn 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 ii 个和第 jj 个元素，如果满足 i&lt;ji&lt;j 且 a[i]&gt;a[j]a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 nn，表示数列的长度。</p>
<p>第二行包含 nn 个整数，表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000，<br>数列中的元素的取值范围 [1,109][1,109]。</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>由于归并排序先递归，所以是先将数组分割为很多最小长度数组，然后从最小长度数组（即数组要么只有一个数，要么只有两个数）开始排序，所以当每一次回溯的时候，序列两边其实是排好序的，具有单调性，所以我们可以从这一点思考。将序列从中间分开，那么逆序对只能是这种情况：两个元素一个在左，一个在右。</p>
<p>比如：4 5 6 | 1 2 3 ，我们将4与1进行比较，发现这两个数构成逆序对，由于左右两边数组都具有单调性，那么我们就知道5和6也是与1构成逆序对的，这个时候就可以直接跳过1与5、6 比较的情形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((l+r)/<span class="number">2</span>)</span><br><span class="line">    mergeSort(arr,l,mid)</span><br><span class="line">    mergeSort(arr,mid+<span class="number">1</span>,r)</span><br><span class="line">    <span class="keyword">let</span> i = l</span><br><span class="line">    <span class="keyword">let</span> j = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> temp = <span class="keyword">new</span> <span class="built_in">Array</span>(r-l+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r )&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[t++] = arr[i++]</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//n记录的就是逆序对的数量，当右边数组数小于左边的时候，即从i开始到mid的属于左边的数都与右边数组的这个数构成逆序对</span></span><br><span class="line">            n += (mid-i+<span class="number">1</span>)</span><br><span class="line">            temp[t++] = arr[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) temp[t++] = arr[i++]</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) temp[t++] = arr[j++]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = l,t = <span class="number">0</span>;t &lt; temp.length;i++,t++)&#123;</span><br><span class="line">        arr[i] = temp[t]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">process.stdin.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read();</span><br><span class="line">    <span class="keyword">if</span> (chunk) buf += chunk.toString();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> getInputArgs = <span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&#x27; &#x27;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&#x27;&#x27;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x));</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    buf.split(<span class="string">&#x27;\n&#x27;</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">line, lineIdx</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lineIdx === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> arr = getInputArgs(line);</span><br><span class="line">            mergeSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5、数的范围"><a href="#5、数的范围" class="headerlink" title="5、数的范围"></a>5、数的范围</h3><p>给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。</p>
<p>对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 nn 和 qq，表示数组长度和询问个数。</p>
<p>第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p>
<p>接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。</p>
<p><strong>输出格式</strong></p>
<p>共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000<br>1≤q≤100001≤q≤10000<br>1≤k≤100001≤k≤10000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>由于输入的样例是升序的，并且是要查找某一个数的范围，那么我们就应该考虑用二分法。</p>
<p>步骤：</p>
<p>1、根据要查找的目标值对数组样例进行二分查找，即用数组中间的值与目标值进行比较，如果比目标值小说明目标值位于数组中点右边，反之说明在数组中点左边。</p>
<p>2、由于是查找目标值在数组中的范围，所以我们可以用两种二分的方法，一种是将最终结果逐渐逼近数组较左边的目标值下标，另一种是逼近数组较右边目标值下标。（如下代码）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">            k = getInputArgs(line)[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="number">1</span>)&#123;</span><br><span class="line">            arr = getInputArgs(line)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            target = getInputArgs(line)[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">console</span>.log(fn(arr,target)[<span class="number">0</span>],fn(arr,target)[<span class="number">1</span>])</span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr,target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> r = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//第一次二分，返回较左的目标值下标</span></span><br><span class="line">    <span class="comment">//用1 2 2 3 3 4测试，最后返回下标3</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = r + l &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= target) r = mid <span class="comment">//这一步使得最后当几个数相等时，r会越来越小</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    left = arr[l] === target ? l : -<span class="number">1</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="comment">//第二次二分，返回较右的目标值下标</span></span><br><span class="line">    <span class="comment">//用1 2 2 3 3 4测试，最后返回下标4</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = r + l + <span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &lt;= target) l = mid <span class="comment">//这一步使得最后当几个数相等时，l会越来越大，因为上面mid与第一次二分不一样</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    right = arr[l] === target ? l : -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [left,right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6、高精度加法"><a href="#6、高精度加法" class="headerlink" title="6、高精度加法"></a>6、高精度加法</h3><p>给定两个正整数（不含前导 00），计算它们的和。</p>
<p><strong>输入格式</strong></p>
<p>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含所求的和。</p>
<p><strong>数据范围</strong></p>
<p>1≤整数长度≤1000001≤整数长度≤100000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>将两个数的每一位数依次存放进两个数组中，然后我们用这两个数组模拟两个数的竖式相加，就是小学学的列竖式。</p>
<p>由于相加是从个位数开始的，所以我们可以从个位数开始将数存进数组，这是为了方便计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> a,b,c = []</span><br><span class="line"><span class="keyword">let</span> d = <span class="string">&quot;&quot;</span></span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot;&quot;</span>).map(<span class="built_in">Number</span>).reverse()</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">           a = getInputArgs(line)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="number">1</span>)&#123;</span><br><span class="line">           b = getInputArgs(line)</span><br><span class="line">           add(a,b)</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">let</span> i = c.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">                d += c[i] + <span class="string">&quot;&quot;</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">console</span>.log(d)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; a.length || i &lt; b.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.length) t += a[i]</span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.length) t += b[i]</span><br><span class="line">        c.push(t % <span class="number">10</span>)</span><br><span class="line">        t = <span class="built_in">Math</span>.floor(t / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) c.push(t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7、高精度减法"><a href="#7、高精度减法" class="headerlink" title="7、高精度减法"></a>7、高精度减法</h3><p>给定两个正整数（不含前导 00），计算它们的差，计算结果可能为负数。</p>
<p><strong>输入格式</strong></p>
<p>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含所求的差。</p>
<p><strong>数据范围</strong></p>
<p>1≤整数长度≤1051≤整数长度≤105</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>同高精度减法~</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> a,b = []</span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x)).reverse()</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">0</span></span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m === <span class="number">0</span>)&#123;</span><br><span class="line">            a = getInputArgs(line)</span><br><span class="line">            m++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b = getInputArgs(line)</span><br><span class="line">            <span class="keyword">if</span>(cmp(a,b))&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(fn(a,b).reverse().join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;-&quot;</span> + fn(b,a).reverse().join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">             m --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = []</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; a.length || i &lt; b.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.length) t += a[i]</span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.length) t -= b[i]</span><br><span class="line">        c.push((t + <span class="number">10</span>) % <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span>( t &lt; <span class="number">0</span>) t =-<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.length &gt; <span class="number">1</span> &amp;&amp; c[c.length - <span class="number">1</span>] === <span class="number">0</span>) c.pop()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cmp</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length !== b.length) <span class="keyword">return</span> a.length &gt; b.length</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.length === b.length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = a.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] !== b[i]) <span class="keyword">return</span> a[i] &gt; b[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8、高精度乘法"><a href="#8、高精度乘法" class="headerlink" title="8、高精度乘法"></a>8、高精度乘法</h3><p>给定两个非负整数（不含前导 00） AA 和 BB，请你计算 A×BA×B 的值。</p>
<p><strong>输入格式</strong></p>
<p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含 A×BA×B 的值。</p>
<p><strong>数据范围</strong></p>
<p>1≤A的长度≤1000001≤A的长度≤100000,<br>0≤B≤100000≤B≤10000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> a,b = []</span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x)).reverse()</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">0</span></span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m ===<span class="number">0</span>)&#123;</span><br><span class="line">            a = getInputArgs(line)</span><br><span class="line">            m++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b = line.trim()</span><br><span class="line">            <span class="built_in">console</span>.log(fn(a,b).reverse().join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            m--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = []</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; a.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.length) t += a[i] * b</span><br><span class="line">        c.push(t % <span class="number">10</span>)</span><br><span class="line">        t = <span class="built_in">Math</span>.floor(t / <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) c.push(t)</span><br><span class="line">    <span class="keyword">while</span>(c.length &gt; <span class="number">1</span> &amp;&amp; c[c.length - <span class="number">1</span>] === <span class="number">0</span>) c.pop()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9、高精度除法"><a href="#9、高精度除法" class="headerlink" title="9、高精度除法"></a>9、高精度除法</h3><p>给定两个非负整数（不含前导 00） A，BA，B，请你计算 A/BA/B 的商和余数。</p>
<p><strong>输入格式</strong></p>
<p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p>
<p><strong>输出格式</strong></p>
<p>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p><strong>数据范围</strong></p>
<p>1≤A的长度≤1000001≤A的长度≤100000,<br>1≤B≤100001≤B≤10000,<br>BB 一定不为 00</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>由于除法与上面三个题的计算不一样，除法需要从最高位开始除，如果我们依然从各位数开始存数的话，那么就应该从数组最后一位从后往前计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> a,b = []</span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x)).reverse()</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">0</span></span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m === <span class="number">0</span>)&#123;</span><br><span class="line">            a = getInputArgs(line)</span><br><span class="line">            m++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b = line</span><br><span class="line">            fn(a,b)</span><br><span class="line">            m--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = []</span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = a.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        t = t * <span class="number">10</span> + a[i]</span><br><span class="line">        c.push(<span class="built_in">Math</span>.floor(t / b))</span><br><span class="line">        t = t % b</span><br><span class="line">    &#125;</span><br><span class="line">    c = c.reverse()</span><br><span class="line">    <span class="keyword">while</span>(c.length &gt; <span class="number">1</span> &amp;&amp; c[c.length - <span class="number">1</span>] === <span class="number">0</span>) c.pop()</span><br><span class="line">    <span class="built_in">console</span>.log(c.reverse().join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">    <span class="built_in">console</span>.log(t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10、前缀和"><a href="#10、前缀和" class="headerlink" title="10、前缀和"></a>10、前缀和</h3><p>输入一个长度为 nn 的整数序列。</p>
<p>接下来再输入 mm 个询问，每个询问输入一对 l,rl,r。</p>
<p>对于每个询问，输出原序列中从第 ll 个数到第 rr 个数的和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 nn 和 mm。</p>
<p>第二行包含 nn 个整数，表示整数数列。</p>
<p>接下来 mm 行，每行包含两个整数 ll 和 rr，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong></p>
<p>共 mm 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong></p>
<p>1≤l≤r≤n1≤l≤r≤n,<br>1≤n,m≤1000001≤n,m≤100000,<br>−1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>
<p>如果使用暴力算法，那么我们每一次查询都需要遍历数组然后计算对应范围的前缀和，然后相减，这太费劲了。如果我们一次性把数组所有下标的前缀和直接存放进一个数组，以后每一次查询都可以根据范围，直接从前缀和数组中查询出两个下标的前缀和然后相减即可。</p>
<p>*注意：由于数据范围是从1开始的，所以前缀和数组也需要从下标1开始存储，下标0存储0即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算前缀和公式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr,l,r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[r] - arr[l - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">process.stdin.on(<span class="string">&quot;readable&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunk = process.stdin.read()</span><br><span class="line">    <span class="keyword">if</span>(chunk) buf += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputArgs</span>(<span class="params">line</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> line.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">s</span> =&gt;</span> s !== <span class="string">&quot;&quot;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">parseInt</span>(x))</span><br><span class="line">&#125;</span><br><span class="line">process.stdin.on(<span class="string">&quot;end&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m,n = <span class="number">0</span></span><br><span class="line">    buf.split(<span class="string">&quot;\n&quot;</span>).forEach(<span class="function">(<span class="params">line,index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index === <span class="number">0</span>)&#123;</span><br><span class="line">            m = getInputArgs(line)[<span class="number">0</span>]</span><br><span class="line">            n = getInputArgs(line)[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index === <span class="number">1</span>)&#123;</span><br><span class="line">            arr = getInputArgs(line)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">                arr[i] += arr[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            arr.unshift(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">let</span> l = getInputArgs(line)[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">let</span> r = getInputArgs(line)[<span class="number">1</span>]</span><br><span class="line">                <span class="built_in">console</span>.log(fn(arr,l,r))</span><br><span class="line">            &#125;</span><br><span class="line">            n--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="11、子矩阵的和"><a href="#11、子矩阵的和" class="headerlink" title="11、子矩阵的和"></a>11、子矩阵的和</h3><p>输入一个 nn 行 mm 列的整数矩阵，再输入 qq 个询问，每个询问包含四个整数 x1,y1,x2,y2x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数 n，m，qn，m，q。</p>
<p>接下来 nn 行，每行包含 mm 个整数，表示整数矩阵。</p>
<p>接下来 qq 行，每行包含四个整数 x1,y1,x2,y2x1,y1,x2,y2，表示一组询问。</p>
<p><strong>输出格式</strong></p>
<p>共 qq 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong></p>
<p>1≤n,m≤10001≤n,m≤1000,<br>1≤q≤2000001≤q≤200000,<br>1≤x1≤x2≤n1≤x1≤x2≤n,<br>1≤y1≤y2≤m1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p><strong>题解：</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/10/%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/" data-id="cl0x9xz3f000etsughrytathe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/Vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Vue/" class="article-date">
  <time datetime="2021-11-20T12:43:46.915Z" itemprop="datePublished">2021-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Vue/">Vue篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>说说路由？</li>
</ul>
<p>路由route就是URL到函数的一个映射，router就是管理多个路由的一个容器，当接收到一个URL需要去路由映射表中查找相应的函数。</p>
<p>服务器端的路由就是当接收到客户端发来的HTTP请求时会根据请求的URL找到相对应的映射函数并执行，然后将返回值发送给客户端。</p>
<p>客户端路由通常就是进行一些DOM的显示与隐藏，当访问不同的路径时，会显示不同的页面组件，客户端实现路由有两种基本方式：</p>
<p>基于Hash：就是URL中#及其后面的部分为hash,hash仅仅是客户端的一个状态，当发送请求时hash部分不会发送出去</p>
<p>基于History API：就是在不刷新页面的情况下，直接改变当前URL，需要后端人员的支持</p>
<p>在Vue中路由的使用，第一步需要先安装vue-router，第二步就是使用该插件，然后在router配置项里编写路由的相关信息，最后指定路由展示位置实现切换。</p>
<ul>
<li>vue2响应式实现</li>
</ul>
<p>vue2采用数据劫持结合发布订阅模式，通过Object.defineproperty来劫持各个属性的setter和getter,在数据变动时发布消息给订阅者，触发响应的监听回调。</p>
<p>当创建Vue实例时，vue会遍历data的所有选项的属性，利用Object,defineproperty为属性添加getter和setter对数据的读取进行劫持，并且在内部追踪依赖，在属性被访问和修改时通知变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订阅器模型</span></span><br><span class="line"><span class="keyword">let</span> dingyue = &#123;</span><br><span class="line">	<span class="attr">container</span>: &#123;&#125;</span><br><span class="line">	<span class="comment">//订阅函数</span></span><br><span class="line">	<span class="attr">listen</span> : <span class="function"><span class="keyword">function</span>(<span class="params">key,fn</span>)</span>&#123;</span><br><span class="line">		(container[key] || (container[key] = [])).push(fn) </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//发布函数</span></span><br><span class="line">	<span class="attr">trigger</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!container[key])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> fns = container[key]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;fn;fn = fns[i++])&#123;</span><br><span class="line">            fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据劫持</span></span><br><span class="line"><span class="comment">//data是一个对象,datakey是键值，tag是标记</span></span><br><span class="line"><span class="keyword">let</span> dataHi = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;data,tag,datakey,selector&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">&quot;&quot;</span></span><br><span class="line">    el = <span class="built_in">document</span>.queryselector(selector)</span><br><span class="line">    <span class="built_in">Object</span>.defineproperty(data,datakey,&#123;</span><br><span class="line">        <span class="attr">get</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(“赋值”)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">setter</span> : <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        	value = val</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">&quot;改值&quot;</span>)</span><br><span class="line">        	dingyue.trigger(tag,val)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    dingyue.listen(tag,fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说说对Vue的理解：</li>
</ul>
<p>Vue是一个构建数据驱动的渐进性框架，它的目标是通过API实现响应数据绑定和视图的更新</p>
<ul>
<li>说说Vue的优缺点：</li>
</ul>
<p>优点：</p>
<p>1、数据驱动视图，对真实DOM进行抽象出虚拟DOM（本质就是一个js对象），并配合diff算法、响应式和观察者、异步队列等手段以最小的代价更新DOM，渲染页面</p>
<p>2、组件化，组件用单文件的形式进行代码的组织编写，使得我们可以在一个文件中编写html/css/js并且配合Vue-loader之后支持更强大的预处理器功能</p>
<p>3、强大且丰富的API提供一系列的api能满足业务开发中各类需求</p>
<p>4、生命周期构子函数，选项式的代码组织方式，</p>
<p>5、生态好，社区活跃</p>
<p>缺点：</p>
<p>1、由于底层是使用Object.defineProperty实现响应式，而这个api本身不支持IE8及以下浏览器</p>
<p>2、由于百度等引擎爬虫无法爬取js中的内容，故单页面应用先天就对seo优化不友好</p>
<ul>
<li>什么是虚拟DOM：</li>
</ul>
<p>虚拟DOM是相对于浏览器所渲染出来的真实DOM的，在React、vue等技术出现之前，我们要改变页面展示的内容只能通过遍历查询dom树的方式来找到需要修改的dom然后修改样式行为或结构，来达到更新ui的目的。</p>
<p>这种方式相当 消耗计算资源，因为每次查询几乎需要遍历整棵DOM树，如果建立一个与DOM树对应的虚拟DOM对象，以对象嵌套的方式表示DOM树，那么每次DOM的更改就变成了js对象属性的更改，这样一来查找js对象的属性变化要比查询DOM树性能开销小。</p>
<ul>
<li>简要概述Vue的生命周期：</li>
</ul>
<p>生命周期就是Vue从创建到销毁的过程，分为四大步，分别是创建、挂载、更新和销毁。每一步又分为两小步。</p>
<p>beforeCreate就是new Vue的时候会初始化事件和生命周期，beforeCreate和crated之间会挂载data，绑定事件；接下来会根据el挂载页面元素。el挂载结束后，根据template或outerHTML渲染页面；beforeMount前虚拟DOM已经创建完成，之后在mounted前，将vm.$el替换掉页面元素el，mounted将虚拟DOM挂载到真实页面，此时页面已经全部渲染完成，之后发生数据变化时触发beforeUpdate和updated进行进行一些操作；最后主动调用销毁函数或者组件自动销毁时beforeDestory，手动撤销监听事件，计时器等；destoryed时仅存在DOM节点，其他所有东西已经自动销毁。</p>
<ul>
<li>删除数组成员用delete和Vue.delete的区别：</li>
</ul>
<p>delete删除数组成员只是被删除的元素变为empty/undefined，其他元素键值不变</p>
<p>Vue.delete是直接删除数组元素，改变了数组的键值</p>
<ul>
<li>vue的nexttick：</li>
</ul>
<p>vue实现响应式并不是在数据变化之后DOM立即变化，而是等同一事件循环中的所有数据变化完成之后再同一进行视图更新。</p>
<p>vue的nexttick是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，可以获取更新后的DOM。</p>
<ul>
<li>vue和react的区别：</li>
</ul>
<p>原理上：vue是通过发布订阅模式加数据劫持监听值的变化，从而实现响应式的，vue是双向数据流，使用v-model这一语法糖即可轻松实现数据的双向绑定。react是需要依赖”onchange/setState”模式来实现数据的双向绑定，因为他是单向数据流。</p>
<p>模板渲染：react在JSX中使用原生的js语法实现插值，条件渲染，循环等。vue则需要依赖指令进行更容易上手，但封装程度更高，调试成本更大。</p>
<ul>
<li>计算属性（computed）和监听器（watch）的区别：</li>
</ul>
<p>计算属性：计算属性是一个函数，最后函数返回的结果就是计算属性得到的结果，当我们第一次使用计算属性时会执行计算属性并进行计算然后将结果缓存起来，当第二次使用插值表达式或其他方式使用该计算属性时，就会检查计算属性中用到的数据是否发生了变化，如果没有则在直接获取缓存中的值，有则重新计算然后进行缓存。计算属性的应用场景是计算的内容需要依赖多个属性的情况。</p>
<p>监听器：一个监听器对应data中的一个属性，当属性发生变化时触发监听器的执行。监听器的应用场景是计算的内容依赖一个属性的情况。</p>
<p>如果数据反复发生变化计算很多次的情况下使用计算属性的开销更大，适合使用监听器；当一个数据反复使用但是它依赖的内容很少发生变化时由于计算属性会缓存计算结果所以更加合适。</p>
<ul>
<li>vue2为什么直接对对象新增和删除属性监听不到：</li>
</ul>
<p>vue对对象属性实现响应式是只会对组件实例中data里面的对象通过遍历为每个属性用Object.defineProperty绑定getter和setter来实现属性数据的监听。</p>
<ul>
<li>vue的diff算法：</li>
</ul>
<p>虚拟DOM中不同的属性有唯一的key标识，当数据发生变化时，vue会根据新数据生成新的虚拟DOM，随后进行新旧虚拟DOM的对比：它会根据key值对比新旧虚拟DOM中的内容，如果不变则直接使用之前的真实DOM，如果改变则创建新的真实DOM然后渲染到页面中。</p>
<ul>
<li>实现浏览器多文件并发上传怎么设置，怎么批量上传</li>
</ul>
<p>使用elementUI默认是每保存一个文件就会立即向服务器发送上传请求，我们可以设置auto-upload来取消这个默认行为，设置limit可以控制最多上传文件个数，如果想要一次性上传多个文件可以将文件保存在一个数组中，然后发送一个请求。</p>
<ul>
<li>hash和history有哪些差异：</li>
</ul>
<p>hash模式会在url中携带#，#及其后面的内容就是hash，当我们发送http请求时hash是不会被包括在url中的，所以hash模式可以在前端很好的实现路由跳转，即使刷新页面也没事。</p>
<p>history模式利用了HTML5historyAPI新增的pushState()和replaceState()，这两个方法应用于浏览器的历史记录栈，提供对历史记录进行修改的功能。history模式下的url是不带#号的，所以当刷新页面时，会向服务器发送请求该url的页面，如果没有在后端设置响应的资源会出现 404的情况。</p>
<ul>
<li><p>父子组件如何进行通信：</p>
<p>父组件向子组件通信：</p>
</li>
</ul>
<p>1、通过props属性实现父组件向子组件通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">        &lt;child :data = &quot;fatherData&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import child from &quot;./child&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">			return &#123;</span><br><span class="line">                fatherData:&quot;我是父组件的数据&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;子组件&lt;/h2&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123;fatherData&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props:[&quot;fatherData&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2、使用$emit和$on传递父组件方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">        &lt;child @childevent = &quot;parentmethod&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import child from &quot;./child&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">			return &#123;</span><br><span class="line">                fatherData:&quot;我是父组件的数据&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            parentmethod()&#123;</span><br><span class="line">				alert(this.fatherData)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;子组件&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted:&#123;</span><br><span class="line">            this.$emit(&quot;childevent&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>3、通过$parent获取父组件然后使用父组件中的数据</p>
<p>4、vue依赖注入provide - inject实现子组件调用父组件的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//父组件提供provide，允许我们指定我们想要提供给后代组件的数据/方法</span><br><span class="line">    provide: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">       getMap: this.getMap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子组件使用 inject 选项来接收指定的我们想要添加在这个实例上的属性：</span><br><span class="line">    inject: [&#x27;getMap&#x27;]</span><br></pre></td></tr></table></figure>

<p>​    子组件向父组件通信：</p>
<p>1、使用$emit和$on</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;父组件&lt;/h2&gt;</span><br><span class="line">        &lt;child @childevent = &quot;parentmethod&quot;&gt;&lt;/child&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import child from &quot;./child&quot;</span><br><span class="line">    export default &#123;</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        data()&#123;</span><br><span class="line">			return &#123;</span><br><span class="line">                fatherData:&quot;我是父组件的数据&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            parentmethod(name)&#123;</span><br><span class="line">				alert(name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">    	&lt;h2&gt;子组件&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted:&#123;</span><br><span class="line">        	this.$emit(&quot;childevent&quot;,&quot;zehong&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>2、在子组件添加ref属性，通过ref属性获取到子组件，与$parent类似</p>
<p>补充：消息发布订阅（适用于任意组件间通信）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、安装pubsub</span><br><span class="line">2、在 main.js中引入</span><br><span class="line">3、在想接收数据的组件订阅消息，订阅的回调留在该组件中</span><br><span class="line">methods:&#123;</span><br><span class="line">	demo()&#123;</span><br><span class="line">		alert(&quot;你好&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted:&#123;</span><br><span class="line">	this.pid = pubsub.subscribe(&quot;xxx&quot;,this.demo)//订阅消息</span><br><span class="line">&#125;</span><br><span class="line">4、提供数据，在另一个组件进行发布</span><br><span class="line">pubsub.publish(&quot;xxx&quot;,数据)</span><br><span class="line">5、最好在beforeDestory周期中取消订阅</span><br><span class="line">Pubsub.unsubcribe(pid)</span><br></pre></td></tr></table></figure>

<p>全局事件总线（适用于任意组件间通信）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//全局事件总线本质上就是一个对象，所有的组件都能够找到他，可以使用$on与$emit绑定与触发事件 </span><br><span class="line">//在mian.js中设置全局事件总线，在new Vue()的时候实例化了一个Vue实例对象，为了所有组件可以找到全局事件总线，将这个对象放在vue原型上</span><br><span class="line">new Vue(&#123;</span><br><span class="line">	beforeCreate()&#123;</span><br><span class="line">		Vue.prototype.$bus = this</span><br><span class="line">	&#125;,</span><br><span class="line">	el:&quot;root&quot;,</span><br><span class="line">	render:h =&gt; h(App)</span><br><span class="line">&#125;)</span><br><span class="line">使用this.$bus.on(&quot;xxx&quot;,method)绑定事件</span><br><span class="line">使用this.$bus.emit(&quot;xxx&quot;,data)触发事件传递数据</span><br></pre></td></tr></table></figure>

<ul>
<li>拥抱vue3：</li>
</ul>
<p>1、性能的提升，使用vite打包文件更小，初次渲染更快，更新更快，内存使用减少</p>
<p>2、更好的ts支持，可以在命令行直接配置</p>
<p>3、新增加proxyAPI可以对对象新增属性进行监听，proxy是真正意义上给对象包上一层代理从而去完成数据监听劫持的操作，总体来说复杂度比vue2是减少一个数量级的。只要对这个代理对象访问或修改都会被代理监听到进而动态决定返回什么东西，并且也不再需要把选项的东西重复挂载到组件实例的this上，因为访问的时候可以知道你访问的东西时属于props还是data还是其他的，vue只要根据这个信息去对应的数据结构中拿出来即可，所以会减少组件的内存。</p>
<ul>
<li>vite和webpack的比较：</li>
</ul>
<p>vite特性：轻量；按需打包；HMR（热渲染更新）</p>
<p>webpack在启动时需要先build一遍，而这个过程是将所有模块提前编译、打包进bundle里，会消耗很多时间，而vite在启动时内部直接启动了web server，并不会编译所有的代码文件，它的打包原理是基于es新特性Dynamic imports实现的，而且在编译ts文件时引用ESbuild通过go对ts语言的支持编译速度比tsc还快几十倍。</p>
<ul>
<li>说说ES6的proxy：</li>
</ul>
<p>proxy是代理器的意思，proxy在目标对象外层搭建了一层拦截，外界对目标对象的某些操作必须通过这层拦截。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line"><span class="comment">//target是要拦截的对象，若为空对象则对proxy的操作直通目标对象；handler是一个对象来定制拦截行为</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="comment">//Reflect.get相当于读取对象中的属性</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">    <span class="comment">//Reflect.set相当于在对象上设置一个属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>对vue3中set up函数的理解：</li>
</ul>
<p>set up是为了使用组合式API,组件中所有用到的数据方法都要配置在set up中，set up返回的对象中所有的属性和方法在模板中都可以直接使用。在set up中定义响应式数据可以使用ref函数，定义一个对象类型的响应式数据可以使用reactive函数，ref函数底层是Object.defineProperty，reactive函数底层是proxy</p>
<ul>
<li>说说vue的mixin：</li>
</ul>
<p>mixin本质是一个js对象，他可以包含我们组件中任意功能选项，比如data，methods等，组件可以使用mixins对象将mixin选项混入到该组件本身的选项中，实现代码复用。当组件选项与mixin对象发生冲突时会覆盖mixin选项，如果相同 选项为生命周期函数时会合并为一个数组，先执行mixin的函数再执行组件的。</p>
<ul>
<li>详细说说vue2的响应式原理：</li>
</ul>
<p>当执行new Vue时，vue就进入了初始化阶段，vue会对指令进行解析（初始化视图，增加订阅者、绑定更新函数），同时通过Observe遍历数据，对每一个属性是对象的添加<code>__ob__</code>，它是一个observer类，通过递归以及Object.defineProperty的getter与setter实现对多层数据，包括数组的监听。在observer实例中，都会有一个dep实例对象，它使用发布订阅的模式。当数据发生变化时，Observer中的setter方法会被触发，会调用Dep.notify()，循环依赖列表通知所有的watcher，并调用watcher的update方法，通过回调函数通知视图进行更新。（多看源码）</p>
<p>对于数组的监听，vue是对数组的七个方法，即push/pop/shift/unshift/splice/reverse/sort进行了改写，通过在observer实例对象与Array.prototype之间的原型链上添加了一个新的对象，然后在该对象中对数组方法进行了改写，让数组通过这七个方法的增删后的数组也可以被监听到。</p>
<ul>
<li>理清Vue响应式系统中的Watcher和Dep的关系：</li>
</ul>
<p>Dep何时创建：初始化时给data的属性进行数据劫持时创建的</p>
<p>Dep有几个：与data中的属性一一对应</p>
<p>Dep结构是什么：id标识、subs存放watcher的容器</p>
<p>Watcher何时创建：初始化解析大括号表达式/一般指令时创建</p>
<p>Watcher有几个：与模板表达式一一对应</p>
<p><strong>Dep与watcher是多对多的关系</strong>：</p>
<p>一个data属性对应一个Dep，一个Dep可能对应n个watcher（属性多次在模板中被使用）</p>
<p>一个表达式对应一个Watcher，一个watcher可能对应n个Dep（多层表达式，如a.b.c）</p>
<ul>
<li>v-router传参方式:</li>
</ul>
<p>1、使用router的name属性也就是params来传递参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先在router的index.js中配置每个路由的路径，name属性</span></span><br><span class="line"><span class="keyword">export</span> router = <span class="keyword">new</span> routerMap (&#123;</span><br><span class="line">    <span class="attr">routes</span>:[&#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;./about&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>:About,</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&quot;about&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在传值页面写法：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;about&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">userId</span>:<span class="string">&quot;110&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在取值页面写法：</span></span><br><span class="line"><span class="built_in">this</span>.$route.params.userId</span><br></pre></td></tr></table></figure>

<p>2、通过query传参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在传值页面写法：</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;about&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">        <span class="attr">userId</span>:<span class="string">&quot;110&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在取值页面的写法：</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="built_in">this</span>.router.currentRoute.query.userId</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="built_in">this</span>.route.query.userId</span><br></pre></td></tr></table></figure>

<p>3、使用vue里的<code>&lt;router-link&gt;</code>标签来传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在传值页面呢</span><br><span class="line">&lt;router-link target=&quot;about&quot; :to=&quot;&#123;path:&#x27;/about&#x27;,query:&#123;userId:&#x27;33333&#x27;&#125;&#125;&quot;&gt;&lt;/router-link&gt;</span><br><span class="line">//在取值页面与第二种方法一样</span><br><span class="line">//当路由携带params参数时，若使用to的对象写法必须使用name配置项</span><br></pre></td></tr></table></figure>

<ul>
<li>说说路由守卫：</li>
</ul>
<p>路由守卫主要用来通过跳转或取消的方式对路由进行权限控制</p>
<p>全局守卫：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//全局前置守卫，初始化执行，每次路由切换执行</span><br><span class="line">//使用router.beforeEach注册一个全局前置守卫</span><br><span class="line">router.beforeEach((to,from,next) =&gt; &#123;</span><br><span class="line">	//to是即将进入的目标，from是当前导航要离开的路由，next是放行</span><br><span class="line">&#125;)</span><br><span class="line">//全局后置守卫，初始化执行，每次路由切换后执行</span><br><span class="line">//使用router.afterEach注册一个全局后置守卫</span><br></pre></td></tr></table></figure>

<p>独享守卫（只对特定的路由起作用）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//直接在路由配置上定义beforeEnter守卫</span><br><span class="line">const routes = [&#123;</span><br><span class="line">	path:...,</span><br><span class="line">	component:...,</span><br><span class="line">	beforeEnter:(to,from,next) =&gt; &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>组件内守卫：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//进入守卫：在渲染该组件的对应路由时被调用</span><br><span class="line">//不能获取到组件实例this，因为在守卫执行之前组件实例还没有被创建</span><br><span class="line">//可以通过next获取data中的数据</span><br><span class="line">beforeRouteEnter(to,from,next)&#123;</span><br><span class="line">&#125;</span><br><span class="line">//离开守卫：通过路由规则，离开该组件时被调用,通常用来预防用户在还没保存修改前突然离开，可以通过next(false)来取消</span><br><span class="line">//可以访问组件实例this</span><br><span class="line">beforeRouteLeave(to,from,next)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>说说vue的diff算法：</li>
</ul>
<p>vue的diff算法是一种通过同层的树节点进行比较的高效算法，作用于虚拟DOM渲染为真实DOM的新旧节点比较。</p>
<p><strong>diff算法的主要特点有：</strong></p>
<p>diff会对key值相同的虚拟DOM节点进行比较，每一个虚拟的DOM节点都有一个唯一的key值；</p>
<p>只有key值相同且选择器相同的虚拟DOM节点才会进行精细化比较；</p>
<p>diff算法只进行同层比较，不会跨层比较。</p>
<p>diff算法底层是通过四种命中查找的优化策略，即①新前节点与新后节点，②新后节点与旧后节点，③新后节点与旧前节点，④新前节点与旧后节点，当一种查找不满足之后会继续下一种查找，如果找到则中断该节点查找，进行相应的处理，例如更新索引值或者通过patch函数让虚拟节点上树。如果四个策略都不满足，会循环查找。当开始索引值大于结束索引值时，也会终止查找策略，根据新旧索引情况判定是删除旧节点还是新增新节点。</p>
<ul>
<li>vuex与vue的关系以及vuex的使用：</li>
</ul>
<p>vuex是vue开发提供的状态管理工具，在一个项目只能够频发使用组件传参的方式来同步data的值，一旦项目比较庞大，数据管理与维护是一个棘手的问题。vuex就是一个统一的管理数据的工具，只要把数据存放在里面即可在vue组件中使用。</p>
<p><strong>vuex安装：</strong></p>
<p>1、使用npm安装vuex</p>
<p>2、在项目根目录下新建一个store文件夹在文件夹中新建一个index.js</p>
<p>3、初始化index.js中的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;</span><br><span class="line">import Vuex from &quot;vuex&quot;</span><br><span class="line"></span><br><span class="line">//挂载vuex</span><br><span class="line">Vue.use(vuex)</span><br><span class="line"></span><br><span class="line">//创建vue对象</span><br><span class="line">const store = new Vuex.store(&#123;</span><br><span class="line">	state:&#123;</span><br><span class="line">		//存放的值是要管理的状态</span><br><span class="line">		name:&quot;nihao&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	mutations:&#123;</span><br><span class="line">		//用来修改state和getters中的数据</span><br><span class="line">	&#125;,</span><br><span class="line">	getters:&#123;</span><br><span class="line">		//相当于计算属性</span><br><span class="line">	&#125;,</span><br><span class="line">	actions:&#123;</span><br><span class="line">		//用于发起异步请求</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default store</span><br></pre></td></tr></table></figure>

<p>4、将store挂载到当前项目vue实例中，在main.js配置</p>
<p><strong>vuex的使用：</strong></p>
<p>在任意组件中，可以使用this.$store.state.属性名来获取数据，在模块中使用。</p>
<p>在组件中修改state使用mutations,通过this.$store.commit(“mutation事件名”,参数)可以修改state中的数据。</p>
<p>在getters中进一步对state中的数据进行加工得到新数据，通过return返回新数据。</p>
<p>在vuex中使用actions发送异步请求，在组件中通过this.$store.dispatch(“actions的名字”,参数)来调用actions中的方法，使用commit调用mutations来修改state，而不是直接变更状态。</p>
<p>当项目越来越大，vuex中的数据越来越多，可以在modules中对数据进行分配，让不同的组件共享特定的state。</p>
<p>可以使用mapState将state中的数据映射到组件内部的计算属性中，使用…mapState()对对象进行展开运算，整体上是对象的合并。</p>
<ul>
<li>为什么vue-if与vue-for不能放在一起使用：</li>
</ul>
<p>因为vue-for的优先级比vue-if高，放在一起使用意味着每一个循环都会运行一次vue-if，消耗性能。</p>
<p>解决方案：</p>
<p>1、在外部包裹一个template标签使用vue-if，这样就可以先执行vue-if再执行vue-for。</p>
<p>2、不使用vue-if，使用计算属性对需要循环遍历的列表或数组进行过滤得到想要的元素。</p>
<ul>
<li>为什么vue组件中的data必须是函数而不能是对象：</li>
</ul>
<p>如果使用对象来声明数据的话，会让不同组件的data数据其实是同一个引用地址，会产生数据污染。而使用函数对数据进行声明，因为函数返回的对象内存地址并不相同所以不会出现数据污染。</p>
<p>在组件根实例对象data可以是对象或函数，但是在组件实例对象中data必须是函数。</p>
<ul>
<li>vue的组件与插件有什么不同：</li>
</ul>
<p>组件：就是把各种逻辑抽象成一个统一的组价来实现开发的模式，在vue中每一个.vue后缀的文件可以视为一个组件。使用组件可以降低系统的耦合度，我们可以通过替换不同组件来实现不同的需求；组件也方便我们调试，在出现bug的时候可以通过移除组件的方式来判断问题所在；同时组件还可以提高项目的可维护性，由于组件在系统中是被复用的，所以对组件代码的优化可以获得系统的整体升级。</p>
<p>组件的编写一般就是vue单文件的形式，我们在文件中进行组件代码的编写，然后通过Vue.component进行全局注册或者在需要用到的地方进行局部注册即可。</p>
<p>插件：插件通常用来添加全局功能，有添加全局方法或属性（<code>Vue.全局方法 = function()&#123;&#125;</code>）、添加全局资源（<code>Vue.directive(&quot;方法名&quot;,&#123;bind(el,binding,vnode,oldVnode)&#123;&#125;&#125;)</code>）、通过全局混入添加组件选项（<code>Vue.mixin(&#123;created:function()&#123;&#125;&#125;)</code>）、添加Vue实例方法（<code>Vue.prototype.$方法名 = function()&#123;&#125;</code>）等实现插件功能。</p>
<p>插件的编写需要新建一个js文件并在里面暴露一个install方法，在方法里面进行插件代码的编写，然后通过Vue.use()方法对插件进行注册即可。</p>
<ul>
<li>说说vue的插槽：</li>
</ul>
<p>vue的插槽就是如果在项目中有一个会被重复使用到的组件，但是这个组件在不同的地方会有少量的更改，此时如果我们重写组件实际上是很不明智的。所以可以使用slot元素在组件中进行占位，然后可以在不同的组件中自定义插槽中的内容，实现对组件的复用比如一些布局组件。</p>
<p>插槽分为默认插槽、具名插槽与作用域插槽，具名插槽相对于默认插槽，可以通过name属性来表示不同的插槽，然后在父组件中为不同的插槽填写不同的内容；作用域插槽就是子组件可以通过将自身数据作为slot标签的一个元素传递给父组件，然后在父元素中使用v-slot获取然后使用<code>&#123;&#123;&#125;&#125;</code>进行调用。（注：v-slot只能在template标签上使用）</p>
<ul>
<li>了解过Vue.observable吗，说说看：</li>
</ul>
<p>当我们需要在非父子组件中进行通信时，如果实现的功能并不复杂，由于全局事件总线与vuex比较繁琐，所以可以使用observerable来实现。observerable是可观察的意思，它可以让一个对象变为响应式数据，我们可以通过新建一个js文件，通过Vue.observable方法创建一个state对象来存储需要进行共享的数据，然后在mutations对象中可以创建对应的方法，最后直接在vue文件中引入就可以直接使用了。</p>
<ul>
<li>用的比较多的element 组件：</li>
</ul>
<p>el-button按钮、el-input输入框、el-upload上传、el-form表单、el-breadcrumb面包屑</p>
<ul>
<li>说说vue的模板引擎：</li>
</ul>
<p>模板引擎就是让数据变为视图的解决方案。vue在实现模板引擎中引入了mustache库，在这之前实现数据变为视图的方法有：纯DOM（手动根据data创建dom节点和对应赋值）、join方法（将模板HTML字符串每一行都写在数组中，数据进行相对应的填充，最后利用join方法生成HTML）、es6模板字符串（join的升级版，由于可以换行直接写在反引号中，用$填充数据最后遍历生成HTML）。</p>
<p>mustache库使用render函数根据模板字符串和数据生成相对应的HTML，实现的原来是将传入的模板字符串转成tokens，结合传入的data生成填充数据渲染后的HTML字符串。tokens是反映模板字符串结构和内容的数组，它的分割是基于双大括号，里面的内容为name类型，值为key，外面的字符串内容都为text，值就是字符串；当双大括号里面是#array数组时，会被解析成#类型，这时候会开辟索引2，存放tokens数组，知道遇到双大括号里面是<code>/array</code>会被解析成/类型，值为数组索引。</p>
<p>具体实现步骤：</p>
<p>1、Scanner类：一个扫描器类，用于扫描将指定字符串，最后生成tokens</p>
<p>2、tokens数组的折叠：使用到栈结构sections以及收集器collector，对token类型是#的token进行折叠。</p>
<p>3、tokens与data结合生成HTML：对tokens数组的每一项类型检查，如果为text则直接加进HTMLStr中，如果为name类型将数据值加进HTMLStr中，如果是#类型，则使用递归思想将这一项的子项tokens和封装了<code>.</code>属性的子对象传入参数中，最后返回整个HTMLStr。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/Vue/" data-id="cl0x9xz3z000rtsugcgi7267m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/TensorFlow-js/">TensorFlow.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">大三上日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">大三寒假日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">网站介绍</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%8B%E7%BB%8D/" rel="tag">介绍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;">介绍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/">手写系列</a>
          </li>
        
          <li>
            <a href="/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          </li>
        
          <li>
            <a href="/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/">node.js</a>
          </li>
        
          <li>
            <a href="/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/">webpack基础</a>
          </li>
        
          <li>
            <a href="/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/">项目相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 ChenZehong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>