<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>大三下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="大三下">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="大三下">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="ChenZehong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="大三下" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">大三下</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试准备/计网" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%A1%E7%BD%91/" class="article-date">
  <time datetime="2021-11-20T12:43:32.637Z" itemprop="datePublished">2021-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%A1%E7%BD%91/">计算机网络篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>知道哪些计算机网络模型？OSI 和 TCP/IP</li>
</ul>
<p>OSI模型一共有七层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<p>TCP/IP模型有五层：应用层（HTTP协议、DNS协议、FTP协议）、传输层（TCP协议、UDP协议）、网络层（IP协议）、数据链路层、物理层</p>
<ul>
<li>TCP协议与UDP协议的区别：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/26468b56ce599668.png"></p>
<ul>
<li>为什么UDP有时候比TCP有优势：</li>
</ul>
<p>UDP以其简单、传输快的优势，在越来越多的场景下取代了TCP如实时游戏</p>
<p>1、网速的提升给UDP 的稳定性提供了可靠的网络保障，丢包率很低，如果使用应用层重传，能够保证传输的可靠性</p>
<p>2、TCP为了实现网络通信的可靠性使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于是在TCP内置的系统协议栈中，所以极难对其进行改进。</p>
<p>采用TCP一旦发生丢包会将后续的包缓存起来，等前面的包重传并接收后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下采用自定义重传机制能够把丢包产生的延迟降低到最低，尽量减少网络问题对游戏造成影响。</p>
<ul>
<li>UDP协议为什么不可靠：</li>
</ul>
<p>1、不保证信息交付：不确认、不重传、无超时</p>
<p>2、不保证交付顺序：不设置包序号，不重排，不会发生队首堵塞</p>
<p>3、不跟踪连接状态：不必建立连接或重启状态机</p>
<p>4、不进行拥塞控制：不内置客户端或网络反馈机制</p>
<ul>
<li>TCP三次握手：</li>
</ul>
<p>浏览器先向服务器发送一个SYN包以及seq序列号，然后服务器接收到SYN包后也向浏览器发送一个SYN包以及ACK确认应答（seq+1），然后浏览器接收到服务器发来的包后再向服务器发送一个确认应答ACK（服务器seq+1），此包发送完毕后客户端与服务器连接成功，三次握手结束。</p>
<ul>
<li>泛洪攻击：</li>
</ul>
<p>在三次握手中当服务器发送SYN-ACK包给客户端之后，可能不会接收到客户端回应的ACK包，这个就是半开放连接，服务器需要消耗一定数量的系统内存来等待这个连接。攻击者通过创建很多的半开放连接来发动泛洪攻击。</p>
<ul>
<li>TCP四次挥手：</li>
</ul>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放报文首部FIN=1，序列号seq等于前面传送过来的数据最后一个字节的序号+1，此时客户端进入终止等待状态1。</li>
<li>服务器收到连接释放报文后发出确认应答ACK，并且带上自己的序列号，然后服务器进入等待关闭状态</li>
<li>客户端收到服务器的确认应答后客户端进入终止等待状态2，等待服务器发送连接释放报文</li>
<li>服务器将最后的数据发送完毕后向客户端发送连接释放报文，此时服务器进入最后确认状态，等待客户端的确认</li>
<li>客户端收到服务器的连接释放报文后向服务器发送确认应答，此时客户端进入时间等待状态，等待一段时间后才进入关闭状态</li>
<li>服务器收到客户端的确认 应答后立即进入关闭状态，服务器结束TCP连接的时间要比客户端早一些</li>
</ol>
<ul>
<li>为什么需要四次挥手：</li>
</ul>
<p>因为当服务器接收到客户端的连接释放报文后需要发送确认应答ACK与FIN包，但是由于服务器接收到报文之后还有数据需要传输，所以先发送一个确认应答，等到数据全部发送完了才能够发送FIN报文。（FIN报文是终结连接请求）</p>
<ul>
<li>TCP如何实现可靠性：</li>
</ul>
<p>TCP通过序列号（报文所发送的数据的第一个字节的序号）、检验和、确认应答信号（期望收到对方的下一个报文段的数据的第一个字节的序号）、重发控制、连接管理、窗口控制、流量控制。拥塞控制实现可靠性。</p>
<ul>
<li>TCP的重传机制（针对数据包丢失或者定时器超时）：</li>
</ul>
<p>由于TCP的下层网络层可能出现丢失、重复或者失序的情况，为保证数据传输的正确性，TCP会重传认为已丢失的包。TCP在发送一个数据之后会开启一个定时器，若是在这个时间内没有收到发送数据的确认应答，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。TCP使用两套独立的机制来完成重传，一个是基于时间，一个是基于确认信息。</p>
<p>超时重传（RTO）：超时重传时间应该略大于报文往返的RRT值。实际上RTO是经常变化的，因为我们的网络也是经常变化的。</p>
<p>快速重传：不以时间为驱动，而是以数据为驱动重传。快速重传的工作方式就是当收到三个相同的ACK报文时吗，会在定时器过期之前，重传丢失的报文。为了解决是重传之前的一个还是重传所有的问题，于是有了SACK方法。</p>
<p>选择性确认（SACK）：这种方式只需要在TCP头部字段中加一个SACK的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据接收到了，然后重传丢失的数据。</p>
<p>D-SACK：可以让发送方知道是发出去的包丢了哈市接收方回应的ACK包丢了，还可以知道是不是发送方的数据包被网络延迟了；还可以知道网络中是不是把发送方的数据包复制了。</p>
<ul>
<li>TCP协议的流量控制（针对避免网络拥堵）：</li>
</ul>
<p>流量控制就是为了让发送方发送数据的速度不要太快，TCP采用大小可变的滑动窗口进行流量控制。</p>
<p>当一个连接建立时，连接的每一端会分配一个缓冲区来保存输入的数据并将缓冲区的大小发送给另一端；当数据到达时接收方发送确认其中包含自己剩余的缓冲区大小（即自己的接收窗口大小rwnd）。如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告；如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口，发送方收到一个零窗口通告的时候必须停止发送，直到接收方重新通告一个正的窗口。但有两种情况除外，一个是可以发送紧急数据；一个是发送方可以发送一个1字节的数据包来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<ul>
<li>接收窗口与拥塞窗口的区别：</li>
</ul>
<p>接收窗口由接收方管理，接收方将窗口大小发送给发送方，窗口大小表示接收方缓冲区仍然空闲的字节数。拥塞窗口是发送方强加的窗口，它的实现是为了避免网络路径中间的一些路由器溢出，拥塞窗口是发送方允许自己发送更多未完成的数据而出现，当发送方检测到数据丢失时对将窗口切成两半，背后的原理是发送方假设数据包丢失是因为某个地方的缓冲区溢出而发生的，因此发送方希望保持较少的数据“在运行中”，以避免将来进一步包的丢失。</p>
<ul>
<li>TCP的拥塞控制（避免刚开始启动时避免一下子发送大量数据导致网络瘫痪）：</li>
</ul>
<p>TCP的拥塞控制算法包含了：慢启动，拥塞避免，快速重传，快速恢复</p>
<p>慢启动：开始的时候不要发送大量数据，先测试一下网络的拥塞程度，由小到大增加拥塞窗口（cwnd）的大小。为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限（sssthresh）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当cwnd&lt;sssthresh时，使用慢开始算法</span><br><span class="line">当cwnd=sssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法</span><br><span class="line">当cwnd》sssthresh时，使用拥塞避免算法</span><br></pre></td></tr></table></figure>

<p>拥塞避免：让拥塞窗口缓慢的增大，每经过一个返回时间RRT就把发送方的拥塞控制窗口加一。无论是慢开始阶段还是拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为拥塞时发送窗口大小的一半，然后拥塞窗口设置为1，执行慢开始算法。</p>
<p>快速重传：要求接收方在收到一个失序的报文段后就立即发出重复确认，发送方只要一连续收到三个重复的确认应发就立即重传对方尚未收到的报文段，而不必等待设置的重传计时器时间到期。</p>
<p>快速恢复：当发送方连续收到三个重复确认就执行乘法减小算法，将门限减半，然后接下去并不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<ul>
<li>TCP的停止等待协议：</li>
</ul>
<p>停止等待协议是为了实现可靠传输的，它的原理是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。每个分组发送完会开启一个超时计时器，如果超时则自动重传数据，这种重传方式叫做自动重传请求ARQ。在停止等待协议中若收到重复分组就丢弃该分组，但同时还要再发送确认。连续ARQ协议可提高信道利用率，发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一把采用累积确认，对按序到达的最后一个分组发送确认，表明这个分组位置的所有分组都已经正确收到了。</p>
<p><strong>确认丢失和确认迟到：</strong></p>
<p>1、确认丢失：确认信息在传输过程中丢失。</p>
<p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>
<p>丢弃这个重复的M1消息，不向上层交付；</p>
<p>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</p>
<p>2、确认迟到 ：确认消息在传输过程中迟到</p>
<p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>
<p>A收到重复的确认后，直接丢弃。</p>
<p>B收到重复的M1后，也直接丢弃重复的M1。</p>
<ul>
<li>为什么四次握手发送最后一次报文之后需要等待2MSL的时间：</li>
</ul>
<p>1、为了保证A发送的最后一个确认报文能够到达B，如果A不等待2MSL，若A返回的最后确认报文段丢失，则B不能进入正常状态，而此时A已经关闭，不能再重传。</p>
<p>2、防止出现“已失效的连接请求报文段”，在A发送完最后一个确认报文段后再经过2MSL可保证本连接持续的时间内所产生的所有报文从网络中消失。</p>
<ul>
<li>为什么超时事件发生时cwnd设置为1，而受到三个重复的ACK时cwnd只是减半：</li>
</ul>
<p>超时事件发生时网络拥塞更严重，说明网络可能已经拥塞得连ACK报文都传输不了了；而受到三个重复的ACK时，虽然网络拥塞但是至少ACK报文能被正确交付，网路拥塞相对不是很严重。</p>
<ul>
<li>是否TCP和UDP都需要计算往返时间RRT：</li>
</ul>
<p>TCP需要根据RRT来动态设置超时计时器的超时时间，UDP没有确认和重传机制，因此RRT对UDP没有什么意义。</p>
<ul>
<li>为什么TCP在建立连接时不能每次都选择相同的、固定的序列号：</li>
</ul>
<p>1、假如A和B频繁的建立连接，传送一些TCP报文段后再释放连接，然后又不断建立新的连接，传送报文段和释放连接；</p>
<p>2、假如每一次建立连接时主机A都选择相同的固定的初始序号1</p>
<p>3、若主机A发送出的某些TCP报文在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段</p>
<p>4、若有一些网络中滞留较久的TCP报文最后终于到达了主机B，但这是传送该报文段的连接早已释放了，而在此时到达主机B的TCP连接时一条新的连接</p>
<p>以上情况可能会导致在新的TCP连接中的主机B有可能会接收在旧的连接传送的已经没有意义的过时的TCP报文段（因为这个TCP报文段的序号有可能正好处于新的链接所使用的序号范围内）。因此必须使得迟到的TCP报文段中的序号不在新的连接中使用的序号范围内。不同的TCP连接不能使用相同的初始序号。</p>
<ul>
<li>在使用TCP传输数据时如果有一个确认报文段丢失了，也不一定会引起与该确认报文段相对应的数据的重传：</li>
</ul>
<p>因为发送方可能还未重传时就收到了更高序号的确认。例如主机A连续发送两个报文段，均正确到达主机B。B连续发送两个确认ACK1和ACK2(ACK2的序号比ACK1的序号高)。但前一个确认帧在传输时丢失了。若在超时前，ACK2被A接收，更高的序号代表该序号之前的所有字节都被接收了，所以A知道前一个报文也被正确的接收了，这种情况下A不会重传第一个报文段。</p>
<ul>
<li>Cookie Session Token的原理</li>
</ul>
<p>cookie的原理：</p>
<ol>
<li>客户端第一次发送请求时发送数据到服务器</li>
<li>服务器返回响应消息的同时传回一个cookie</li>
<li>客户端接收到服务器的响应后将cookie存放在一个统一的地方</li>
<li>客户端再次向服务器发送请求时会把cookie写进请求头然后发给服务器</li>
</ol>
<p>session的原理：</p>
<ol>
<li>服务器在处理客户端请求过程中会创建session，并为session生成一个唯一的ID</li>
<li>服务器将sessionID发送给客户端</li>
<li>当客户端再次发送请求时会带上这个sessionID</li>
<li>服务器接收到请求之后会根据ID找到相对应的session，完成请求</li>
</ol>
<p>token的原理：</p>
<ol>
<li>客户端第一次请求时，发送用户信息到服务器，服务器对用户信息使用加密算法和密钥进行签名，再将这个签名和数据一起作为token返回给客户端</li>
<li>服务端不再保存token，客户端保存token</li>
<li>当客户端再次发送请求时在请求信息中将token一起发送给服务器</li>
<li>服务器使用相同的加密算法和密钥对数据再进行一次签名，和token的签名作比较</li>
<li>如果相同则知道客户端登录过</li>
</ol>
<ul>
<li>跨域：</li>
</ul>
<p>同源：指域名、协议、端口相同</p>
<p>跨域就是指浏览器不能执行其他网站的脚本，是浏览器对Javascript实施的安全限制。之所以有同源策略是浏览器对于用户安全的考虑，会导致Cookie、LocalStorage无法读取，DOM和JS对象无法获取、Ajax请求发送不出去。</p>
<p>解决跨域的方法：</p>
<p>1、jsonp是利用script脚本不受同源策略的限制</p>
<p>2、CORS（跨域资源共享）</p>
<p>当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头origin;后端在接收到请求确定响应后会在响应头加上Access-Control-Allow-Origin。浏览器判断响应中的Access-Control-Allow-Origin与当前地址值是否相同，匹配成功则继续相应处理，否则报错。</p>
<p>需要浏览器和服务器的支持，浏览器在发送请求时在请求头中添加origin字段，然后在服务器里面配置Access-Control-Allow-Origin，服务器接收到请求时会根据origin字段在Access-Control-Allow-Origin查找，如果有则允许跨域，没有则不允许。</p>
<p>3、代理跨域请求</p>
<p>前端发送请求经过代理，请求需要的服务器资源</p>
<p>4、HTML5 postMessage方法</p>
<p>允许来自不同源的脚本采用异步方式进行有限的通信</p>
<p>5、基于HTML5的websocket协议</p>
<p>基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求</p>
<ul>
<li>HTTP缓存：</li>
</ul>
<p>有效减少网络请求的体积和数量</p>
<p>强缓存：在第一次请求返回的响应头中添加cache-control，设置max-age有效时间，这样当发送下一次请求时如果在有效期内则直接在缓存中获取资源。</p>
<p>协商缓存：服务器端缓存策略，在第一次发送请求的响应头中加入资源标识，如果第二次请求发现资源并没有修改过则返回304状态码直接从缓存中获取资源。如果资源已经修改则返回200状态码和最新的资源以及最新的资源标识。资源标识有last-modified和etag，last-modified对应需要在第二次请求的请求中中添加if-modified-since；etag对应需要在第二次请求的请求中中添加if-none-match。</p>
<p>etag优先级更高，因为last-modified只能精确到秒，而且文件如果隔一段时间重复生成即使内容相同last-modified会每次返回资源文件，而etag可以判断内容相同则返回304从缓存中获取资源。</p>
<ul>
<li>js事件循环：</li>
</ul>
<p>浏览器由很多模块组成，有解析html和css的模块，有解析js的模块，有定时器模块，有ajax模块。</p>
<p>宏任务：script标签中的整体代码、setTimeout、setInterval、I/O、UI渲染</p>
<p>微任务：process.nextTick、Promise、MutationObserver</p>
<p>事件循环：一开始整个脚本作为一个宏任务执行，执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列。当前宏任务执行完毕后立即执行微任务队列中的所有微任务。当前宏任务执行完毕开始检查渲染，然后GUI线程接管渲染（浏览器会在两个宏任务交接期间，对页面进行重新渲染）。渲染完毕后JS线程继续接管，开始下一个宏任务，依此循环，直到宏任务与微任务队列都为空。</p>
<ul>
<li>GET 和 POST 的区别：</li>
</ul>
<p>GET是通过URl传递参数，post是通过请求体传递参数</p>
<p>GET请求在url中是有长度限制的，而post没有</p>
<p>get比post不安全，因为参数是直接暴露在url中的，所以不能传递敏感信息</p>
<p>get是一个幂等的请求不会产生对服务器资源产生影响，post不是一个幂等的请求一般用以对服务器资源产生影响的情景，如注册用户</p>
<p>get请求参数会被完整地保留在浏览器的历史记录里，而post不会</p>
<ul>
<li>post请求与put请求的区别：</li>
</ul>
<p>put请求是向服务器端发送数据，从而修改数据的内容，但是不会更新数据的种类，可以理解为更新数据</p>
<p>post请求是向服务器发送数据，该请求会改变数据的种类等资源，它会创建新的内容。</p>
<ul>
<li>常见http请求头：</li>
</ul>
<p>Accept：浏览器可处理的内容类型</p>
<p>Accept-Charset：浏览器能够显示的字符集</p>
<p>Accept-Encoding：浏览器能够处理的压缩编码</p>
<p>Connection：浏览器与服务器之间连接的类型</p>
<p>Cookie：当前页面设置的任何Cookie</p>
<p>Host：发出请求页面所在的域</p>
<p>Referer：发出请求的页面的URL</p>
<p>User-Agent：浏览器的用户代理字符串</p>
<ul>
<li>常见http响应头：</li>
</ul>
<p>Date：发送消息的时间</p>
<p>server：服务器名称</p>
<p>Cache-Control：控制http缓存</p>
<p>content-type：表示后面的文档属于什么MIME类型</p>
<ul>
<li>http码是304多好还是不好？</li>
</ul>
<p>304是协商缓存中服务器向客户端返回，允许客户端调用缓存内容的状态码，它不是一种错误。</p>
<p>但是当304状态码多了之后，搜 索引擎蜘蛛可能会降低对网站的抓取次数，相反如果每次抓取都能获取新内容，回访率也会增加。</p>
<ul>
<li>options的主要用途：</li>
</ul>
<p>获取服务器支持的所有http请求方法</p>
<p>用来检查访问权限，例如在进行CORS进行跨域资源共享时，对于复杂请求就是使用options方法发送嗅探请求，以判断是否有对指定资源的访问权限</p>
<ul>
<li>http1.0与http1.1之间的区别：</li>
</ul>
<p>连接方面：1.0使用非持久连接，1.1使用持久长连接，支持多个http请求使用同一个tcp连接</p>
<p>资源请求方面：1.0中当客户端需要某个对象的一部分，服务器只能一整个对象，而1.1中引入range允许只请求资源的某个部分，返回码是206</p>
<p>缓存方面：1.0主要使用If-Modified-Since、Expries来作为缓存判断的标准，1.1则引入了Etag、if-Undified-Since、If-Match、If-None-Match等更多缓存头来控制缓存策略</p>
<p>1.1新增了host字用来指定服务器的域名，同时新增了许多请求方法，如PUT、HEAD等</p>
<ul>
<li>1.1与2.0的区别：</li>
</ul>
<p><strong>二进制分帧</strong>：流式连接中的一个虚拟信道，可以承载双向消息传输，每个流有唯一整数标识符，为了防止两端流ID冲突，客户端发起的流具有奇数ID。服务器发起的流具有偶数ID一个独立的双向的帧存在于客户端和服务器之间的http2连接中。一个http2连接上可以包含多个并发打开的流，这个并发的数量由客户端设置。在二进制分帧层上http2会将所有传输信息分割为更小的消息或帧，并对他们采用二进制格式的编码进行封装。</p>
<p><strong>多路复用</strong>：多路复用允许同时通过一个单一的http2连接发起多重的请求-响应消息，有了新的分帧机制后，http2可以不再依赖多个TCP连接。每个数据流都拆分为很多互不依赖的帧，而这些帧可以交错，还可以分优先级发送，最后在另一端重新组合。</p>
<p><strong>头部压缩</strong>：由于1.1协议不带状态，每次请求都必须附上全部信息，所以请求的很多字段都是重复的，这既浪费带宽也影响速度。http2使用encoder来减少需要传输的请求头大小，通讯双方各自缓存一份头部字段表，既避免了重复请求头的传输，也减小了需要传输的大小。对于相同的数据，不再需要每次请求和响应发送，通信期间几乎不会改变通用键值对。如果首部发生了变化则只需将变化的部分加入到请求头中，改变的部分会加入到头部字段表中。</p>
<p><strong>请求优先级</strong>：把http消息分为很多独立帧之后可以通过优化这些帧的交错与传输顺序进一步优化性能，每个流可以带有优先值。服务器根据流的优先级控制资源分配，而在响应数据准备好之后优先将最高优先级的帧发送给客户端。一般html文件优先级最高，css文件次之，之后是js文件等资源。</p>
<p><strong>服务端推送</strong>：服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确的请求，服务器能把客户端需要的资源伴随着index.html一起发送给客户端。这种服务器推送的是基于客户端的请求响应确定的。</p>
<ul>
<li>http协议与https协议的区别：</li>
</ul>
<p>https协议需要ca证书，费用较高，而http协议不需要</p>
<p>http协议是超文本传输协议，信息是明文传输；https协议是具有安全性的ssl加密传输协议</p>
<p>使用不同的连接方式，端口也不同，http协议是80端口，https协议是443</p>
<p>http协议连接时无状态的，https协议是有ssl和http协议构建的可进行加密传输 、身份认证的网络协议，更加安全</p>
<ul>
<li>对keep-alive的理解：</li>
</ul>
<p>keep-alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，可以避免建立或者重新建立连接，这就会长连接</p>
<p>1.0默认是没有keep-alive的要想连接得到保持需要手动配置connection:keep-allive字段，关闭则发送connection:close字段</p>
<p>1.1规定了默认保持长连接</p>
<ul>
<li>keep-alive的建立过程：</li>
</ul>
<ol>
<li>客户端向服务器在发送请求报文同时在首部添加connection字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送connection:keep-alive字段给客户端</li>
<li>客户端收到connection字段</li>
<li>keep-alive建立成功 </li>
</ol>
<ul>
<li>开启keep-alive的优点：</li>
</ul>
<p>较少的CPU和内存的使用（由于同时打开的连接少了）</p>
<p>允许请求和应答的http管线化</p>
<p>降低拥塞控制（tcp连接少了）</p>
<p>减少了后续请求的延迟（无需再进行握手）</p>
<ul>
<li>缺点：</li>
</ul>
<p>长时间的连接容易导致系统资源无效占用，浪费系统资源</p>
<ul>
<li>http状态码：</li>
</ul>
<p>2开头：请求成功处理（200：请求成功处理，一般用于get与post请求；201：已创建，成功请求并创建了新的资源；202：已接受，已经接受请求但是未处理成功；204：成功处理请求但是无内容返回）</p>
<p>3开头：重定向相关（301：永久性重定向，返回信息会包括新的url，浏览器会自动定向到新的url；302：暂时性重定向；304：协商缓存时返回的状态码，当允许从本地读取缓存时返回）</p>
<p>4开头：客户端错误（400：客户端请求的语法错误，服务器无法理解；401：请求要求用户的身份认证；403：服务端理解用户客户端请求但是拒绝执行；404：服务器无法根据客户端请求找到资源）</p>
<p>5开头：服务端错误（500：服务器不支持请求的功能，无法完成请求；505：服务器不支持此请求http版本，无法完成处理）</p>
<ul>
<li>同样是重定向，307,302,303的区别：</li>
</ul>
<p>302是http1.0的状态码，在http1.1版本中为了细化302状态码多出了303与307。303表示客户端应当采用get方法获取资源，它会把post请求变为get请求进行重定向；307表示遵照浏览器标准，不会从post变为get方法。</p>
<ul>
<li>JS数据为什么分别存在栈和堆：</li>
</ul>
<p>在JS中栈是用来存储基本类型数据的，如boolean、number、string等，这些数据类型在栈内存中分别占有固定大小的空间，我们通过值来对数据进行访问，基本数据类型在当前执行环境结束时就会在栈中销毁；由于引用类型大小不固定所以不能保存在栈中，所以使用堆来对引用数据类型进行保存，而在栈中保存这些引用类型的地址，这样当查询引用数据类型的变量时就会先从栈中读取内存地址然后再去堆中找到相应的值。堆中的数据是不会对执行环境结束而销毁的，只有当所有引用它的变量不存在时这个对象才会被回收机制回收。</p>
<ul>
<li>如何设置httponly：</li>
</ul>
<p>在服务器返回响应头的cookie中添加http only属性为true</p>
<ul>
<li>浏览器渲染过程：</li>
</ul>
<p>1、根据HTML构建DOM树</p>
<p>2、根据CSS构建stylesheet</p>
<p>3、将DOM树与stylesheet合并为渲染树</p>
<p>4、根据渲染树来布局，以计算每个节点的几何信息</p>
<p>5、将各个节点绘制到屏幕上</p>
<ul>
<li>在浏览器输入baidu.com并且按下回车之后发生了什么：</li>
</ul>
<p>1、解析url：首先对url进行解析，分析所需要的传输协议和请求的资源路径，如果输入的url中的协议或者主机名不合法将会把地址栏输入的内容传递给搜索引擎。如果没问题就会检查url中是否出现了非法字符，如果存在非法字符则对非法字符进行转义后再进行下一过程。</p>
<p>2、缓存判断：浏览器会判断所请求的资源是否在缓存里，如果在缓存里并且没有失效，就直接使用，否则向服务器发起新的请求。</p>
<p>3、DNS解析：下一步首先需要获取输入的url的域名的ip地址，首先会先判断浏览器是否有该域名的ip地址的缓存，如果有则使用，没有则继续所搜操作系统的DNS缓存，如果没有再向本地DNS服务器发起请求。本地的服务器会先检查是否存在缓存，没有就会向根域名服务器发起请求，获得负责的顶级域名服务器的地址后再向顶级域名服务器发起请求，然后获得负责的权威域名服务器地址后再向权威域名服务器发起请求最终获得域名的IP地址，本地DNS服务器再将这个ip地址返回给请求的用户。</p>
<p>4、获得MAC地址：当浏览器得到ip地址后，数据传输还需要知道目的主机MAC地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的ip地址作为目的地址然后下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，本机的MAC作为源MAC地址，目的MAC地址需要分情况处理。通过将IP地址与本机的子网掩码相比较可以判断是否与请求主机在同一子网中，如果在同一子网中可以使用APR协议获取到目的主机的MAC地址，如果不在一个子网中那么请求应该转发给网关，由它代为转发，此时同样可以通过APR协议来获取网关的Mac地址，此时目的主机的MAC地址应该为网关的地址</p>
<p>5、TCP三次握手：首先客户端向服务器发送一个SYN连接请求报文段和一个随机序列号，服务器接收到请求后向客户端发送一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收到确认应答后进入连接建立状态，同时向服务器发送一个ACK确认报文段，服务器接收到确认后，也进入连接建立状态，此时双方连接就建立起来了</p>
<p>6、https握手：如果使用的是https协议，在通信前还存在一个TLS的四次握手过程。首先客户端向服务器发送使用协议的版本号、一个随机数和可以使用的加密方法。服务器接收到之后确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端接收到之后首先检查数字证书是否有效，如果有效则再生成一个随机数并使用证书中的公钥对随机数加密，然后发送给服务器，并且还会提供一个前面所有内容的hash值给服务器进行检验。服务器接收后使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的hash值给客户端检验，这个时候双方都有了三个随机数，按照之前所约定的加密方法使用这三个随机数生成一把密钥以后双方通信前就使用这个密钥对数据进行加密后再传输</p>
<p>7、返回数据：当页面请求发送到服务器后，服务器会返回一个html文件作为响应，浏览器接收到响应后开始对文件进行解析，开始页面的渲染过程</p>
<p>8、页面渲染：浏览器首先会根据html文件构建DOM树，根据解析到的css文件构建 CSSOM树，如果遇到script标签则判断是否含有defer或者async属性，不然script标签的加载和执行会造成页面的渲染的阻塞。当DOM数和CSSOM树建立好之后根据他们来构建渲染树。渲染树构建好之后会根据渲染树进行布局。布局完成后最后使用浏览器的ui接口对页面进行绘制，这个时候页面就显示出来了。</p>
<p>9、TCP四次挥手：最后一步是TCP断开连接的四次挥手过程。若客户端认为数据发送完毕需要向服务器发送连接释放请求，服务器收到连接释放请求后会告诉应用层要释放TCP连接，然后发送ACK包，并进入CLOSE_WAIT状态，此时表明客户端到服务器的连接已经释放不再接受客户端发来的数据。因为TCP连接是双向的所以服务器仍旧可以发送数据给客户端。服务器如果此时还有没发完的数据会继续发送完毕后向客户端发送释放连接请求，然后服务器进入LAST-ACK状态，客户端收到释放请求后向服务器发送确认应答，此时客户端进入TIME-WAIT状态，该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间超时会被抛弃）时间。若时间段内没有服务器的重发请求的话就进入CLOSED状态，当服务器收到确认应答后也进入CLOSED状态。</p>
<ul>
<li>页面中有多张图片，http是怎样加载的：</li>
</ul>
<p>在http1下，浏览器对一个域名下最大TCP连接数是6，可以使用多域名部署解决，这样可以提高同时请求的数目，加快页面图片的获取速度</p>
<p>在http2下，可以一瞬间加载出来很多资源因为http2支持多路复用，可以在一个TCP连接中发送多个http请求</p>
<ul>
<li>http2的头部压缩算法是怎样的：</li>
</ul>
<p>http2的头部压缩算法是HPCK算法，在客户端与服务器两端建立字典，用索引表示重复的字符串，采用哈弗曼编码来压缩整数和字符串可以达到50%~90%的压缩率</p>
<p>具体来说：</p>
<p>在客户端与服务器使用首部表来跟踪和存储之前发送的键值对，对于相同的数据不再通过每次请求和响应发送</p>
<p>首部表在http2的连接存续期内始终存在，由客户端与服务器共同渐近的更新</p>
<p>每个新的首部键值要么被追加到当前表的末尾要么替换表中之前的值</p>
<ul>
<li>说一下http3.0：</li>
</ul>
<p>http2的多路复用在丢包场景下会出现队头堵塞问题。http3采用UDP作为传输层协议重新实现了无需连接，并在此基础上通过有序的QUIC Stream提供了多路复用。</p>
<p>http3是基于udp协议实现类似于tcp的多路复用数据流，传输可靠等功能，这套功能被称为QUIC协议</p>
<p>1、流量控制。传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制以及其他tcp中的特性。</p>
<p>2、集成TCP加密功能：目前QUIC使用TLS1.3减少了握手所花费的RTT数</p>
<p>3、多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头堵塞问题</p>
<p>4、快速握手：由于基于UDP可以实现使用0~1个RRT来建立连接</p>
<ul>
<li>队头堵塞：</li>
</ul>
<p>http传输的报文必须是一发一收，但是里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会堵塞后面的请求的处理，这就是队头堵塞</p>
<p>队头阻塞的解决方案：</p>
<p>1、并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其他所有任务</p>
<p>2、域名分片：将域名分出很多二级域名，他们都指向同样的一台服务器，能够并发的长连接数量变多，解决了队头堵塞的问题</p>
<ul>
<li>TLS/SSL的工作原理：</li>
</ul>
<p>TLS/SSL称为安全传输层协议，是介于TCP与HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能主要依赖三类基本算法：散列函数hash、对称加密和非对称加密，作用如下：</p>
<p>基于散列函数验证信息的完整性；对称加密算法采用协商的密钥对数据加密；非对称加密实现身份认证和密钥加密</p>
<p>散列函数：常见的散列函数有MD5、SHA1、SHA256，该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以防止信息篡改并验证信息的完整性。</p>
<p>对称加密：对称加密的方法是双方使用同一个密钥对数据进行加密和解密，但是对称加密的一个问题就是如何保证密钥传输的安全性，因为密钥还是会通过网络传输，一旦密钥被其他人获取到，那么整个加密过程就毫无作用了，这就要用到非对称加密</p>
<p>非对称加密：我们拥有两个密钥一个是私钥一个是公钥，公钥是公开的，私钥是保密的，用私钥加密的数据只有对应的公钥才能解密，用公钥加密的数据只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户都可以使用我们提供的公钥对数据进行加密然后我们使用私钥进行解密，这样就能保证数据的安全了。掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信。但是有一个缺点就是加密的过程很慢。</p>
<p>TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的密钥，对称加密算法采用协商密钥对信息以及信息摘要进行加密通信。</p>
<ul>
<li>数字证书是什么：</li>
</ul>
<p>因为没有办法确定得到的公钥就一定是安全的，可能存在一个中间人，截取了对方发给我们的公钥然后将它自己的公钥发送给我们，当我们使用它的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后伪装成我们以同样的方法向对方发送信息这样我们的信息就被窃取了。为了解决这个问题可以使用数字证书。</p>
<p>首先使用一种hash算法对公钥和其他信息进行加密，生成一个消息摘要，然后让有公信力的认证中心（CA）用它的私钥对消息摘要进行加密形成签名，最后将原始信息与签名合成在一起，称之为数字证书。当接收方接收到证书时，先根据原始信息使用同样的hash算法生成一个摘要，然后使用公证处的公钥对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>一般浏览器会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<ul>
<li>https的通信过程（握手过程）：</li>
</ul>
<p>1、客户端向服务器发起请求，请求中包含使用的协议版本号，生成的一个随机数，以及客户端支持的加密方法</p>
<p>2、服务器接收到请求后，确认双方使用的加密方法，并给出服务器的证书，以及一个服务器生成的随机数</p>
<p>3、客户端确认服务器的证书有效后，生成一个新的随机数，并使用数字证书中的公钥加密这个随机数，然后发给服务器，并且还会提供一个前面所有内容的hash值，用来供服务器检验</p>
<p>4、服务器使用自己的私钥，来解密客户端发送过来的随机数，并提供前面所有内容的hash值来供客户端检验</p>
<p>5、客户端和服务器根据自己约定的加密方法使用前面三个随机数，生成对话密钥，以后的对话过程都使用这个密钥进行加密信息。</p>
<ul>
<li>DNS协议是什么：</li>
</ul>
<p>DNS是域名系统，提供一种主机名到IP地址的转换服务，它是由一个分层的DNS服务器组成的 分布式数据库，定义了主机如何查询这个分布式数据库的方式的应用层协议。</p>
<p>作用：将域名解析为IP地址，客户端向DNS服务器发送域名查询请求，DNS服务器告知客户端服务器的IP地址。</p>
<ul>
<li>DNS同时使用TCP与UDP协议：</li>
</ul>
<p>1、在区域传输的时候使用TCP协议：辅域名服务器会定时向主域名服务器查询以便了解数据是否有变动，如有变动会执行一次区域传送，进行数据同步。TCP是一种可靠连接，保证了数据的准确性。</p>
<p>2、在域名解析的时候使用UDP协议：客户端向DNS服务器查询域名，一般返回的内容不超过512字节，用UDP协议传送即可。因为不用经过三次握手所以响应DNS服务器负载更低，响应更快。</p>
<ul>
<li>DNS完整的查询过程：</li>
</ul>
<p>1、首先会在浏览器缓存中查找对应的IP地址，找到则返回，否则进入下一步</p>
<p>2、将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，找到则返回，否则进入下一步</p>
<p>3、本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</p>
<p>4、本地DNS服务器向顶级域名服务器发送请求，接收请求的服务器查询自己的缓存，如果有记录则返回查询结果，否则返回 相关的下一级的权威服务器的地址</p>
<p>5、本地DNS服务器向权威服务器发送请求，域名服务器返回对应的结果</p>
<p>6、本地DNS服务器将返回的结果保存在缓存中便于下次使用 </p>
<p>7、本地DNS服务器将返回结果返回给浏览器、、</p>
<ul>
<li>DNS解析是包含递归查询与迭代查询的过程：</li>
</ul>
<p>递归查询：查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果，使用递归查询用户只需要发出一次查询请求</p>
<p>迭代查询：查询请求后，域名服务器返回单次查询的结果，下一级查询由用户自己请求，使用迭代查询用户需要发起多次的查询请求</p>
<p>一般我们向本地DNS服务器发送请求的方式是递归查询，而本地服务器向其他域名服务器请求的过程是迭代请求的过程。</p>
<ul>
<li>说说常见的content-type：</li>
</ul>
<p><em>text/html：html格式</em></p>
<p><em>text/plain：纯文本格式</em></p>
<p><em>image/gif：gif格式</em></p>
<p><em>application/json：json数据格式</em></p>
<p><em>application/pdf：pdf数据格式</em></p>
<p><em>application/msword：word文档格式</em></p>
<p><em>application/octet-stream：二进制流格式</em></p>
<p><em>application/x-www-form-urlencoded：表单的默认提交数据格式，将键值对的参数使用&amp;连接起来，如果有空格则转换为+号，如有特殊字符则进行转义。</em></p>
<p><em>mulitipart/form-data：需要在表单中进行二进制文件上传时，需要使用该格式，也可用于键值对参数，最后连接成一串字符传输。</em></p>
<ul>
<li>URL有哪些组成部分：</li>
</ul>
<p>协议部分、域名部分、端口部分、虚拟目录部分、文件名部分、参数部分（从？到#之间的部分都是参数部分，参数之间用&amp;作为分隔符）、锚部分（从#开始到最后都是锚部分）。</p>
<ul>
<li>HTTPS的特点：</li>
</ul>
<p><strong>优点：</strong></p>
<p>1、可以认证用户和服务器，确保数据发送到正确的客户端和服务器</p>
<p>2、可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取，修改，保证数据的安全性</p>
<p>3、不是绝对安全的但是大幅增加了中间人攻击的成本</p>
<p><strong>缺点：</strong></p>
<p>1、需要做服务器与客户端双方的加密解密处理，耗费更多的服务器资源，过程复杂</p>
<p>2、握手阶段比较费时，增加页面加载时间</p>
<p>3、SSL证书是收费的，功能越强大的证书费用越高</p>
<p>4、连接服务器资源占用高很多，支持访客稍多的网站需要投入更多的成本</p>
<p>5、需要绑定IP，不能在同一个IP绑定多个域名</p>
<ul>
<li>说一说什么是大端、小端，如何判断大端和小端 </li>
</ul>
<p>1、字节序</p>
<p><strong>字节顺序</strong>，又称<strong>端序</strong>或<strong>尾序</strong>（英语：<strong>Endianness</strong>）。在计算机科学计算机科学”)领域中，是跨越多字节的程序对象的存储规则。<br>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为int的变量x地址为0x100，那么其对应地址表达式&amp;x的值为0x100。且x的四个字节将被存储在存储器的0x100, 0x101, 0x102, 0x103位置。</p>
<p>2、大小端</p>
<p>在计算机中一般讲字节序分为两类：Big-Endian（大端字节序） 和Little-Endian。<br>a) Little-Endian 高位字节在前，低位字节在后。<br>b) Big-Endian 低位字节在前，高位字节在后。<br>c) 网络字节序：TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。</p>
<ul>
<li>XSS攻击是什么？</li>
</ul>
<p>XSS是跨站脚本攻击(Cross Site Scripting)，攻击者可以通过向Web页面里面插入script代码，当用户浏览这个页面时，就会运行被插入的script代码，达到攻击者的目的。XSS的危害一般是泄露用户的登录信息cookie，攻击者可以通过cookie绕过登录步骤直接进入站点。XSS的分类分为反射型和存储型。反射型需要欺骗用户去点击才能触发XSS代码。存储型就是将恶意代码以留言的形式保存在服务器数据库，任何访问网站的人都会受到攻击。</p>
<p>一切用户可控并且能够输出在页面代码中的地方都可能出现XSS漏洞，比如评论区、留言区等。</p>
<p><strong>预防</strong>：对用户输入进行过滤，对输出进行html编码。也就是对用户提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉导致脚本执行的相关内容，然后对动态输出到页面的内容进行html编码使脚本无法在浏览器中执行。还可以在服务端设置会话cookie的http only属性，这样客户端的JS脚本就不能获取到cookie信息了 。</p>
<ul>
<li>说说CSRF：</li>
</ul>
<p>CSRF是跨站请求伪造，可以在用户毫不知情的情况下以用户的名义伪造请求发送给攻击站点，从而在未授权的情况下进行权限保护内的操作，比如以用户的名义发送邮件，购买商品等。</p>
<p><strong>预防</strong>：</p>
<p>同源检测：验证http Referer字段，http头中的字段Referer中记录了http请求的来源地址，可以通过对每一个请求验证其Referer值，如果是其他网站则拒绝请求；</p>
<p>随机数一致性检测：令牌同步模式：CSRF token：用户登录后生成随机的token值，用户提交的操作类请求中，提交的表单中携带CSRF token值，服务器判断CSRF token值是否正确。</p>
<ul>
<li>XSS攻击与CSRF攻击的区别：</li>
</ul>
<p>CSRF不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击；</p>
<p>CSRF攻击成本比XSS低。</p>
<ul>
<li>合法的IPv4 或 IPv6 地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 合法的IPv4:</span><br><span class="line">1.1 .分割为4组</span><br><span class="line">1.2 每组不为空</span><br><span class="line">1.3 每组长度 &lt;= 3</span><br><span class="line">1.4 每组在0~255之间</span><br><span class="line">1.5 每组不包含前导0, 除非本身为0</span><br><span class="line">/^[1-9]\d&#123;0,2&#125;$/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2. 合法的IPv6:</span><br><span class="line">2.1 : 分割为8组</span><br><span class="line">2.2 每组不为空</span><br><span class="line">2.3 每组长度 &lt;=4</span><br><span class="line">2.4 每组为一个16进制数: 即字符范围为: 0~9, a~f, A~F</span><br><span class="line">/^[0-9a-fA-F]&#123;1,4&#125;$/</span><br></pre></td></tr></table></figure>

<ul>
<li>说一说进程通信的方式有哪些？</li>
</ul>
<p>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：</p>
<ol>
<li><p>管道</p>
<p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。</p>
</li>
<li><p>命名管道</p>
<p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
</li>
<li><p>信号</p>
<p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>消息队列</p>
<p>消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。</p>
</li>
<li><p>共享内存</p>
<p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
</li>
<li><p>内存映射</p>
<p>内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。</p>
</li>
<li><p>信号量</p>
<p>信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。</p>
</li>
<li><p>Socket</p>
<p>套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</p>
</li>
</ol>
<ul>
<li>UDP(用户数据报协议)是什么？</li>
</ul>
<p>UDP是OSI参考模型中的传输层协议，是一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p>
<p>UDP协议有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说UDP协议不能得知报文是否安全完成到达，由于UDP协议只负责将应用程序给IP层的数据报发送出去，不用在客户端与服务器之间建立连接且没有超时重发等机制，所以UDP协议的传输速度很快。</p>
<p>绝大部分UDP应用都不需要可靠机制，甚至可能因为引入可靠机制降低性能，比如流媒体、即时多媒体游戏等应用。如果一个应用需要很高的可靠性可以选择TCP协议。</p>
<ul>
<li>进程与线程</li>
</ul>
<p>进程是操作系统资源分配的基本单位；线程是进程的一个执行单元，是处理器任务调度和执行的基本单位。</p>
<p>线程共享本进程的地址空间和资源，但进程之间是独立的地址空间；</p>
<p>在一个进程中一个线程奔溃会导致整个进程都死掉，但是多进程中一个进程奔溃不会影响其他进程；</p>
<p>每个独立的进程有程序运行的入口、执行顺序和程序出口；但线程是依存在应用程序中的，由应用程序提供多个线程执行控制，两者均可并发执行。</p>
<ul>
<li>线程切换为什么比进程切换容易？</li>
</ul>
<p>操作系统需要保存进程运行所需要的所有状态信息，也就是进程的上下文。在任何时刻，单处理器系统只能执行一个进程，所以当操作系统将控制权从一个进程切换到另一个进程时，需要保存原先进程的上下文，并恢复新进程的上下文，然后将控制权传递给新进程。</p>
<p>但是对线程而言，进程内的所有线程共享进程的虚拟地址空间，在线程进行切换时不会涉及虚拟地址空间的切换。</p>
<ul>
<li>计算机的原码、反码、补码</li>
</ul>
<p>原码就是符号位加上真值的绝对值</p>
<p>反码的话，正数的反码是它本身，负数的反码就是符号位不变，其余各个位取反</p>
<p>补码的话，正数的补码是它本身，负数的补码就是符号位不变，其余各个位取反，最后+1</p>
<ul>
<li>请描述一下cookies,sessionStorage和localStorage的区别：</li>
</ul>
<p>sessionStorage 和 localStorage 是HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p>
<p>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面，sessionStorage 对象也是不同的。</p>
<p>由于webstorage容易受到xss攻击，所以不建议在其中保存比较敏感的信息，避免xss攻击可能通过提前对保存进webstorage中的数据进行加密，以及在读取数据后对数据进行编码、转义。</p>
<p>cookies会发送到服务器端。其余两个不会。</p>
<ul>
<li><p>Cookie</p>
<ul>
<li>每个域名存储量比较小（各浏览器不同，大致4K）</li>
<li>所有域名的存储量有限制（各浏览器不同，大致4K）</li>
<li>有个数限制（各浏览器不同）</li>
<li>会随请求发送到服务器</li>
</ul>
</li>
<li><p>LocalStorage</p>
<ul>
<li>永久存储</li>
<li>Localstorage可以跨窗口与选项卡共享</li>
<li>单个域名存储量比较大（推荐5MB，各浏览器不同）</li>
<li>总体数量无限制</li>
</ul>
</li>
<li><p>SessionStorage</p>
<ul>
<li>只在 Session 内有效</li>
<li>Sessionstorage可以跨窗口与选项卡共享</li>
<li>存储量更大（推荐没有限制，但是实际上各浏览器也不同）</li>
</ul>
</li>
<li><p>如果要保存的cookie数据大于4k，又不想保存在webstorage中怎么办：</p>
</li>
</ul>
<p>可以对cookie数据进行压缩，将cookie中多个键值对看成文本，用文本压缩的方式进行压缩，可以使用gzip或者deflate算法，由于cookie中key,value必须是ascii字符，不能是Unicode字符，所以需要将压缩后的数据进行base64或者base32编码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E8%AE%A1%E7%BD%91/" data-id="cl0x9xz7c001ltsugfx6wdfuu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JavaScript/" class="article-date">
  <time datetime="2021-11-20T12:43:23.515Z" itemprop="datePublished">2021-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JavaScript/">JavaScript篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>判断数组的五种方法：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(arr,<span class="built_in">Array</span>.prototype))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(arr) === <span class="built_in">Array</span>.prototype)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>null 和 undefined 的差异：</li>
</ul>
<ol>
<li><ul>
<li>null 转为数字类型值为 0,而 undefined 转为数字类型为 NaN(Not a Number) </li>
<li>undefined 是代表调用一个值而该值却没有赋值,这时候默认则为 undefined </li>
<li>null 是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象) </li>
<li>设置为 null 的变量或者对象会被内存收集器回收</li>
</ul>
</li>
<li><ul>
<li>==、===与Object.is()的区别：</li>
</ul>
</li>
<li><ul>
<li>==：等同，比较运算符，两边值类型不同的时候，先进行类型转换，再比较；</li>
<li>===：恒等，严格比较运算符，不做类型转换，类型不同就是不等；</li>
</ul>
</li>
<li><p><code>Object.is()</code>与===差不多，主要区别是：</p>
</li>
<li><ul>
<li>+0 不等于-0。</li>
<li>NaN 等于自身。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>isNaN 和 Number.isNaN 函数的区别：</li>
</ul>
<ol>
<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 </li>
<li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="string">&quot;nihao&quot;</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">true</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;nihao&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;true&quot;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>什么是 JavaScript 中的包装类型？</li>
</ul>
<p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象。可以使用<strong>valueOf</strong>方法将包装类型倒转成基本类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虽然传入的值为boolean类型，但是false被包裹为包装类型后就成了对象，所以if语句不会运行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let、const、var的区别：</li>
</ul>
<p>（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li><input disabled="" type="checkbox"> 内层变量可能覆盖外层变量 </li>
<li><input disabled="" type="checkbox"> 用来计数的循环变量泄露为全局变量 </li>
</ul>
<p>（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。<br>（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br>（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。<br>（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。<br>（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。<br>（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<p><img src="D:\个人文件\学习课件\大物\09649105ECF8457104E1D23CB4E533C0.png"></p>
<p><strong>暂时性死区</strong>：ES6 新增的 let、const 关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建之前被创建出来，由于此时还未完成语法绑定，如果我们访问或使用该变量，就会产生暂时性死区的问题，由此我们可以得知，从变量的创建到语法绑定之间这一段空间，我们就可以理解为‘暂时性死区’。</p>
<ul>
<li>箭头函数：</li>
</ul>
<ol>
<li>箭头函数没有 arguments </li>
<li>箭头函数没有 prototype 属性，不能用作构造函数 </li>
<li>箭头函数没有自己 this，它的 this 是词法的，引用的是上下文的 this，即在你写这行代码的时候就箭头函数的 this 就已经和外层执行上下文的 this 绑定了。箭头函数的 this 指向即使使用 call,apply,bind 也无法改变（这里也验证了为什么 ECMAScript 规定不能使用箭头函数作为构造函数，因为它的 this 已经确定好了无法改变）</li>
</ol>
<ul>
<li>for…of跟for…in的区别：</li>
</ul>
<p>for … of 是作为 ES6 新增的遍历方式,允许遍历一个含有 iterator 接口的数据结构并且返回各项的值 。</p>
<p><strong>ES 中的 for … in 的区别如下</strong></p>
<p> 1、for … of 只能用在可迭代对象上,获取的是迭代器返回的 value 值,for … in 可以获取所有对象的键名</p>
<p> 2、for … in 会遍历对象的整个原型链,性能非常差不推荐使用,而 for … of 只遍历当前对象不会遍历它的原型链</p>
<p> 3、对于数组的遍历,for … in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for … of 只返回数组的下标对应的属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> iterator <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(iterator)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//1 2 3 4 5 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(arr, key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key)</span><br><span class="line">        <span class="built_in">console</span>.log(arr[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 </span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JS 为什么放到后面，CSS 会阻塞渲染吗：</li>
</ul>
<h4 id="为什么外链-css-为什么要放头部？"><a href="#为什么外链-css-为什么要放头部？" class="headerlink" title="为什么外链 css 为什么要放头部？"></a>为什么外链 css 为什么要放头部？</h4><p>首先整个页面展示给用户会经过 html 的解析与渲染过程。而外链 css 无论放在 html 的任何位置都不影响 html 的解析，但是影响 html 的渲染。如果将 css 放在尾部，html 的内容可以第一时间显示出来，但是会阻塞 html 行内 css 的渲染。浏览器的这个策略其实很明智的，想象一下，如果没有这个策略，页面首先会呈现出一个行内 css 样式，待 外部css渲染完之后又突然变了一个模样。用户体验可谓极差，而且渲染是有成本的。如果将 css 放在头部，css 的下载解析是可以和 html 的解析同步进行的，放到尾部，要花费额外时间来解析 CSS，并且浏览器会先渲染出一个没有样式的页面，等 CSS 加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。</p>
<h4 id="为什么-script-要放在尾部？"><a href="#为什么-script-要放在尾部？" class="headerlink" title="为什么 script 要放在尾部？"></a>为什么 script 要放在尾部？</h4><p>因为当浏览器解析到 script 的时候，就会立即下载执行，中断 html 的解析过程，如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p><strong>具体的流程是这样的：</strong></p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。 </li>
<li>解析过程中，发现 script 标签 </li>
<li>暂停解析，网页渲染的控制权转交给 JavaScript 引擎 </li>
<li>如果 script 标签引用了外部脚本，就下载该脚本，否则就直接执行 </li>
<li>执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页</li>
</ol>
<ul>
<li>JavaScript 脚本延迟加载的方式有哪些？</li>
</ul>
<p><strong>defer 属性</strong>： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。 </p>
<p><strong>async 属性</strong>： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。 </p>
<p><strong>动态创建 DOM 方式</strong>： 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。 </p>
<p><strong>使用 setTimeout 延迟方法</strong>： 设置一个定时器来延迟加载 js 脚本文件 </p>
<p><strong>让 JS 最后加载</strong>： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>
<ul>
<li>为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一:将数组的方法应用到类数组上，这时候就可以使用call和apply方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>,<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二:使用Array.from方法将类数组转化成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法三:使用展开运算符将类数组转化成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [...arguments]</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Eventloop：</li>
</ul>
<p>JavaScript中有一个主线程和调用栈，所有的任务都会被放在调用栈等待主线程执行。</p>
<p>同步任务会在调用栈中等待主线程依次执行，异步任务会在异步任务有了结果之后，将注册的回调函数放入任务队列中等待主线程空闲的时候，被读取到栈内等待执行。</p>
<p>执行栈在执行完同步任务后，查看执行栈是否为空，如果为空，就会去执行宏任务，每次宏任务执行完后，检查微任务队列是否为空，如果不为空按照先进先出的规则执行完所有微任务后，设置微任务队列为null，然后继续执行宏任务，如此循环。</p>
<ul>
<li>闭包：</li>
</ul>
<p>在一个函数里面声明另一个函数，那么这个内部的函数就叫做闭包函数。闭包的产生，一个条件是闭包函数，另一个就是在内部函数中使用外部函数声明的参数和变量。闭包存在的意义，是让外部访问函数内部变量成为可能，就是因为闭包产生之后，会创建一个私有的作用域来保存内部函数中使用到的参数和变量。所以闭包的一个使用场景就是作为函数返回体，这样外部就可以通过闭包函数来获取到函数内部的参数和变量。每个闭包里面的环境都是独立的，互不干扰，所以闭包会发生内存泄露，需要谨慎使用。</p>
<ul>
<li>原型与原型链：</li>
</ul>
<p>当我们声明一个函数的时候，会在函数内部自动创建一个原型对象，就是prototype，它是一个空的Object对象，我们可以在这个对象中添加属性，当我们使用new关键字创建一个新的对象时，会自动创建一个<code>__proto__</code>，它会指向构造函数的原型对象，这就是原型链。</p>
<p>当我们在这个对象中查找一个属性或方法时，会先在自己的私有属性中进行查找，如果找不到会顺着<code>__proto__</code>原型链进行查找，直到null都没有找到则报错。</p>
<ul>
<li>JS怎么控制一次加载一张图片，加载完再加载下一张？</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> Image()</span><br><span class="line">	obj.src = <span class="string">&quot;网址&quot;</span></span><br><span class="line">	obj.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>).innerHTML = <span class="string">&quot;&lt;img src = &#x27;+this.src&#x27; /&gt;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;&quot;</span>&gt;</span>onLoading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">也可以用obj.onreadyStatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.readState == <span class="string">&quot;complete&quot;</span>)&#123;</span><br><span class="line">    	<span class="built_in">document</span>.getElementById(<span class="string">&quot;id&quot;</span>).innerHTML = <span class="string">&quot;&lt;img src = &#x27;+this.src&#x27; /&gt;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;代替</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Promise.all实现限制并发请求函数：</li>
</ul>
<p>所谓并发请求，即有待请求接口100个，限制每次只能发出10个。即同一时刻最多有10个正在发送的请求。</p>
<p>每当10个之中有一个请求完成，则从待请求的接口中再取出一个发出。保证当前并发度仍旧为10。</p>
<p>直至最终请求完成。</p>
<p>设计思路：</p>
<p>简单思路如下：</p>
<p>1、创建发送请求函数，然后返回一个promise对象，通过改变该promise状态来调用then函数发送网络请求</p>
<p>2、根据最大并发数通过for循环发送网络请求，使用一个数组来接收请求结果</p>
<p>3、由于发送请求函数返回的是promise，所以我么可以创建一个调度函数，在请求完成后的回调函数中继续触发下一个请求，实现链式调用</p>
<p>4、在调度函数里面进行判断，当请求全部执行完毕后，停止发送请求，最后使用Promise.all，将保存结果的数组作为参数传入，此时请求结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用promise实现并发发送多个请求</span></span><br><span class="line">        <span class="comment">//发送请求函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">                resolve(param)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">urls,max</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//存放请求的结果</span></span><br><span class="line">            <span class="keyword">let</span> pool = []</span><br><span class="line">            <span class="keyword">let</span> Max = <span class="built_in">Math</span>.min(urls.length,max)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; Max;i++)&#123;</span><br><span class="line">                pool.push(send(urls.splice(<span class="number">0</span>,<span class="number">1</span>)).then(resolve))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调度函数</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;当前并发度为：&quot;</span>,pool.length)</span><br><span class="line">                <span class="keyword">if</span>(urls.length === <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&quot;请求全部发送成功&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> send(urls.splice(<span class="number">0</span>,<span class="number">1</span>)).then(resolve)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Promise</span>.all(pool).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;请求结束&quot;</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        request([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>讲一下数组的方法，哪些会改变原数组哪些不会？</li>
</ul>
<p>fill方法：用一个固定值填充一个数组中从起始索引到终止索引的全部元素，不包括最终索引，会改变原数组。</p>
<p>filter方法：创建一个新的数组，其包含通过所提供函数实现的测试的所有元素，不会改变原数组。</p>
<p>find方法：返回数组中满足提供的测试函数的第一个元素的值，不会改变原数组。</p>
<p>flat方法：按照一个深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回，不会改变原数组。</p>
<p>forEach方法：对数组中的每个元素执行一次给定的函数，会改变原数组</p>
<p>map方法：创建一个新数组，其结果是该数组中的每个元素是调用一个提供的函数后的返回值，不会改变原数组。</p>
<p>reduce方法：对数中的每个元素执行一个提供的reduce函数，将其结果汇总为单个返回，不会改变原数组。</p>
<p>some方法：测试数组中是不是至少有一个元素通过了被提供的函数，返回一个布尔值，不会改变原数组。</p>
<p>sort方法：对数组元素进行排序，并返回数组，默认排序时将元素转换为字符串，比较他们的UTF-16代码单元值，会改变原数组。</p>
<p>splice方法：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组的形式返回被修改的内容，会改变原数组。</p>
<ul>
<li>手写原生AJAX：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AJAX = &#123;</span><br><span class="line">	<span class="attr">get</span> : <span class="function"><span class="keyword">function</span>(<span class="params">url,callback</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//1、创建一个XMLHttpRequest对象，即异步请求对象</span></span><br><span class="line">		<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequst()</span><br><span class="line">		<span class="comment">//2、创建一个HTTP请求并配置请求方法，url和验证方法</span></span><br><span class="line">		xhr.open(<span class="string">&quot;GET&quot;</span>,url,<span class="literal">false</span>)</span><br><span class="line">		<span class="comment">//3、设置http响应状态改变的函数</span></span><br><span class="line">		xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//readyState:0(还没有调用open()) 1（请求已经建立，但是没有发送，即没有调用send()） 2（请求已发送，正在处理中） 3（请求在处理中，但是服务器还没有完成响应的生成） 4（响应已完成，可以获取并使用服务器的响应）</span></span><br><span class="line">			<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">					<span class="comment">//5、拿到请求的数据	</span></span><br><span class="line">					<span class="built_in">console</span>.log(responseText)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 设置请求头信息</span></span><br><span class="line">        xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            </span><br><span class="line">		<span class="comment">//4、发送http请求</span></span><br><span class="line">		xhr.send()	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如何实现 ajax 请求，假如我有多个请求，我需要让这些 ajax 请求按照某种顺序一次执行，有什么办法呢？如何处理 ajax 跨域</li>
</ul>
<p>我们可以将多个ajax请求封装进一个数组中，然后使用jQeury的deferred对象，它有一个done和fail函数分别接收的是请求成功执行与失败的回调，当成功执行时我们可以将数组的第一个元素弹出，然后递归执行发送函数，失败的话可以设置重新发送或者将数组第一个元素弹出继续发送下一个请求，最后返回一个promise对象。</p>
<ul>
<li>说一下promise：</li>
</ul>
<p>promise是es6用来进行异步编程，解决回调地狱的新技术，本质上promise是一个构造函数，初始状态pending。我们可以通过指定执行器函数来改变promise的状态，resolve就是改为resolved状态，reject就是改为rejected状态。我们可以在then函数中指定成功或失败的回调函数来获取成功的value或失败的reason，这就是promise的基本使用流程。</p>
<p>promise可以用于封装基于定时器的异步，也可以封装ajax异步请求。由于promise.then会返回一个promise对象所以可以实现链式调用，有效解决回调地狱问题。</p>
<p>关于事件循环：promise的执行器函数会在promise内部同步执行，回调函数是异步执行，会被放在微任务队列中。</p>
<p>关于API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.prototype.catch()：是then的语法糖，相当于then(<span class="literal">undefined</span>,onrejected)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="function">(<span class="params">value</span>) =&gt;</span>&#123;&#125;)：返回一个成功/失败的promise对象</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="function">(<span class="params">reason</span>) =&gt;</span>&#123;&#125;)：返回一个失败的promise对象</span><br><span class="line"><span class="built_in">Promise</span>.all(<span class="function">(<span class="params">promises</span>) =&gt;</span> &#123;&#125;)：返回一个新的promise,只有数组中所有的promise都成功才成功，只要有一个失败了直接失败</span><br><span class="line"><span class="built_in">Promise</span>.race(<span class="function">(<span class="params">promises</span>) =&gt;</span> &#123;&#125;)：返回一个新的promise，第一个完成的promise结果状态就是最终的结果状态</span><br></pre></td></tr></table></figure>

<p>关于then返回的promise状态：</p>
<p>如果抛出异常，新promise对象状态变为rejected，reason为抛出的异常</p>
<p>如果返回的是非promise值，新promise对象变为resolved，value为返回的值</p>
<p>如果返回的是一个promise，则新的promise结果是此promise的结果</p>
<p>关于中断promise链：</p>
<p>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数，可以在回调函数中返回一个pending状态的promise对象。</p>
<ul>
<li>实现动画有哪些方法:</li>
</ul>
<p>1、使用transition</p>
<p>2、使用animation和@keyframes</p>
<p>3、使用js定时器加css改变</p>
<p>4、使用js定时器加canvas</p>
<p>5、使用requestAnimationFrame</p>
<ul>
<li>使用过eslint好处：</li>
</ul>
<p>eslint是js检查代码的工具，由于js语言是弱类型的所以有时候在开发过程中会有一些坑出现，比如==会涉及到弱类型转换，而eslint中是禁止使用==的。使用eslint虽然限制了语言的灵活性但是可以避免低级bug，提示删除多余代码、形成统一的团队代码风格。</p>
<ul>
<li>es6类的概念、继承的特点以及实现：</li>
</ul>
<p>es6中的类是构造函数的另一种写法，它使对象原型的写法更加清晰，更像面向对象编程的写法。</p>
<p>使用class类声明一个全新的类，在类中有一个constructor函数，定义在这个函数里面的属性和方法，会在用new创建一个对象的时候赋值给对象。在类的其他地方声明的属性和方法会被声明在构造函数的原型对象上，供所有实例对象共同使用。</p>
<p>在类中可以用static声明静态方法，静态方法可以不需要通过实例对象直接通过构造函数就可以使用。</p>
<p>类的继承：使用extends关键字实现子类对父类的继承，可以通过super方法访问调用父类上的函数，也可以在子类中对父类的函数进行重写。</p>
<ul>
<li>数据类型检测方式有哪些：</li>
</ul>
<p>typeof：其中数组、对象和null会被判断为object</p>
<p>instanceof：正确判断对象的类型，依据是在其原型链中能否找到该类型的原型</p>
<p>constructor：</p>
<p>1、判断数据的类型    2、判断对象实例通过constructor对象访问它的构造函数，如果创建一个对象来改变他的原型则不能用来判断数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FN</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">FN.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> FN()</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === FN) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === <span class="built_in">Array</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Object.prototype.toString.call()：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([]))  <span class="comment">//[Object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>)) <span class="comment">//[Object Number]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>为什么0.1+0.2  !==  0.3：</p>
</li>
<li><p>计算机是通过二进制存储数据的所以计算机计算的实际上是两个数的二进制的和，但是0.1和0.2的二进制数都是循环数，在JS中只有number一种数据类型，使用64位固定长度来表示，就是标准的双精度浮点数，在二进制科学表示法中小数部分最多只能保存52位，再加上表示符号的数，其实就是保留53位有效数字，剩余的舍去，得到的数转换为十进制就是0.30000000000000004</p>
</li>
<li><p>typeof NaN的结果是什么：</p>
</li>
</ul>
<p>是number，NaN是一个特殊值，指不是一个数字</p>
<ul>
<li>||和&amp;&amp;操作符返回值：</li>
</ul>
<p>对于||来说如果条件是true会返回第一个操作数的值，如果是false就返回第二个的值</p>
<p>对于&amp;&amp;来说如果条件是true就返回第二个操作数的值，如果是false就返回第一个操作数的值</p>
<ul>
<li>什么是JS中的包装类型：</li>
</ul>
<p>在JS中基本数据类型是没有属性和方法的，但是为了便于操作基本类型的值在调用基本类型的属性或者方法时JS会在后台隐式的将基本类型的值转换为对象</p>
<ul>
<li>如何提取高度嵌套的对象中的指定属性：</li>
</ul>
<p>逐层结构</p>
<p>在解构出来的变量右侧通过冒号+{目标属性名}这种形式来进一步解构它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">class</span>:&#123;<span class="attr">stu</span>:&#123;name&#125;&#125;&#125; = school</span><br></pre></td></tr></table></figure>

<ul>
<li>rest参数的理解：</li>
</ul>
<p>扩展运算符被用在函数形参上可以把一个分离的参数序列整合成一个数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>用于获取函数的多余参数或者处理函数参数个数不确定的情况。</p>
<ul>
<li>map与object的区别：</li>
</ul>
<p>意外的键：map默认情况下不包含任何键，只包含显式插入的键；object有一个原型，原型链上的键名可能与自己在对象上设置的键名起冲突</p>
<p>键的类型：map的键可以是任意值；object的键必须是string或者symbol</p>
<p>键的顺序：map的key是有序的，因此在迭代时可以以插入的顺序返回键值；object的键是无序的</p>
<p>size：map上的键值对个数可以通过size轻松获取，object只能手动计算</p>
<p>迭代：map可以直接迭代；但是object需要以某个方式获取它的键然后才能够 迭代</p>
<p>性能：map在频繁增删键值对的场景下表现更好。</p>
<ul>
<li>对JSON的理解：</li>
</ul>
<p>JSON是一种基于文本的轻量级的数据交换格式，它可以被任何编程语言读取和作为数据格式来传递</p>
<p>在项目开发中使用JSON作为前后端数据交换的方式，在前端将一个符合JSON格式的数据结构序列化为JSON字符串，然后将它传递到后端，后端通过JSON格式的字符串解析后生成对应的数据结构。</p>
<p>JSON是基于JS的，JSON中属性值不能为函数，不能出现NaN这样的属性。</p>
<p>JSON.stringfy：传入一个JSON格式的数据结构将其转换为一个JSON字符串。</p>
<p>JSON.parse：将JSON格式的字符串转换为一个js数据结构</p>
<ul>
<li>说说jsonp：</li>
</ul>
<p>jsonp是JSON with padding的意思，它允许在服务器端集成script tags返回到客户端，通过javascript callback的形式实现跨域访问。跨域访问的原理是script标签的src属性不受同源策略所约束，所以可以获取任何服务器上脚本并执行。</p>
<p>jsonp简单的实现模式就是在客户端创建一个回调函数，然后在远程服务器上调用这个函数并且将json数据作为参数传递，完成回调。我们也可以通过动态创建script标签的形式来灵活调用远程服务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">       alert(data.message);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//添加&lt;script&gt;标签的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">       script.setAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">       script.src = src;</span><br><span class="line">       <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       addScriptTag(<span class="string">&quot;http://localhost:20002/test.js&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">//服务器</span></span><br><span class="line"><span class="comment">//调用callback函数，并以json数据形式作为阐述传递，完成回调</span></span><br><span class="line"></span><br><span class="line">callback(&#123;<span class="attr">message</span>:<span class="string">&quot;success&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>JS中类数组对象的理解：</li>
</ul>
<p>一个拥有length属性和若干索引属性的对象就可以称为类数组对象。类数组对象不能调用数组的方法。</p>
<p>常见的将类数组对象转换为数组的方法:</p>
<p>1、通过call调用数组的slice方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure>

<p>2、通过call调用数组的splice方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.splice.call(arguments,0)</span><br></pre></td></tr></table></figure>

<p>3、通过apply调用数组的concat方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.concat.apply([],arguments)</span><br></pre></td></tr></table></figure>

<p>4、通过Array.from来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.from(arguments)</span><br></pre></td></tr></table></figure>

<ul>
<li>常见的位运算符，其计算规则是什么：</li>
</ul>
<p>&amp;：与：两个位都为1时结果才为1</p>
<p>​    用途：判断奇偶；清零</p>
<p>|：或：只要有一个数是1结果就是1</p>
<p>^：异或：两个位相同为0，相异为1</p>
<p>~：取反：0变1,1变0</p>
<p>&lt;&lt;：左移</p>
<p><code>&gt;&gt;</code>：右移</p>
<p>原码：一个数的二进制数</p>
<p>反码：正数反码与原码相同，负数反码除符号位，按位取反</p>
<p>补码：正数补码与原码相同，负数反码除符号位，按位取反最后加1</p>
<ul>
<li>JS为什么要进行变量提升：</li>
</ul>
<p>JS在拿到一个函数或者变量的时候会有两步操作，即解析和执行：</p>
<p>在解析阶段，JS会检查语法并对函数进行预编译。解析的时候会创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量赋值为undefined，函数先声明好可使用。在一个函数执行之前也会创建一个函数执行上下文环境与全局执行上下文类似但是多出this、arguments和函数的参数。</p>
<p>在执行阶段，按照代码的顺序依次执行。</p>
<p>原因：</p>
<p>1、提高性能：在JS代码执行之前语法检查与预编译只进行一次，否则每次执行代码前都需要重新解析一遍该变量或函数。</p>
<p>2、容错性更好</p>
<ul>
<li>ES6模块与CommonJS模块有什么异同：</li>
</ul>
<p>区别：</p>
<p>CommonJS是对模块的浅拷贝，ES6模块时对模块的引用，即ES6模块只存只读，不能改变其值，也就是指针指向不变，类似于const</p>
<p>import的接口时read-only，不能修改其变量值，即不能修改其变量的指针指向，但可以改变变量内部的指针指向；CommonJS可以重新重新赋值（改变指针指向），但是对ES6模块赋值会编译错误</p>
<p>共同点：</p>
<p>两者都可以对引入的对象内部属性进行改变</p>
<ul>
<li>常见的DOM操作：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM节点的获取：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById <span class="comment">//按照id查询</span></span><br><span class="line"><span class="built_in">document</span>.getElementByTagNme <span class="comment">//按照标签名查询</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DOM节点的创建</span></span><br><span class="line"><span class="built_in">document</span>.creatElement() <span class="comment">//创建一个DOM节点</span></span><br><span class="line"><span class="built_in">document</span>.appendChild() <span class="comment">//将DOM添加到页面中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DOM节点的删除</span></span><br><span class="line">父元素.removeChild(子元素)</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改DOM元素</span></span><br><span class="line">父元素.insertBefore(两个子元素)</span><br></pre></td></tr></table></figure>

<ul>
<li>use strict是什么意思，使用它有什么区别：</li>
</ul>
<p>严格模式，使JS在更严格的条件下运行，目的如下：</p>
<p>消除JS语法的的不合理不严谨之处；</p>
<p>消除代码运行的不安全之处，保证代码运行的安全；</p>
<p>提高编译效率，增加运行速度；</p>
<p>区别：</p>
<p>禁止使用with语句；禁止this关键字指向全局对象；对象不能有重名的属性</p>
<ul>
<li>强类型语言与弱类型原因的区别：</li>
</ul>
<p>强类型语言：要求变量的使用要严格符合定义，所有变量必须先定义再使用，一旦被指定为某个数据类型如果不经过强制转换就永远是这个数据类型。</p>
<p>弱类型语言：可以理解为变变量类型是可以被忽略的语言。</p>
<ul>
<li>解释性语言与编译型语言的区别：</li>
</ul>
<p>解释性语言：每次运行都需要将源代码解析成机器码并执行，效率低；只要平台提供相应的解释器就可以运行源代码，方便源程序移植；如JS和python</p>
<p>编译型语言：一次性编译成平台相关的机器语言文件，所以只需编译一次，运行时脱离开发环境，运行效率高；与特定平台相关，一般无法移植到其他平台，如C++</p>
<ul>
<li>ajax和axios和fetch的区别：</li>
</ul>
<p>Ajax是一种在无需加载整个页面的情况下能够更新部分页面的技术。通过在后台与服务器进行少量数据交换，ajax可以使网页实现异步更新。缺点是本身是针对MVC编程，不符合前端MVVN浪潮；基于原生XHR开发，配置和调用的方式非常混乱，而且基于事件的异步模型不友好；</p>
<p>Fetch是基于promise设计的，不是ajax的进一步封装，而是原生JS，没有使用XMLHttpRequest对象。优点：基于标准promise实现，支持async/await，更加底层，提供的API丰富（request，response）；缺点是只对网络请求报错，对于400/500都当做成功的请求，不会reject，只有网络请求不能完成时fetch才会被reject；fetch默认不会带cookie，需要添加配置项（fetch(url,{credentials:”include”]})）;fetch不支持abort与超时控制，使用setTimeout与promise.reject实现超时控制并不能阻止请求过程继续在后台运行造成流量的浪费；fetch没有办法原生监控请求的进度，而XHR可以；</p>
<p>Axios是一种基于promise封装的http客户端，特点是浏览器发起XMLHttpRequest请求；node端发起http请求，支持promiseAPI，对请求和返回进行转换；自动转换json数据；客户端支持抵御XSRF攻击。</p>
<ul>
<li>async与await原理：</li>
</ul>
<p>async与await其实是generator函数的语法糖，并对generator函数进行了改进。相比生成器函数，async自带执行器，不需要手动执行next方法；async函数的await命令后面，既可以是promise对象也可以是原始数据类型，它都会自动转成成功状态的promise对象。而且async函数的返回值是promise对象，可以使用then方法进行调用。</p>
<p>由于async隐式返回promise作为结果，那么可以理解为在await命令之后，await会产生一个微任务，相当于是promise.then()，但还是这个微任务产生的时机是在await执行之后，直接跳出async函数执行其他代码，这就是协程的运作。其他代码执行完毕后在回到async函数执行剩下的代码，注册到微任务队列中。</p>
<ul>
<li>commonjs与es6模块的区别：</li>
</ul>
<p>commonjs模块加载过程是同步阻塞性加载，在缓存方面，commonjs在模块代码被运行前就已经以模块绝对路径为key，module对象为value写入cache，同一个模块被多次require时只会执行一次，重复的require得到的是相同的exports引用。</p>
<p>ES6模块时为了不再使用闭包与函数封装的方式进行模块化提供的模块化功能，使用export暴露、import引入。在node使用es6模块需要将js文件后缀改成mjs，或者配置package.json的type为module，告诉node以esmodule的形式加载模块。</p>
<p>es6模块加载过程：</p>
<p>1、es6模块会在程序开始前先根据模块的关系查找到所有的模块生成一个无环关系图然后将所有模块实例创建好</p>
<p>2、在内存中腾出空间给即将使用export暴露的内容，然后使import和export指向内存中的这些空间（连接）</p>
<p>3、基于第一步生成的无环图进行深度优先后遍历填值，如果此时访问到了尚未初始化完成的空间会抛出异常。</p>
<p>commonjs可以在运行时使用变量进行require但是import不可以因为es6模块会先解析所有模块在执行代码；</p>
<p>require会将完成的exports对象引入，但是import可以只引入部分必要的内容，这就是为什么使用tree-shaking时必须使用es6模块写法；</p>
<p>import另一个模块没有export的变量会在代码执行前报错，但是使用commonjs是在模块运行时才报错。</p>
<ul>
<li>为什么浏览器端不建议使用commonjs：</li>
</ul>
<p>因为在浏览器端我们如果封装一个模块来发送网络请求，由于网络请求会消耗一定时间所以一般使用异步加载的方式发送网络请求。但是当使用commonjs，由于commonjs加载模块是同步执行代码的，此时请求的等待时间可能随着网速快慢以及请求数据大小的影响，会使浏览器处于假死状态。</p>
<ul>
<li>documentfragment（文档片段接口）：</li>
</ul>
<p>documentfragment是一个类似于document的文档对象，它可以向document一样存储由节点组成的文档结构，但是它最大的特点就是它的变化不会触发dom树的重新渲染，所以我们可以把添加删除节点的所有操作使用documentfragment 保存起来，最后一次性插入到文档中，这样文档只会发生一次重新渲染。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个frame对象</span></span><br><span class="line"><span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="comment">//可以跟document一样获取元素节点，也可以使用appendChild和removeChild来添加删除节点</span></span><br><span class="line"><span class="comment">//最后只需要将frame对象添加到document中即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MutationObserver：</li>
</ul>
<p>MutationObserver的出现是为了取代废弃的MutationEvent,因为后者有严重的性能问题。MutationObserver可以用于观察指定dom元素的属性、子节点以及文本的变化，并且可以在dom元素被修改时异步执行回调。</p>
<p>我们可以通过创建一个MutationObserver实例，然后使用它的方法来指定对哪些元素以及元素哪些属性进行观察，通过mutationRecord和mutationObserve参数可以获取到观察的配置。每一个MutationObserver实例对象会把每一次变化的信息保存在MutationRecord实例中，然后添加到记录队列，通过数组进行保存，注册的回调函数只会执行一次。</p>
<p>MutationObserver对象有三个方法可以调用：</p>
<p>observer（）：通过该方法可以传入要观察的dom元素以及对目标节点的观察范围。该方法可以关联MutationObserver对象与dom元素，可以重复使用来复用一个MutationObserver对象观察多个不同的目标节点。</p>
<p>disconnect（）：使用该方法可以提前终止执行回调函数。</p>
<p>takeRecords（）：可以清空记录队列，取出并返回包含其中的所有MutationRecord实例的数组。</p>
<ul>
<li>使用promise需要执行并行和独立的异步操作并收集所有结果（包括成功与失败）怎么办：</li>
</ul>
<p>使用Promise.allSettled()方法可以并行执行独立的异步操作，并将异步操作的结果以一个数组返回，如果成功则是{status:”fulfilled”,value:value}，失败则是{status:”rejected”,reason:reason}。可以使用then方法，也可以使用async/await提取所有的promise状态。</p>
<ul>
<li>说说图片懒加载：</li>
</ul>
<p>图片懒加载就是让一些不可视的图片不去加载，避免一次性加载太多图片导致请求阻塞，可以提高网网站的加载速度，提高用户体验。</p>
<p>实现：</p>
<p>1、首先对需要懒加载的图片标签自定义一个属性用来存放真正的图片或者原图地址，并且定义一个类名，表示该图片是需要懒加载的。</p>
<p>2、根据类名为图片设置一个未加载前的背景图。</p>
<p>3、在js中获取到所有需要懒加载的图片的元素集合，判断是否在可视区域，如在可视区域则将元素的src属性设置为真正的图片地址</p>
<p>判断是否出现在可视区域可以通过以下方法：</p>
<p>offsetTop、scrollTop：offsetTop表示元素的上边框至包含元素的上内边框之间的距离；scrollTop表示元素的滚动位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInViewPortOfOne</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.offsetTop</span><br><span class="line">    <span class="keyword">const</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line">    <span class="keyword">const</span> top = offsetTop - scrollTop</span><br><span class="line">    <span class="keyword">return</span> top &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getBoundingClientRect：返回值是一个对象，拥有left、top、right等属性</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/dc51e2f83b622172.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInViewPort</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntersectionObserver：可以判断两个元素是否重叠，因为不用进行事件监听所以性能会好很多。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建观察者</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123; ....&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入被观察者</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.observe(target);</span><br></pre></td></tr></table></figure>

<ul>
<li>node与浏览器事件循环区别：</li>
<li>map与set的区别：</li>
</ul>
<p>map是一个存储键值对的集合，与Object对象不同的是map存储的键可以是任意数据类型，而object对象的键只能是字符串或者是symbol，map对象可以通过set、get、delete等方法对键值对进行增删改查。</p>
<p>set是一个存储元素的集合，它只能存储不重复的值，与map不同的是它没有get方法，因为它存储的不是键值对，也可以使用set对数组去重，将数组作为参数新建一个set对象，然后对set对象使用扩展运算符即可。</p>
<ul>
<li>说说js垃圾回收机制：</li>
</ul>
<p>标记清除法：当代码执行在一个环境中时（比如一个函数的时候），每声明一个变量就会对变量做一个标记，当离开当前执行环境进入另一执行环境的时候，这时会对上一个环境的变量做一个标记，等到垃圾回收执行时，会根据标记来决定清除哪些变量。</p>
<p>引用计数法：用一个值跟踪记录每个值被使用的次数，当声明一个变量并将一个引用类型赋值给该变量时，该值加1（指的是引用数据类型），当该变量被重新赋值时该值减1，当该值为0的时候说明没有变量在使用，会在垃圾回收的时候尽心回收。</p>
<ul>
<li>常见的内存泄露场景：</li>
</ul>
<p>意外的全局变量：当我们在全局对象中window声明一个变量使用完毕后没有使用null进行处理或者重新定义的时候，会出现内存泄露。</p>
<p>闭包：使用闭包我们可以从外部访问到内部函数的属性，会产生一个独立的作用域，过度使用闭包会导致内存占用过多。</p>
<p>计时器：使用完计时器完后需要手动清除计时器，否则可能由于其中引用的变量或函数被认为是需要的而不进行回收，出现内存泄露。</p>
<p>脱离DOM的使用 ：当我们在js中操作使用一个变量来操作DOM的时候，如果在后面代码中删除DOM的时候没有对该变量进行清除的话会产生内存泄露。</p>
<ul>
<li>实现水印（场景题）：</li>
</ul>
<p>1、使用js在页面上充满透明度较低的信息盒子。在一个大盒子中循环生成小的水印，为每一个水印展示要显示的信息。</p>
<p>2、在页面上覆盖一个固定定位的盒子，然后创建一个canvas画布，绘制出一个水印区域，将画布通过toDataUrl方法输出为一个图片，将这个图片设置为盒子的背景图，通过background-repeat:repeat实现充满屏幕的效果。也可以使用svg。</p>
<p>为了避免水印被恶意删除，可以通过MutationObserver观察节点变化，因为该API只能监听子节点的变化，所以可以通过监听水印的父节点，当有人对水印进行删除操作时，调用方法重新添加水印。</p>
<ul>
<li>说说继承：</li>
</ul>
<p>继承就是通过某种方式让对象可以访问到另一个对象中的属性与方法，这种方法称为继承。</p>
<p>1、原型链继承：通过实例化一个新的函数，子类的原型指向父类的实例，子类就可以调用父类原型对象上的私有属性和方法，本质上值重写了原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.parentName = <span class="string">&quot;父类&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getParentName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parentName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.childName = <span class="string">&quot;子类&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">//原型链继承</span></span><br></pre></td></tr></table></figure>

<p>原型链继承的优点是简单易实现，父类新增原型方法与属性子类都能访问；缺点就是无法实现多继承，引用类型的值会被实例共享。</p>
<p>2、借用构造函数继承：就是利用call或apply函数，在子类型构造函数的内部调用超类型构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.hobbies = [<span class="string">&quot;sing&quot;</span>,<span class="string">&quot;dance&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>,name)</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借用函数构造的优点是解决了引用类型的值被实例共享的问题，可以试下超类传递参数，可以实现多继承；缺点是不能继承超类原型链上的属性与方法，无法实现函数复用，由于call有多个父类实例的副本有性能的损耗。</p>
<p>3、组合模式继承：是将原型链继承与借助构造函数继承的技术组合到一块的一种继承模式。</p>
<p>4、共享原型继承：就是子类与父类共享一个原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Parent.prototype.hobbies = [<span class="string">&quot;sing&quot;</span>,<span class="string">&quot;dance&quot;</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Parent.prototype</span><br></pre></td></tr></table></figure>

<p>共享原型继承的优点是简单易实现，缺点是只能继承父类原型的属性与方法，不能继承构造函数属性方法。</p>
<p>5、原型式继承：用于基于当前已有对象创建新对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//es5的Object.create()方法规范类原型式继承</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">//创建一个纯洁的对象，对象什么属性都没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;zehong&quot;</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1) <span class="comment">//创建一个子对象，继承某个父对象</span></span><br></pre></td></tr></table></figure>

<p>6、寄生式继承：是原型式继承的加强版，它结合原型式继承与工厂模式，创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后返回对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(origin) <span class="comment">//通过调用函数创建一个对象</span></span><br><span class="line">    clone.sayHi = <span class="function"><span class="title">fnuction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;父对象&quot;</span>,</span><br><span class="line">    <span class="attr">hobbies</span>:[<span class="string">&quot;sing&quot;</span>,<span class="string">&quot;dance&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = createAnother(o1)</span><br></pre></td></tr></table></figure>

<p>7、寄生组合式继承：是寄生式继承的加强版，是伪类避免组合继承中无法避免要调用两次父类构造函数的最佳方案。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheriPrototype</span>(<span class="params">SubType,SuperType</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(SuperType.prototype)</span><br><span class="line">    prototype.constructor = SubType</span><br><span class="line">    SubType.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.hobbies = [<span class="string">&quot;sing&quot;</span>,<span class="string">&quot;dance&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getHobbies = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hobbies</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>,name)</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure>

<p>本质是子类的原型继承自父类的原型，申明一个用于继承原型的inheritPrototype方法，通过这个方法我们能够将子类的原型指向超类的原型从而避免超类二次实例化。</p>
<p>8、class继承：通过class关键字定义类，子类可以通过extends继承父类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.hobbies = [<span class="string">&quot;sing&quot;</span>,<span class="string">&quot;dance&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getHobbies</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.hobbies</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getCurrent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//static关键字定义的静态方法都必须通过类名调用，它的this指向调用者而非实例</span></span><br><span class="line"><span class="comment">//通过extends可以继承父类的所有原型属性与static类方法，子类可以调用super父类构造函数实现实例属性与方法的继承</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器事件模型：</li>
</ul>
<p>W3C将事件发生定义为三个阶段：捕获阶段、目标阶段与冒泡阶段</p>
<p>捕获阶段：首先window会捕获到事件之后document、documentElement、body会捕获到，再之后就是在body中DOM元素一层一层的捕获事件，直到到达事件的目标节点，捕获阶段的主要任务是建立传播路径。</p>
<p>目标阶段：真正点击的元素事件发生了两次，因为既在捕获阶段绑定了事件，又在冒泡阶段绑定了事件</p>
<p>冒泡阶段：事件在目标元素上触发后，并不在这个元素上终止，它会随着DOM树 一层层往上冒泡，回溯到根节点。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/c3b16f60fc3ab25c.webp"></p>
<p>在事件回调函数里加上true则为事件捕获，会从根接电脑向下逐级触发各个节点直到目标节点触发事件处理函数。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/03/9efd4f5ae10be359.webp"></p>
<p>可以使用e.stopPropagation()阻止事件传播，既可以是冒泡阶段也可以是捕获阶段；可以使用e.preventDefault()阻止事件的默认行为发生。</p>
<ul>
<li>深度优先输出html上的所有标签：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = []</span><br><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFirstSearch</span>(<span class="params">node,nodeList</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)&#123;</span><br><span class="line">		nodeList.push(node)</span><br><span class="line">        <span class="keyword">var</span> children = node.children</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; children.length;i++)&#123;</span><br><span class="line">            deepFirstSearch(children[i],nodeList)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFirstSearch</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = []</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> stack = []</span><br><span class="line">        stack.push(node)</span><br><span class="line">        <span class="keyword">while</span>(stack.length !== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> item = stack.pop()</span><br><span class="line">            nodes.push(item)</span><br><span class="line">            <span class="keyword">var</span> children = item.children</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = children.length;i &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">                stack.push(children[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>广度优先输出html上的所有标签：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadFirstSearch</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = []</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(!(node == <span class="literal">null</span>))&#123;</span><br><span class="line">        nodes.push(node)</span><br><span class="line">        breadFirstSearch(node.nextElementSibling)</span><br><span class="line">        node = nodes[i++]</span><br><span class="line">        breadFirstSearch(node.firstElementChild)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadFirstSearch</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = []</span><br><span class="line">    <span class="keyword">if</span>(node !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> queue = []</span><br><span class="line">        queue.unshift(node)</span><br><span class="line">        <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> item = queue.shift()</span><br><span class="line">            nodes.push(item)</span><br><span class="line">            <span class="keyword">var</span> children = item.children</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; children.length;i++)&#123;</span><br><span class="line">                queue.push(children[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/JavaScript/" data-id="cl0x9xz3p000ktsug1dxn3tu5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/CSS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/CSS/" class="article-date">
  <time datetime="2021-11-20T12:43:19.933Z" itemprop="datePublished">2021-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/CSS/">CSS篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-CSS布局单位"><a href="#1-CSS布局单位" class="headerlink" title="1.CSS布局单位"></a>1.CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p>
<p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域。</p>
<p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p>
<p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p>
<ul>
<li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。 </li>
<li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕分辨率间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。 </li>
</ul>
<p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<ul>
<li>vw：相对于视窗的宽度，视窗宽度是100vw； </li>
<li>vh：相对于视窗的高度，视窗高度是100vh； </li>
<li>vmin：vw和vh中的较小值； </li>
<li>vmax：vw和vh中的较大值； </li>
</ul>
<p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p>
<ul>
<li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等) </li>
<li>vw/vm：相对于视窗的尺寸 </li>
</ul>
<ul>
<li>怎么判断元素在页面中的可视范围内：</li>
</ul>
<p>1、offsetTo：表示元素的上边框至包含元素的上内边框的距离</p>
<p>scrollTop：表示这个元素的<strong>内容顶部</strong>（卷起来的）到它的视口可见内容（的顶部）的距离</p>
<p>使用offsetTo-scrollTop是否小于等于视窗高度来判断</p>
<p>2、使用getBoundingClientRect来获取元素的信息，包括大小与相对于视窗的位置</p>
<p>3、使用IntersectionObserver来判断两个元素是否重叠，因为不会触发回流重绘所以性能比上一个好；主要分为创建观察者与传入观察者。</p>
<h3 id="2-link与-import标签的区别"><a href="#2-link与-import标签的区别" class="headerlink" title="2.link与@import标签的区别"></a>2.link与@import标签的区别</h3><p>link属于html标签，而@import是css提供的</p>
<p>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。</p>
<p>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。</p>
<p>link方式样式的权重高于@import的。</p>
<h3 id="3-什么是BFC"><a href="#3-什么是BFC" class="headerlink" title="3.什么是BFC"></a>3.什么是BFC</h3><p>BFC就是块级格式化上下文，可以理解为时一个独立的块，在这个块中浮动元素会被计算高度，所有元素垂直沿着父元素边框排列。</p>
<p>BFC布局规则：</p>
<ul>
<li><p>内部的Box会在垂直方向，一个接一个地放置。</p>
</li>
<li><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</p>
</li>
<li><p>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p>
</li>
<li><p>BFC的区域不会与float box重叠。</p>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</li>
<li><p>计算BFC的高度时，浮动元素也参与计算。</p>
</li>
<li><p>如何开启BFC：</p>
</li>
</ul>
<p>1、设置元素浮动</p>
<p>2、设置元素绝对定位</p>
<p>3、设置元素为inline-block</p>
<p>4、将元素的overflow设置为hidden（副作用最小）</p>
<h3 id="4-垂直居中的方法"><a href="#4-垂直居中的方法" class="headerlink" title="4.垂直居中的方法"></a>4.垂直居中的方法</h3><p>(1)margin:auto法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">css:</span><br><span class="line">div&#123;</span><br><span class="line">width: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#465468</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>:</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;mm.jpg&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>定位为上下左右为0，margin：0可以实现脱离文档流的居中.</p>
<p>(2)margin负值法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#379</span>;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">480px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">380px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#746</span>;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin-top</span>: -<span class="number">190px</span>; <span class="comment">/*height的一半*/</span></span><br><span class="line"><span class="attribute">margin-left</span>: -<span class="number">240px</span>; <span class="comment">/*width的一半*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：其实这里也可以将marin-top和margin-left负值替换成，<br>transform：translateX(-50%)和transform：translateY(-50%)</p>
<p>(3)table-cell（未脱离文档流的）</p>
<p>设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css:</span><br><span class="line">div&#123;</span><br><span class="line">width: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#555</span>;</span><br><span class="line"><span class="attribute">display</span>: table-cell;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)利用flex</p>
<p>将父元素设置为display:flex，并且设置align-items:center;justify-content:center;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">css:</span><br><span class="line">.container&#123;</span><br><span class="line">width: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#546461</span>;</span><br><span class="line"><span class="attribute">display</span>: -webkit-flex;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">-webkit-<span class="attribute">align-items</span>: center;</span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br><span class="line">-webkit-<span class="attribute">justify-content</span>: center;</span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span>&#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">3px</span> solid <span class="number">#458761</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-多行文本的文本省略"><a href="#5-多行文本的文本省略" class="headerlink" title="5.多行文本的文本省略"></a>5.多行文本的文本省略</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使文字数量不同在相同的地方显示，给盒子加固定高度</span><br><span class="line"> </span><br><span class="line"><span class="attribute">overflow</span>：hidden;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">display</span>：-webkit-box; 将盒子转换为弹性盒子</span><br><span class="line"> </span><br><span class="line">-webkit-line-clamp：<span class="number">2</span>; 设置显示多少行</span><br><span class="line"> </span><br><span class="line"><span class="attribute">text-overflow</span>：ellipsis; 文本以省略号显示   </span><br><span class="line"> </span><br><span class="line">-webkit-box-orient：vertical; 文本显示方式，默认水平</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-visibility-hidden-opacity-0，display-none的区别"><a href="#6-visibility-hidden-opacity-0，display-none的区别" class="headerlink" title="6.visibility=hidden, opacity=0，display:none的区别"></a>6.visibility=hidden, opacity=0，display:none的区别</h3><p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>
<h3 id="7-垂直外边距重叠"><a href="#7-垂直外边距重叠" class="headerlink" title="7.垂直外边距重叠"></a>7.垂直外边距重叠</h3><p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠</p>
<p>折叠的结果为：</p>
<ul>
<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>
<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>
<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>
</ul>
<h3 id="8-清除浮动"><a href="#8-清除浮动" class="headerlink" title="8.清除浮动"></a>8.清除浮动</h3><ul>
<li>给父级div定义<code>height</code>属性 </li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式 </li>
<li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code> </li>
<li>使用 :after 伪元素</li>
</ul>
<h3 id="9-offset-scroll-client-各类属性"><a href="#9-offset-scroll-client-各类属性" class="headerlink" title="9.offset/scroll/client 各类属性"></a>9.offset/scroll/client 各类属性</h3><h4 id="clientX-clientY"><a href="#clientX-clientY" class="headerlink" title="clientX clientY"></a>clientX clientY</h4><ul>
<li>鼠标相对于浏览器窗口可视区域的 X，Y 坐标 </li>
</ul>
<h4 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX pageY"></a>pageX pageY</h4><ul>
<li>类似于 clientX，clientY，但它们使用的是文档坐标而非窗口坐标。具体来说,<strong>pageY = clientY + 页面滚动高度</strong>。 </li>
</ul>
<h4 id="offsetX-offsetY"><a href="#offsetX-offsetY" class="headerlink" title="offsetX offsetY"></a>offsetX offsetY</h4><ul>
<li>鼠标相对于事件源元素（srcElement）的 X，Y 坐标</li>
</ul>
<p><img src="D:\个人文件\学习课件\大物\976B9A765990D59544D4B6D6655484F3.png"></p>
<h3 id="10-选择器上的优先级"><a href="#10-选择器上的优先级" class="headerlink" title="10.选择器上的优先级"></a>10.选择器上的优先级</h3><p>对于选择器的<strong>优先级</strong>： </p>
<ul>
<li> 标签选择器、伪元素选择器：1 </li>
<li> 类选择器、伪类选择器、属性选择器：10 </li>
<li> id 选择器：100 </li>
<li> 内联样式：1000 </li>
</ul>
<p> <strong>注意事项：</strong> </p>
<ul>
<li> !important 声明的样式的优先级最高； </li>
<li> 如果优先级相同，则最后出现的样式生效； </li>
<li> 继承得到的样式的优先级最低； </li>
<li> 通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0； </li>
<li> 样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。 </li>
</ul>
<blockquote>
<p> 简单记住结论：!important&gt;行内样式&gt;id 选择器&gt;class 选择器/属性选择器&gt;标签选择器&gt;通配符*</p>
</blockquote>
<ul>
<li>绝对定位</li>
</ul>
<p>当元素开启绝对定位后会脱离文档流，如果不设置偏移量，则元素位置不会发生变化。绝对定位是相对于离它最近的开启了定位的祖先元素进行定位的，开启了绝对定位后内联元素会变为块元素，块元素的宽度和高度会默认被内容撑开。</p>
<ul>
<li>脱离文档流</li>
</ul>
<p>在HTML中所有的元素都是盒模型，他们一次排放在HTML中形成文档流。脱离文档流的意思就是元素在文档流中不再占据空间，而是出于浮动的状态。</p>
<ul>
<li>margin和padding的区别：</li>
</ul>
<p>padding是作用于自身，margin是作用于外部对象。</p>
<ul>
<li>实现一个渐变色动画：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#jianbian</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">linear-gradient</span>(<span class="number">45deg</span>,<span class="number">#aabbcc</span>,pink,yellow);</span><br><span class="line">    <span class="attribute">animation</span>:name <span class="number">10s</span> infinite alternate</span><br><span class="line">        (infinite是循环，alternate是轮流反向播放)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> name &#123;</span><br><span class="line">	<span class="number">100%</span> : &#123;</span><br><span class="line">        filter:<span class="built_in">hue-rotate</span>(<span class="number">360deg</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给五个div实现以下布局：</li>
</ul>
<p>1                1                1</p>
<p>1                1</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">“a”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">第一种：<span class="attribute">flex</span>布局</span><br><span class="line"><span class="selector-id">#a</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:flex-start;</span><br><span class="line">    <span class="attribute">flex-wrap</span>:wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#a</span> &gt; <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种：grid布局</span><br><span class="line"><span class="selector-id">#a</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">	<span class="attribute">display</span>: grid;</span><br><span class="line">	grid-template-<span class="attribute">columns</span>: <span class="number">300px</span> <span class="number">300px</span> <span class="number">300px</span>;</span><br><span class="line">    //（也可以用fr作为单位，则是按元素宽度比例）</span><br><span class="line">    //（也可以使用repeat（<span class="number">3</span>,<span class="number">300px</span>）实现重复的单元格）</span><br><span class="line">	grid-template-rows:<span class="number">300px</span> <span class="number">300px</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>伪类和伪元素的区别：</li>
</ul>
<p>主要的区别就在于是否创建了新元素。伪类用于选择DOM树以外的信息，或者是不能用简单选择器进行表示的信息。伪元素为DOM树没有定义的虚拟元素，比如::before表示选择元素内容之前的内容。</p>
<p>还有就是伪类是一个:开头，伪元素是两个:开头。</p>
<ul>
<li>实现圣杯布局（左右两边固定宽，中间自适应，使用float、负外左边距和相对定位实现）：</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/02/c2810dc5fbc649f7.png"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#header</span>,<span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#center</span>,<span class="selector-id">#left</span>,<span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">160</span>, <span class="number">55</span>, <span class="number">55</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现双飞翼布局：（左右两边固定宽，中间自适应，使用float、负外左边距实现，和圣杯布局相比这里的main只包裹center，而圣杯布局main包裹center、left、right三个元素）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        *&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#header</span>,<span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">160</span>, <span class="number">55</span>, <span class="number">55</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#main</span>,<span class="selector-id">#left</span>,<span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#aaa</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;header&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;center&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器重绘与回流：</li>
</ul>
<p>重绘：当页面中的元素样式改变不会影响它在文档流中的位置时浏览器会将新样式赋予给元素并重新绘制它，这就是重绘</p>
<p>回流：当渲染树中部分或全部元素的尺寸结构或者某种属性发生变化时，浏览器重新渲染文档的过程就是回流</p>
<p>会导致回流的操作有：添加删除可见的DOM元素、元素位置尺寸发生变化、激活CSS伪类、查询一些属性或者调用某些方法（clentWidth,offsetWidth）</p>
<p>如何避免回流：</p>
<p>CSS：避免设置多层内联样式、将动画效果应用在position设置为absolute或者fixed的元素上（脱离文档流），避免使用css表达式（calc()）</p>
<p>JS：避免频繁操作样式、避免频繁操作DOM、避免频繁读取会引发重绘/回流的属性，使用documentfragment</p>
<ul>
<li>高度塌陷及其解决：</li>
</ul>
<p>当一个元素设置浮动之后会脱离文档流，如果父元素没有设置高度，下面的元素会上移，浮动元素会覆盖下边的元素内容，这就是高度塌陷。</p>
<p>解决方法：</p>
<p>1、给父元素指定高度</p>
<p>2、给父元素开启BFC：设置定位为绝对定位或开启overflow为非visible属性</p>
<p>3、给父元素添加一个伪元素::after，然后该元素设置清除浮动：clear:both</p>
<p>4、给浮动元素下面一个元素然后该元素设置清除浮动</p>
<ul>
<li>实现一个三角形：</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向上</span><br><span class="line"><span class="selector-class">.anjiaoxing</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line">	<span class="attribute">border-bottom</span>:<span class="number">10px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现毛玻璃效果：</li>
</ul>
<p>使用backdrop-filter属性的blur方法为一个元素后面区域添加模糊效果，filter则是作用于整个元素</p>
<p>如果为了兼容，可以使用background-attachment:fixed在元素背后叠加一张同样的图片，然后使用filter:blur对其进行模糊处理即可。</p>
<ul>
<li>gpu加速：</li>
</ul>
<p>当我们在css中做一些对CPU负荷较大的事情，比如css动画、变形和渐变时，可以使用GPU加速的方法来获取更高的渲染性能，同时减少cpu资源的争用。</p>
<p>1、在二维空间中使用translateZ或者translate3d方法来骗取浏览器触发硬件加速。但是这样做使用代价的，就是会占用RAM与GPU存储空间，考虑到移动设备的存储容量有限，所以需要谨慎使用。</p>
<p>2、will-change属性：提前通知浏览器我们要对元素进行什么操作，让浏览器可提前准备合适的优化设置，这样元素就可以更快的改变与渲染，达到页面快速更新，表现更加流畅的效果。但是对太多属性设置will-change会占用太多的资源甚至导致页面奔溃，可以通过js对will-change进行释放。</p>
<ul>
<li>css解析是否阻塞html解析与渲染：</li>
</ul>
<p>由于在浏览器渲染过程中，html需要解析成dom树，css需要解析成stylesheet，所以html解析与css解析时两个并行的进程，css解析不会影响html解析；由于渲染树是依赖于dom树与stylesheet的，所以所以必须等到stylesheet构建完成才开始渲染，所以css解析会影响html渲染。</p>
<p>由于js可能会操作之前的dom节点与css样式，所以样式表会在js执行前先加载执行完毕，所以css会阻塞后面js的执行。</p>
<ul>
<li>requestAnimationFrame：window.requestAnimationFrame()</li>
</ul>
<p>当使用定时器setTimeout实现动画时，由于定时器的回调函数时异步执行的，所以实际执行时间与设置的延迟时间会存在差异。屏幕的刷新频率一般是60hz，所以我们一般设置动画执行间隔为16.7ms，但是由于定时器的特点可能出现动画出现闪烁的效果，引起用户眼睛疲劳。</p>
<p>使用requestAnimationFrame可以由系统函数来决定回调函数执行的时机，它是跟着屏幕刷新频率走的所以不会出现丢帧的现象。而且相比于定时器开启后即使页面被隐藏或者最小化，只要不清除定时器都是一直在后台执行，完全浪费CPU资源；但是requestAnimationFrame任务在被系统暂停后会停止渲染，节省CPU资源。而且使用requestAnimationFrame可以保证回调函数在页面刷新间隔只执行一次，起到函数节流的效果。唯一的缺点就是浏览器对requestAnimationFrame的兼容性较差，所以可以通过优雅降级的方式根据不同浏览器实现动画效果。</p>
<ul>
<li>CSS3新特性：</li>
</ul>
<p>1、新增了一些选择器：:nth-child、:first-of-type、:last-child</p>
<p>2、新样式：</p>
<p>边框新增了border-radius、box-shadow、border-image属性</p>
<p>背景新增了background-origin等属性</p>
<p>文字，颜色也有</p>
<p>3、transition过渡</p>
<p>4、transform转换：包括translate位移、scale缩放、rotate旋转、skew倾斜</p>
<p>5、animation动画</p>
<p>6、渐变：线性渐变linear-gradient与径向渐变radial-gradient</p>
<p>。。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/CSS/" data-id="cl0x9xz3k000gtsugh9b8axx6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试准备/HTML" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HTML/" class="article-date">
  <time datetime="2021-11-20T12:43:14.782Z" itemprop="datePublished">2021-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HTML/">HTML篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. <code>src</code>和<code>href</code>的区别</h3><p><code>src</code>和<code>href</code>都是<strong>用来引用外部的资源</strong>，它们区别如下：</p>
<ul>
<li><code>src</code>：表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。<code>src</code>会将其指向的资源下载并应⽤到⽂档内，如在请求<code>js</code>脚本，<code>img</code>图⽚和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般<code>js</code>脚本会放在页面底部⽽不是头部。 </li>
<li><code>href</code>：表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ul>
<h3 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h3><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。</p>
<p>语义化的优点主要有以下两点：</p>
<ul>
<li>对于机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录； </li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者也能清晰的看出网页的结构，便于团队的开发与维护。 </li>
</ul>
<p> 常见的语义化标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;``header``&gt;&lt;/``header``&gt;头部` `&lt;``nav``&gt;&lt;/``nav``&gt;导航栏` `&lt;``section``&gt;&lt;/``section``&gt;区块（有语义化的div）` `&lt;``main``&gt;&lt;/``main``&gt;主要区域` `&lt;``artical``&gt;&lt;/``artical``&gt;主要内容` `&lt;``aside``&gt;&lt;/``aside``&gt;侧边栏` `&lt;``footer``&gt;&lt;/``footer``&gt;底部</span><br></pre></td></tr></table></figure>



<h3 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或<code>xhtml</code>）的文档类型定义来解析文档</strong>，不同的渲染模式会影响到浏览器对于 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>
<p>浏览器渲染页面的两种模式（可通过<code>document.compatMode</code>获取）：</p>
<ul>
<li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。 </li>
<li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<p>两者区别：</p>
<p>①盒模型</p>
<p>在怪鱼模式下，盒模型是<code>IE</code>盒子而非标准模式下的W3C盒模型，在IE模型中，box width = content width + padding left + padding right + border left + border right， box height = content height + padding top + padding bottom + border top + border bottom。 而在 W3C 标准的盒模型中，box 的大小就是 content 的大小。</p>
<p>②图片元素的垂直对齐方式</p>
<p>对于<code>inline</code>元素和<code>table-cell</code>元素，在 IE Standards Mode 下 vertical-align 属性默认取值为<code>baseline</code>。而当<code>inline</code>元素的内容只有图片时，如<code>table</code>的单元格<code>table-cell</code>。在 IE Quirks Mode 下，<code>table</code>单元格中的图片的 <code>vertical-align</code> 属性默认为<code>bottom</code>，因此，在图片底部会有几像素的空间。</p>
<p>③<table>元素的字体</p>
<p>CSS 中，描述<code>font</code>的属性有<code>font-family</code>，<code>font-size</code>，<code>font-style</code>，<code>font-weigh</code>,上述属性都是可以继承的。而在 IE Quirks Mode 下，对于<code>table</code> 元素，字体的某些属性将不会从<code>body</code>或其他封闭元素继承到<code>table</code>中，特别是 <code>font-size</code>属性。</p>
<p>④内联元素的尺寸</p>
<p>在 IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的<code>width</code>和<code>height</code> 属性，能够影响该元素显示的大小尺寸。</p>
<p>⑤元素溢出的处理</p>
<p>在 IE Standard Mode 下，<code>overflow</code>取默认值 <code>visible</code>，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展<code>box</code>来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容。</p>
<ul>
<li>box-sizing是什么：</li>
</ul>
<p>box-sizing属性定义了应该如何计算一个元素的总宽度与总高度</p>
<p>属性值：</p>
<p>content-box：默认值，如果设置一个元素宽为100px,那么这个元素内容区有100px宽，并且任何边框和内边距的宽度都会增加到最后绘制出来的元素宽度中。</p>
<p>border-box：告诉浏览器设置的边框和内边距的值是包含在width中的，不包括margin</p>
<h3 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。也就是说在渲染script标签之后的文档之前，不等待后续加载的文档元素，读到就开始加载和执行，这样就会阻塞后续文档的加载。</p>
<p>defer属性：当html解析遇到带有defer属性的script标签，不会阻塞html文件的解析，而是异步加载js脚本，直到html文件解析完成，再去执行js文件，执行顺序是按照js脚本在文档中的声明顺序，执行完毕后触发DOMContentLoaded事件。</p>
<p>async属性：当html解析遇到带有async属性的script标签，不会阻塞html文件的解析，而是异步加载js脚本，当js脚本加载完成后如果html还没解析完成会阻塞html文件解析，执行加载好的js文件，执行完继续解析html文件。执行顺序是按照先加载完成的js脚本先执行，DOMContentLoaded事件发生在js脚本执行之前或之后，取决于js文件加载完成在html解析完成前还是后。</p>
<p>两个属性都是用于外联js脚本。 </p>
<ul>
<li>DOMContentLoaded和load事件的区别：</li>
</ul>
<p>DOMContentLoaded：当初始的HTML文档完全加载和解析完成之后，DOMContentLoaded事件被触发，则无需等待样式表，图像和子框架的完全加载。可以理解为页面DOM加载完成后触发。</p>
<p>load：当整个页面及所有依赖资源都已经加载完成时触发。</p>
<h3 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p>
<p>常用的meta标签：<br>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2） <code>keywords</code>，页面关键词：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> = <span class="string">&quot;keywords&quot;</span> <span class="attr">content</span> = <span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）<code>description</code>，页面描述：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> = <span class="string">&quot;description&quot;</span> <span class="attr">content</span> = <span class="string">&quot;想要描述的内容&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>refresh</code>，页面重定向和刷新：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span> = <span class="string">&quot;refresh&quot;</span> <span class="attr">content</span> = <span class="string">&quot;0;url=&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）<code>viewport</code>，适配移动端，开发人员可以控制视口的大小和比例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span> = <span class="string">&quot;viewport&quot;</span> <span class="attr">content</span> = <span class="string">&quot;width = device-width, initial-scale = 1, maximum-scale = 1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>width viewport</code> ：宽度(数值/device-width) </li>
<li><code>height viewport</code> ：高度(数值/device-height) </li>
<li><code>initial-scale</code> ：初始缩放比例 </li>
<li><code>maximum-scale</code> ：最大缩放比例 </li>
<li><code>minimum-scale</code> ：最小缩放比例 </li>
<li><code>user-scalable</code> ：是否允许用户缩放(yes/no）</li>
</ul>
<h3 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h3><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul>
<li>header：定义文档的页眉 头部 </li>
<li>nav：定义导航链接的部分 </li>
<li>footer：定义文档或节的页脚 底部 </li>
<li>article：定义文章。 </li>
<li>section：定义文档中的节（section、区段） </li>
<li>aside：定义其所处内容之外的内容 侧边 </li>
</ul>
<h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span> = <span class="string">&#x27;&#x27;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> = <span class="string">&#x27;true&#x27;</span> &gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>controls 控制面板 </li>
<li>autoplay 自动播放 </li>
<li>loop = ‘true’ 循环播放 </li>
</ul>
<p>（2）video视频</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span> = <span class="string">&#x27;&#x27;</span> <span class="attr">poster</span> = <span class="string">&#x27;imgs/aa.jpg&#x27;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。 </li>
<li>controls 控制面板 </li>
<li>width </li>
<li>height </li>
</ul>
<p>（3）source标签<br>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span> = <span class="string">&#x27;aa.flv&#x27;</span> <span class="attr">type</span> = <span class="string">&#x27;video/flv&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span>   `</span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span> = <span class="string">&#x27;aa.mp4&#x27;</span> <span class="attr">type</span> = <span class="string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p>
<ul>
<li>email ：能够验证当前输入的邮箱地址是否合法 </li>
<li>url ： 验证URL </li>
<li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。 </li>
<li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。 </li>
<li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值 </li>
<li>color ： 提供了一个颜色拾取器 </li>
<li>time ： 时分秒 </li>
<li>date ： 日期选择年月日 </li>
<li>datetime ： 时间和日期(目前只有Safari支持) </li>
<li>datetime-local ：日期时间控件 </li>
<li>week ：周控件 </li>
<li>month：月控件 </li>
</ul>
<p><strong>表单属性：</strong></p>
<ul>
<li>placeholder ：提示信息 </li>
<li>aut<a href="">ofo</a>cus ：自动获取焦点 </li>
<li>autocomplete=“on” 或者 autocomplete=“off” 使用这个属性需要有两个前提：  <ul>
<li>必须表单提交过 </li>
<li>必须有name属性。 </li>
</ul>
</li>
<li>required：要求输入框不能为空，必须有值才能够提交。 </li>
<li>pattern=” “ 里面写入想要的正则模式，例如手机号patte=”^(+86)?\d{10}$” </li>
<li>multiple：可以选择多个文件或者多个邮箱 </li>
<li>form=” form表单的ID” </li>
</ul>
<p><strong>表单事件：</strong></p>
<ul>
<li>oninput 每当input里的输入框内容发生变化都会触发此事件。 </li>
<li>oninvalid 当验证不通过时触发此事件。 </li>
</ul>
<h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul>
<li>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少 </li>
<li>meter标签：用来显示剩余容量或剩余库存（IE、Safari不支持）  <ul>
<li>high/low：规定被视作高/低的范围 </li>
<li>max/min：规定最大/小值 </li>
<li>value：规定当前度量值 </li>
</ul>
</li>
</ul>
<p>设置规则：min &lt; low &lt; high &lt; max</p>
<h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul>
<li>document.querySelector() </li>
<li>document.querySelectorAll() </li>
</ul>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p>
<h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储 </li>
<li>sessionStorage - 针对一个 session 的数据存储 </li>
</ul>
<h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul>
<li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放： </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span> = <span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span> = <span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span> = <span class="string">&quot;200&quot;</span> <span class="attr">height</span> = <span class="string">&quot;100&quot;</span>&gt;</span>&lt;/canvas``&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准 </li>
<li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘ </li>
</ul>
<p><strong>总结：</strong><br>（1）新增语义化标签：nav、header、footer、aside、section、article<br>（2）音频、视频标签：audio、video<br>（3）数据存储：localStorage、sessionStorage<br>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）<br>（5）input标签新增属性：placeholder、autocomplete、aut<a href="">ofo</a>cus、required<br>（6）history API：go、forward、back、pushstate</p>
<p><strong>移除的元素有：</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u; </li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<ul>
<li>说说Web Workers：</li>
</ul>
<p>Web Workers就是在JS创建多线程环境，允许主线程创建Worker线程将任务分配给这些线程运行，这样在主线程运行的同时就会在后台并行运行worker线程，互不干扰。</p>
<p>使用：使用new命令调用Worker构造函数新建一个线程，主线程使用worker.postMessage方法向worker发送消息，通过worker.onmessage指定监听函数接收子线程发回来的消息。</p>
<p>注意点：</p>
<p>1、分配给worker线程的脚本文件必须与主线程脚本文件同源</p>
<p>2、worker线程无法读取主线程所在页面的DOM对象，也无法使用document、window、parent对象，可以使用navigator与location对象。</p>
<p>3、子线程和主线程不在同一个上下文环境不能直接通信，必须通过消息完成</p>
<p>4、子线程不能执行alert方法与confirm方法，但可以通过XMLHttpRequest对象发送AJAX请求</p>
<p>5、子线程无法读取本地文件，所加载的脚本必须来自网络</p>
<h3 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时会用到image标签的srcset属性。srcset属性用于设置不同屏幕密度下，image会自动加载不同的图片。用法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;image-128.png&quot;</span> <span class="attr">srcset</span> = <span class="string">&quot;image-256.png 2x&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p>
<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片的话，加载会很慢。所以就有了新的srcset标准。代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> = <span class="string">&quot;image-128.png&quot;</span> <span class="attr">srcset</span> = <span class="string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span> <span class="attr">sizes</span> = <span class="string">&quot;(max-width: 360px) 340px, 128px&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于srcset里面出现了一个w单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>
<p>sizes语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sizes=&quot;[media query] [length], [media query] [length] ... &quot;</span><br></pre></td></tr></table></figure>

<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>
<h3 id="8-display的block、inline和inline-block的区别"><a href="#8-display的block、inline和inline-block的区别" class="headerlink" title="8. display的block、inline和inline-block的区别"></a>8. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性。<br>　（2）<strong>inline</strong>：元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不可以设置垂直方向的padding和margin。<br>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<p>对于行内元素和块级元素，其特点如下：<br><strong>（1）行内元素</strong></p>
<ul>
<li>设置宽高无效 </li>
<li>对margin设置左右方向有效，而上下无效，padding设置都无效 </li>
<li>不会自动换行 </li>
</ul>
<p><strong>（2）块级元素</strong></p>
<ul>
<li>可以设置宽高 </li>
<li>设置margin和padding都有效 </li>
<li>可以自动换行　　　 </li>
<li>多个块状，默认排列从上到下</li>
</ul>
<h3 id="9-HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#9-HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="9. HTML5的离线储存怎么使用，它的工作原理是什么"></a>9. HTML5的离线储存怎么使用，它的工作原理是什么</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p><strong>原理：</strong>HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
<p><strong>使用方法：</strong><br>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;en&quot;</span> <span class="attr">manifest</span> = <span class="string">&quot;index.manifest&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）在如下 cache.manifest 文件的编写离线存储的资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js/app.js</span><br><span class="line">    css/style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse/logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    / /offline.html</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。 </li>
<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。 </li>
<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。 </li>
</ul>
<p>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p>
<p><strong>如何更新缓存：</strong><br> （1）更新 manifest 文件<br> （2）通过 javascript 操作<br> （3）清除浏览器缓存</p>
<p><strong>注意事项：</strong><br> （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。<br> （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。<br> （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。<br> （4）FALLBACK 中的资源必须和 manifest 文件同源。<br> （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。<br> （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。<br> （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h3 id="10-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#10-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="10. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>10. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h3><ul>
<li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 </li>
<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>
</ul>
<h3 id="11-label-的作用是什么？如何使用？"><a href="#11-label-的作用是什么？如何使用？" class="headerlink" title="11. label 的作用是什么？如何使用？"></a>11. label 的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<ul>
<li>使用方法1： </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mobile&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用方法2： </li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="12-Canvas-和-SVG-有什么区别？"><a href="#12-Canvas-和-SVG-有什么区别？" class="headerlink" title="12. Canvas 和 SVG 有什么区别？"></a>12. Canvas 和 SVG 有什么区别？</h3><ul>
<li>Canvas 是一种通过 JavaScript 来绘制 2D 图形的<strong>方法</strong>。Canvas 是逐像素来进行渲染的，因此当对 Canvas 进行缩放时，会出现锯齿或者失真的情况。 </li>
<li>SVG 是一种使用 XML 描述 2D 图形的<strong>语言</strong>。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</li>
</ul>
<h3 id="13-head-标签中必不少的是？"><a href="#13-head-标签中必不少的是？" class="headerlink" title="13. head 标签中必不少的是？"></a>13. head 标签中必不少的是？</h3><p> 标签用于定义文档的头部，它是所有头部元素的容器。<code>head</code>中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。 </p>
<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, &lt;title&gt;。</span><br></pre></td></tr></table></figure>

<p>其中<code>&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>
<h3 id="14-浏览器乱码的原因是什么？如何解决？"><a href="#14-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="14. 浏览器乱码的原因是什么？如何解决？"></a>14. 浏览器乱码的原因是什么？如何解决？</h3><p><strong>产生乱码的原因：</strong></p>
<ul>
<li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码。反之也会出现乱码； </li>
<li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码； </li>
<li>浏览器不能自动检测网页编码，造成网页乱码。 </li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>使用软件进行编辑HTML网页内容； </li>
<li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码； </li>
<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换</li>
</ul>
<h3 id="15-渐进增强和优雅降级之间的区别"><a href="#15-渐进增强和优雅降级之间的区别" class="headerlink" title="15. 渐进增强和优雅降级之间的区别"></a>15. 渐进增强和优雅降级之间的区别</h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果，交互等方面的改进和追加功能，以达到更好的用户体验。**<br><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>
<p><strong>两者区别：</strong></p>
<ul>
<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要； </li>
<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ul>
<h3 id="14-什么是WebGL-它有什么优点"><a href="#14-什么是WebGL-它有什么优点" class="headerlink" title="14.什么是WebGL,它有什么优点?"></a>14.什么是WebGL,它有什么优点?</h3><p>WebGL（全写 Web Graphics Library ）是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定， WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。显然， WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。</p>
<p>WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：</p>
<p>第一，它通过HTML脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持 ;</p>
<p>第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。</p>
<p>通俗说WebGL中 canvas 绘图中的 3D 版本。因为原生的 WebGL 很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。</p>
<h3 id="15-哪种情况下应该使用small标签？"><a href="#15-哪种情况下应该使用small标签？" class="headerlink" title="15.哪种情况下应该使用small标签？"></a>15.哪种情况下应该使用<code>small</code>标签？</h3><p><code>small</code>标签一般使用场景是在版权信息和法律文本里使用，也可以在标题里使用标注附加信息（bootstrap中可见），但不可以用来创建副标题。</p>
<h3 id="16-如果你有一个搜索结果页面，你想高亮搜索的关键词。什么HTML-标签可以使用"><a href="#16-如果你有一个搜索结果页面，你想高亮搜索的关键词。什么HTML-标签可以使用" class="headerlink" title="16.如果你有一个搜索结果页面，你想高亮搜索的关键词。什么HTML 标签可以使用?"></a>16.如果你有一个搜索结果页面，你想高亮搜索的关键词。什么HTML 标签可以使用?</h3><p>使用<mark>标签高亮文本</p>
<h3 id="17-scope属性的作用"><a href="#17-scope属性的作用" class="headerlink" title="17.scope属性的作用"></a>17.scope属性的作用</h3><p><code>scope</code>属性是一个布尔属性，如果使用该属性，那样式只会应用到<code>style</code>元素的父元素及其子元素</p>
<h3 id="18-使用XHTML有什么局限"><a href="#18-使用XHTML有什么局限" class="headerlink" title="18.使用XHTML有什么局限"></a>18.使用XHTML有什么局限</h3><p><code>xhtml</code>语法要求严格，必须有<code>head、body</code>,每个DOM必须闭合，空标签也必须闭合，另外要在属性值上使用双引号，一旦遇到错误就会停止解析，并显示错误信息。</p>
<h3 id="19-data-属性的作用是什么"><a href="#19-data-属性的作用是什么" class="headerlink" title="19.data-属性的作用是什么"></a>19.data-属性的作用是什么</h3><p><code>data-</code>为开发者提供自定义的属性，这些属性集可以通过对象的<code>dataset</code>属性获取，不支持该属性的浏览器可以通过<code>getAttribute</code>方法获取，<code>data-</code>后面的以连字符分隔的多个单词获取使用驼峰风格。</p>
<p>当没有合适的属性与元素时，自定义的<code>data</code>属性是能够存储页面或<code>APP</code>的私有的自定义数据</p>
<h3 id="21-网站SEO怎么处理"><a href="#21-网站SEO怎么处理" class="headerlink" title="21.网站SEO怎么处理"></a>21.网站SEO怎么处理</h3><p>①网站结构布局优化：</p>
<ul>
<li>网站结构层次越少，越容易被抓取，也就容易被收录。</li>
<li>控制首页链接数量：可以爬取到内页</li>
<li>扁平化的目录层次：尽量在“蜘蛛”跳转三次可以到达任意一个内页</li>
<li>导航优化：图片标签加上<code>alt</code>和<code>title</code></li>
<li>网站的结构布局</li>
<li>控制页面的大小，减少HTTP请求，提高网站加载速度</li>
</ul>
<p>②网页代码优化</p>
<ul>
<li><code>&lt;title&gt;</code>标签：强调重点！</li>
<li><code>&lt;meta keywords&gt;</code>标签：强调重点！</li>
<li><code>&lt;meta description&gt;</code>标签：高度概括网页内容</li>
<li><code>&lt;body&gt;</code>标签：代码语义化</li>
<li><code>&lt;a&gt;</code>标签：加上<code>title</code>加以说明</li>
<li><code>&lt;caption&gt;</code>标签：表格使用该标签说明标题</li>
<li><code>&lt;strong&gt;&lt;em&gt;</code>标签：需要强调时使用，突出关键词</li>
<li><code>&lt;iframe&gt;</code>框架蜘蛛不会抓取</li>
<li><code>diasplay:none</code>会被搜索引擎过滤掉，应当设置<code>z-index</code>或设置到浏览器显示器之外</li>
</ul>
<h3 id="22-减少-dom-数量的办法"><a href="#22-减少-dom-数量的办法" class="headerlink" title="22.减少 dom 数量的办法"></a>22.减少 dom 数量的办法</h3><ul>
<li>可以使用伪元素，阴影实现的内容尽量不使用DOM实现，如清除浮动、样式实现等；</li>
<li>按需加载，减少不必要的渲染；</li>
<li>结构合理，语义化标签</li>
</ul>
<h3 id="一次性给你大量的-dom-怎么优化？"><a href="#一次性给你大量的-dom-怎么优化？" class="headerlink" title="一次性给你大量的 dom 怎么优化？"></a>一次性给你大量的 dom 怎么优化？</h3><ul>
<li>缓存DOM对象：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不缓存DOM查询结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>).length; i++) &#123;</span><br><span class="line">	<span class="comment">//每次循环都会计算length，频繁进行DOM查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存DOM查询结果</span></span><br><span class="line"><span class="keyword">const</span> length = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>).length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;length; i++) &#123;</span><br><span class="line">	<span class="comment">//缓存length，只进行一次DOM查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>文档片段：</li>
</ul>
<p>利用 document.cerateDocumentFragment() 方法创建文档碎片节点，创建的是一个虚拟的节点对象。向这个节点添加dom节点，修改dom节点并不会影响到真实的dom结构。</p>
<p>我们可以利用这一点先将我们需要修改的dom一并修改完，保存至文档碎片中，然后用文档碎片一次性的替换真实的dom节点。与虚拟dom类似，同样达到了不频繁修改dom而导致的重排更重绘的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fragment = <span class="built_in">document</span>.certaeDocumentFragment();</span><br><span class="line"><span class="keyword">const</span> operationDomHandle = <span class="function">(<span class="params">fragment</span>) =&gt;</span>&#123;</span><br><span class="line">     <span class="comment">//操作</span></span><br><span class="line">&#125;</span><br><span class="line">operationDomHandle(fragment);</span><br><span class="line"><span class="comment">//然后最后再替换</span></span><br><span class="line">rootElem.replaceChild(fragment,oldDom);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>用innerHtml 代替高频的appendChilde</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/20/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/HTML/" data-id="cl0x9xz3u000ntsug2ec58emg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-大三上日报" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/17/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/" class="article-date">
  <time datetime="2021-11-17T03:42:21.000Z" itemprop="datePublished">2021-11-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">大三上日报</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/17/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">自律生活，从我做起</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3>2021-11-17</h3>
<h4>个人博客</h4>

<ul>
<li>新增文章加密功能 </li>
<li>更换背景图片</li>
</ul>
<h4 id="小程序："><a href="#小程序：" class="headerlink" title="小程序："></a>小程序：</h4><p>1、新的<code>js</code>库：</p>
<ul>
<li><code>fly.js</code>：类似于<code>axios</code>的<code>HTTP</code>请求库，适用于小程序</li>
<li><code>jsonwebtoken.js</code>：实现token技术的一种解决方案。</li>
</ul>
<p>2、</p>
<p>分包<code>API</code>：在<code>app.json</code>中配置，配置完成后被分包出来的页面路径会发生改变，需要更改代码用到的原路径，体验较差~</p>
<p>分包预加载<code>API</code>：也是在<code>app.json</code>中配置</p>
<h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4><p><code>acwing</code>第二章：栈，队列，单调栈，单调队列，<code>KMP</code>算法</p>
<h3>2021-11-18</h3>

<h4 id="个人博客："><a href="#个人博客：" class="headerlink" title="个人博客："></a>个人博客：</h4><p>搭建<code>ESC</code>云服务器失败，阿里云使用体验太差了，但至少学会了<code>nginx</code>和云服务器<code>linux</code>和<code>git</code>环境的基本搭建</p>
<h3>2021-11-19</h3>

<h4 id="个人博客：-1"><a href="#个人博客：-1" class="headerlink" title="个人博客："></a>个人博客：</h4><p>搭建ESC云服务器成功，但是需要备案服务号才可以访问网站，等有时间有钱再去弄吧~</p>
<h4 id="Vue："><a href="#Vue：" class="headerlink" title="Vue："></a>Vue：</h4><p>学习了<code>Vue3</code>的<code>watch</code>监视属性、生命周期以及<code>hook</code>函数</p>
<h4 id="算法：-1"><a href="#算法：-1" class="headerlink" title="算法："></a>算法：</h4><p>完成区间合并以及区间数的代码理解与打卡</p>
<h3>2021-11-20</h3>

<h4 id="Vue：-1"><a href="#Vue：-1" class="headerlink" title="Vue："></a><code>Vue</code>：</h4><p>完成后台管理系统角色管理页面的添加、编辑以及扩展功能（P82）</p>
<p>学习了<code>Vue3</code>的其他<code>component API</code></p>
<h4 id="面试准备："><a href="#面试准备：" class="headerlink" title="面试准备："></a>面试准备：</h4><p>开始<code>HTML</code>部分的准备</p>
<h3>2021-11-21</h3>

<h4 id="六级："><a href="#六级：" class="headerlink" title="六级："></a>六级：</h4><p>背单词以及阅读两篇短文</p>
<h4 id="Vue：-2"><a href="#Vue：-2" class="headerlink" title="Vue："></a>Vue：</h4><p><code>Vue</code>全家桶完结~~~</p>
<h3>2021-11-22</h3>

<h4 id="六级：-1"><a href="#六级：-1" class="headerlink" title="六级："></a>六级：</h4><p>背单词以及阅读两篇短文</p>
<h4 id="面试准备：-1"><a href="#面试准备：-1" class="headerlink" title="面试准备："></a>面试准备：</h4><p>巩固<code>HTML</code>基础</p>
<h3>2021-11-23</h3>

<h4 id="算法：-2"><a href="#算法：-2" class="headerlink" title="算法："></a>算法：</h4><p>打卡链表与栈</p>
<h3>2021-11-24</h3>

<h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue:"></a>Vue:</h4><p>完成后台管理系统权限功能开发</p>
<h4 id="最优化："><a href="#最优化：" class="headerlink" title="最优化："></a>最优化：</h4><p>学习了凸集凸函数知识</p>
<h3>2021-11-25</h3>

<h4 id="时间序列："><a href="#时间序列：" class="headerlink" title="时间序列："></a>时间序列：</h4><p>学习了第二章与第三章内容</p>
<h4 id="面试准备：-2"><a href="#面试准备：-2" class="headerlink" title="面试准备："></a>面试准备：</h4><p>开始<code>CSS</code>面试题准备</p>
<h3>2021-11-26</h3>

<h4 id="R语言："><a href="#R语言：" class="headerlink" title="R语言："></a>R语言：</h4><p>B站课程完成三分之一</p>
<h4 id="算法：-3"><a href="#算法：-3" class="headerlink" title="算法："></a>算法：</h4><p>打卡表达式求值、模拟队列以及单调栈题目</p>
<h3>2021-11-27</h3>

<h4 id="R语言：-1"><a href="#R语言：-1" class="headerlink" title="R语言："></a>R语言：</h4><p>学会了基本运用</p>
<h3>2021-11-28</h3>

<h4 id="Vue：-3"><a href="#Vue：-3" class="headerlink" title="Vue："></a>Vue：</h4><p>完成后台管理系统商品分类页面开发（ P110）</p>
<p>新的组件库：</p>
<p><code>vue-table-with-tree-grid</code>：树形表格组件库</p>
<h3>2021-11-29</h3>

<h4 id="算法：-4"><a href="#算法：-4" class="headerlink" title="算法："></a>算法：</h4><p>打卡单调队列、滑动窗口题目</p>
<p>学习了<code>Trie</code>、合并集以及手写堆</p>
<h3>2021-11-30</h3>

<h4 id="时间序列：-1"><a href="#时间序列：-1" class="headerlink" title="时间序列："></a>时间序列：</h4><p>学习了第三章<code>ARMA</code>模型</p>
<h3>2021-12-01</h3>

<h4 id="属性数据："><a href="#属性数据：" class="headerlink" title="属性数据："></a>属性数据：</h4><p>学习了列联表</p>
<h4 id="算法：-5"><a href="#算法：-5" class="headerlink" title="算法："></a>算法：</h4><p>学习了哈希表以及读懂<code>KMP</code>代码模板</p>
<h3>2021-12-02</h3>

<h4 id="最优化：-1"><a href="#最优化：-1" class="headerlink" title="最优化："></a>最优化：</h4><p>学习了第一章</p>
<h4 id="算法：-6"><a href="#算法：-6" class="headerlink" title="算法："></a>算法：</h4><p>打卡<code>KMP</code>与<code>trie</code>题目</p>
<h3>2021-12-03</h3>

<h4 id="算法：-7"><a href="#算法：-7" class="headerlink" title="算法："></a>算法：</h4><p>打卡最大异或对、合并集合、连通块中点的数量以及食物链题目</p>
<h3>2021-12-04</h3>

<h4 id="Vue：-4"><a href="#Vue：-4" class="headerlink" title="Vue："></a>Vue：</h4><p>完成后台管理系统分类参数页面的开发（P125）</p>
<h3>2021-12-05</h3>

<h4 id="应用多元统计："><a href="#应用多元统计：" class="headerlink" title="应用多元统计："></a>应用多元统计：</h4><p>学习了判别分析、聚类分析、主成分分析与因子分析</p>
<h4 id="时间序列：-2"><a href="#时间序列：-2" class="headerlink" title="时间序列："></a>时间序列：</h4><p>学习了<code>AR、MA与ARMA</code>模型</p>
<h3>2021-12-06</h3>

<h4 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue:"></a>Vue:</h4><p>完善后台管理系统分类参数页面开发（P131）</p>
<h3>2021-12-07~2021-12-12</h3>

<h4 id="随机过程："><a href="#随机过程：" class="headerlink" title="随机过程："></a>随机过程：</h4><p>学习了平稳过程</p>
<h4 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h4><p>学习了浏览器原理与透视HTTP协议</p>
<h4 id="面试准备：-3"><a href="#面试准备：-3" class="headerlink" title="面试准备："></a>面试准备：</h4><p>准备JS面试题</p>
<h4 id="算法：-8"><a href="#算法：-8" class="headerlink" title="算法："></a>算法：</h4><p>复习算法基础并总结题解</p>
<h3>2021-12-13</h3>

<h4 id="tensorFlow："><a href="#tensorFlow：" class="headerlink" title="tensorFlow："></a><code>tensorFlow</code>：</h4><p>学习了基本操作</p>
<h4 id="六级：-2"><a href="#六级：-2" class="headerlink" title="六级："></a>六级：</h4><p>做了阅读题</p>
<h4 id="算法：-9"><a href="#算法：-9" class="headerlink" title="算法："></a>算法：</h4><p>学习了<code>dfs</code>和<code>bfs</code>，打卡了堆排序题目</p>
<h3>2021-12-15</h3>

<h4 id="算法：-10"><a href="#算法：-10" class="headerlink" title="算法："></a>算法：</h4><p>打卡模拟堆与散列表题目</p>
<h4 id="属性数据分析："><a href="#属性数据分析：" class="headerlink" title="属性数据分析："></a>属性数据分析：</h4><p>学习第二三章</p>
<h4 id="TensorFlow-js："><a href="#TensorFlow-js：" class="headerlink" title="TensorFlow.js："></a><code>TensorFlow.js</code>：</h4><p>学习了读取<code>csv</code>数据以及制作散点图；</p>
<p><code>http-serve</code>可以设置参数控制是否跨域请求</p>
<h4 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h4><p>感情这种东西记不得，先让自己好好改变吧，还是存在很多的毛病。</p>
<h3>2021-12-18</h3>

<h4 id="六级：-3"><a href="#六级：-3" class="headerlink" title="六级："></a>六级：</h4><p>完成一套六级模拟题</p>
<h4 id="Vue管理系统"><a href="#Vue管理系统" class="headerlink" title="Vue管理系统:"></a>Vue管理系统:</h4><p>完成商品参数页面开发（P140）</p>
<h3>2021-12-19</h3>

<h4 id="马克思："><a href="#马克思：" class="headerlink" title="马克思："></a>马克思：</h4><p>复习了第一二章选择题</p>
<h4 id="时间序列：-3"><a href="#时间序列：-3" class="headerlink" title="时间序列："></a>时间序列：</h4><p>复习了<code>ARMA</code>模型</p>
<h4 id="多元统计："><a href="#多元统计：" class="headerlink" title="多元统计："></a>多元统计：</h4><p>复习了判别分析</p>
<h4 id="算法：-11"><a href="#算法：-11" class="headerlink" title="算法："></a>算法：</h4><p>搞懂了树的重点题目</p>
<h3>2021-12-20</h3>

<h4 id="马克思：-1"><a href="#马克思：-1" class="headerlink" title="马克思："></a>马克思：</h4><p>复习了第三四章选择题</p>
<h4 id="算法：-12"><a href="#算法：-12" class="headerlink" title="算法："></a>算法：</h4><p>打卡了<code>DFS</code>排列数以及<code>n</code>皇后问题</p>
<h4 id="随机过程：-1"><a href="#随机过程：-1" class="headerlink" title="随机过程："></a>随机过程：</h4><p>复习了第二章</p>
<h4 id="属性数据：-1"><a href="#属性数据：-1" class="headerlink" title="属性数据："></a>属性数据：</h4><p>复习了第三四章</p>
<h4 id="TensorFlow："><a href="#TensorFlow：" class="headerlink" title="TensorFlow："></a>TensorFlow：</h4><p>学习了如何将数据标准化、建立模型与线性模型优化</p>
<h4 id="最优化：-2"><a href="#最优化：-2" class="headerlink" title="最优化："></a>最优化：</h4><p>学习了0.618法、二分法和三点插值法</p>
<h3>2021-12-21</h3>

<h4 id="随机过程：-2"><a href="#随机过程：-2" class="headerlink" title="随机过程："></a>随机过程：</h4><p>复习了均方分析和平稳过程</p>
<h4 id="Vue：-5"><a href="#Vue：-5" class="headerlink" title="Vue："></a>Vue：</h4><p>完成后台管理系统添加商品的开发（P158）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/17/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/" data-id="cl0x9xz2g0001tsug43ee2ojs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网站介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/15/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/" class="article-date">
  <time datetime="2021-11-15T13:07:54.176Z" itemprop="datePublished">2021-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">网站介绍</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/15/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">网站介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>欢迎来到我的博客，该网站目前只作为前端学习过程中记录笔记之用，往后会一步步完善功能与主题。</p>
<h2>学习历程</h2>

<ul>
<li>学习起始时间：2021/07</li>
<li>已学课程：<code>HTML、CSS、Javascript、ES6、AJAX、axios、Echart、vue...</code></li>
<li>已完成项目：网易云小程序、<code>Vue</code>后台管理网站</li>
<li>近期目标：顺利找到实习</li>
<li>博客错误或者不理解欢迎交流，vx：al1691929357</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/15/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/" data-id="cl0x9xz350008tsugcnakhjr9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%8B%E7%BB%8D/" rel="tag">介绍</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/TensorFlow-js/">TensorFlow.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%97%A5%E6%8A%A5/">大三上日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E6%97%A5%E6%8A%A5/">大三寒假日报</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/">网站介绍</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%8B%E7%BB%8D/" rel="tag">介绍</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BB%8B%E7%BB%8D/" style="font-size: 10px;">介绍</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/18/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/">手写系列</a>
          </li>
        
          <li>
            <a href="/2022/03/12/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
          </li>
        
          <li>
            <a href="/2022/03/08/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/nodeJS/">node.js</a>
          </li>
        
          <li>
            <a href="/2022/02/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/webpack%E5%9F%BA%E7%A1%80/">webpack基础</a>
          </li>
        
          <li>
            <a href="/2022/02/22/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/">项目相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 ChenZehong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>